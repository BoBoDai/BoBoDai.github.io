

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="BoBoDai">
  <meta name="keywords" content="">
  
    <meta name="description" content="进程都是共享CPU以及主存资源的，如果一个程序没有空间可用时，会破坏别的进程的内存。 为了更有效的管理内存并少出错，提出了一种对主存的抽象概念，叫虚拟内存。 虚拟内存提供了三个重要的能力  它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，高效的使用了主存。 它为每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP深入理解计算机系统-第九章-虚拟内存">
<meta property="og:url" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="Cactus Hole">
<meta property="og:description" content="进程都是共享CPU以及主存资源的，如果一个程序没有空间可用时，会破坏别的进程的内存。 为了更有效的管理内存并少出错，提出了一种对主存的抽象概念，叫虚拟内存。 虚拟内存提供了三个重要的能力  它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，高效的使用了主存。 它为每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.1.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.2.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.3.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.4.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.5.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.6.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.7.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.8.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.9.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.10.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.11.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.12.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.13.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.14.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.15.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.16.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.17.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.18.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.19.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.20.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.21.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.22.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.23.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.24.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.25.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.26.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.27.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.28.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.29.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.30.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.31.png">
<meta property="og:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.32.png">
<meta property="article:published_time" content="2025-01-10T01:33:30.000Z">
<meta property="article:modified_time" content="2025-02-17T09:06:40.562Z">
<meta property="article:author" content="BoBoDai">
<meta property="article:tag" content="计算机系统">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.1.png">
  
  
  
  <title>CSAPP深入理解计算机系统-第九章-虚拟内存 - Cactus Hole</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>BoBoBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CSAPP深入理解计算机系统-第九章-虚拟内存"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-01-10 09:33" pubdate>
          January 10, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          90 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CSAPP深入理解计算机系统-第九章-虚拟内存</h1>
            
            
              <div class="markdown-body">
                
                <p>进程都是共享CPU以及主存资源的，如果一个程序没有空间可用时，会破坏别的进程的内存。</p>
<p>为了更有效的管理内存并少出错，提出了一种对主存的抽象概念，叫虚拟内存。</p>
<p>虚拟内存提供了三个重要的能力</p>
<ul>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，高效的使用了主存。</li>
<li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li>
<li>它保护了每个进程的地址空间不被其他进程破坏。</li>
</ul>
<p>虚拟内存沉默地、自动地工作，但是还需要理解它</p>
<ul>
<li><p>虚拟内存是核心的</p>
<p>虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中担任重要角色。</p>
</li>
<li><p>虚拟内存是强大的</p>
<p>虚拟内存给予应用程序强大的能力，可以创建和销毁内存片、将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存。</p>
</li>
<li><p>虚拟内存是危险的</p>
<p>每次应用程序引用一个变量、间接引用一个指针，或者调用一个 malloc 的动态分配程序时，就会和虚拟内存发生交互。如果使用不当，程序就可以立即崩溃于“段错误”或者“保护错误”。</p>
</li>
</ul>
<p>从两部分看虚拟内存</p>
<p>第一部分描述虚拟内存是如何工作的。第二部分描述的是应用程序如何管理虚拟内存。</p>
<h2 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h2><p>主存被组织成一个由M个连续的字节大小的单元组成的数组。</p>
<p>每字节都有一个唯一的<strong>物理地址</strong>。</p>
<p>第一个字节的地址为0，下一个为1，再下一个为2，CPU访问内存最自然的方式就是使用物理地址，这种方式称为<strong>物理寻址</strong>。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.1.png" srcset="/img/loading.gif" lazyload alt="image-9.1"></p>
<p>上图读取物理地址4处开始的4字节字。当CPU执行这条加载指令时，会生成一个有效的物理地址，通过内存总线，传递给主存。主存从物理地址取出四字节字，返回给cpu放到一个寄存器里。</p>
<p>早期PC使用物理寻址，现代计算机使用虚拟寻址。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.2.png" srcset="/img/loading.gif" lazyload alt="image-9.2"></p>
<p>CPU通过虚拟地址（VA）来访问主存，虚拟地址在被送到内存之前先转换成适当的物理地址。将虚拟地址转为物理地址的行为叫做地址翻译。CPU上的内存管理单元（Memory Management Unit）为专用硬件，利用存放在主存中的地址表来动态翻译虚拟地址。</p>
<h2 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h2><p>地址空间是一个非负整数地址的有序集合。</p>
<p>如果地址空间中的整数是连续的，那么我们说是一个线性地址空间。</p>
<p>我们假设使用的是线性地址空间，CPU从一个有N&#x3D;2^n个地址的地址空间生成虚拟地址，这个地址空间称为虚拟地址空间。</p>
<ul>
<li>虚拟地址空间</li>
</ul>
<p>一个地址空间的大小是由表示最大地址所需要的位数来描述。一个包含 N&#x3D;2^n 个地址的虚拟地址空间就叫做一个n位地址空间。现在多为32位或64位。</p>
<ul>
<li>物理地址空间</li>
</ul>
<p>一个系统还有一个物理地址空间，对应于系统中物理内存的 M 个字节，M可以不为2的幂，未来简化讨论假定M&#x3D;2^m。</p>
<p>地址空间的概念区分了数据对象（字节）和他们的属性（地址）。</p>
<p>每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间，这是虚拟内存的基本思想。主存的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<h2 id="9-3-虚拟内存作为缓存工具"><a href="#9-3-虚拟内存作为缓存工具" class="headerlink" title="9.3 虚拟内存作为缓存工具"></a>9.3 虚拟内存作为缓存工具</h2><p>虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。</p>
<p>每字节都有唯一的虚拟地址，作为到数组的索引。磁盘上数组内容被缓存在主存中。</p>
<p>VM系统通过将虚拟内存分割为<strong>虚拟页</strong>（VP）的大小固定块来传输。</p>
<p>每个虚拟页的大小为P&#x3D;2^p字节。</p>
<p>同样物理内存被分割为物理页（PP），大小也为P字节物理页也称为页帧。</p>
<p>任意时刻虚拟页面的集合都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM 系统还未分配或创建的页。未分配的快没有任何数据和他们相关联，也不占用任何空间。</li>
<li>缓存的：当前已缓存在物理内存中的已分配页。</li>
<li>未缓存的：未缓存在物理内存中的已分配页。</li>
</ul>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.3.png" srcset="/img/loading.gif" lazyload alt="image-9.3"></p>
<p>上图是一个有8个虚拟页的小虚拟内存，虚拟页0和3还没有分配，所以在磁盘上还不存在。虚拟页1、4、6被缓存在物理内存中。页2、5、7已经被分配；但是并未缓存在主存中。</p>
<h3 id="9-3-1-DRAM缓存的组织结构"><a href="#9-3-1-DRAM缓存的组织结构" class="headerlink" title="9.3.1 DRAM缓存的组织结构"></a>9.3.1 DRAM缓存的组织结构</h3><p>SRAM缓存表示位于CPU和主存之间的L1、L2和L3高速缓存。</p>
<p>DRAM缓存表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</p>
<p>DRAM比SRAM要慢大约10倍，磁盘比DRAM慢大约100000多倍。</p>
<p>所以DRAM的不命中比SRAM不命中要昂贵的多，因为DRAM缓存不命中是需要磁盘来服务，SRAM不命中是需要DRAM来服务。</p>
<p>因为大大不命中处罚和访问第一个字节的开销，虚拟页往往很大，4KB～2MB。</p>
<p>由于大的不命中处罚，DRAM缓存是全关联的，任何虚拟页都可以放置在任何物理页中。</p>
<p>不命中时的替换策略也很重要，因为替换错了虚拟页的处罚也非常高，系统对DRAM缓存使用了更精密的替换算法。</p>
<p>DRAM缓存总是使用写回，而不是直写。</p>
<h3 id="9-3-2-页表"><a href="#9-3-2-页表" class="headerlink" title="9.3.2 页表"></a>9.3.2 页表</h3><p>虚拟内存系统必须有种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还需要确定这个虚拟内存存放在哪个物理页中。如果不命中，需要判断虚拟页在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换掉牺牲页。</p>
<p>这些功能通过软硬件结合实现，包括操作系统软件、MMU中的地址翻译硬件和一个存放在物理内存中叫页表的数据结构，页表将虚拟内存页映射到物理页。</p>
<p>每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.4.png" srcset="/img/loading.gif" lazyload alt="image-9.4"></p>
<p>页表就是一个页表条目（Page Table Entry）的数组。虚拟地址空间中每个页在页表中一个固定偏移量处都有一个PTE。</p>
<p>假设每个PTE是由一个有效位和一个n位地址字段组成的。有效位表明该虚拟页当前是否被缓存在DRAM中。如果设置的有效位，那么地址字段就表示DRAM中对应的物理页的起始位置，物理页中缓存了该虚拟页。如果没有有效位，那么一个空地址表示这个虚拟页还未被分配。否则这个地址应该指向该虚拟页在磁盘上的起始位置。</p>
<h3 id="9-3-3-页命中"><a href="#9-3-3-页命中" class="headerlink" title="9.3.3 页命中"></a>9.3.3 页命中</h3><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.5.png" srcset="/img/loading.gif" lazyload alt="image-9.5"></p>
<p>当CPU想要读包含在VP2中的虚拟内存的一个字时。</p>
<p>VP2被缓存在DRAM中。地址翻译硬件将虚拟地址作为索引来定位PTE2，并从内存中读取它。</p>
<p>因为设置了有效位，地址翻译硬件就知道VP2已经缓存在内存中了。所以它使用PTE中的物理内存地址，得到这个字的物理地址。</p>
<h3 id="9-3-4-缺页"><a href="#9-3-4-缺页" class="headerlink" title="9.3.4 缺页"></a>9.3.4 缺页</h3><p>DRAM缓存不命中为缺页。</p>
<p>CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位判断VP3未被缓存，并触发一个<strong>缺页异常</strong>。</p>
<p>缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如放在pp3中的vp4，如果vp4已经被修改了，内核就将它复制回磁盘（回写）。无论怎样都会修改VP4的页表条目。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.6.png" srcset="/img/loading.gif" lazyload alt="image-9.6"></p>
<p>接下来内核从磁盘中复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时会重新启动导致缺页的指令，该指令回把导致缺页的地址重新发送到地址翻译软件，现在VP3已经在主存中了，所以页面能正常由地址翻译正常处理了。</p>
<p>在虚拟内存的习惯说法中，快被称为页。在磁盘和内存之间传送页的活动叫做<code>交换</code>或者<code>页面调度</code>。页从磁盘换入DRAM和从DRAM中换出。</p>
<p>当有不命中发生时才换入页面的策略叫做按需页面调度。</p>
<h3 id="9-3-5-分配页面"><a href="#9-3-5-分配页面" class="headerlink" title="9.3.5 分配页面"></a>9.3.5 分配页面</h3><p>当操作系统分配一个新的虚拟内存页时，调用malloc，在磁盘上创建空间并更新PTE5，使它指向磁盘上这个新创建的页面。</p>
<h3 id="9-3-6-局部性"><a href="#9-3-6-局部性" class="headerlink" title="9.3.6 局部性"></a>9.3.6 局部性</h3><p>虚拟内存不会因为不命中处罚很大，担心页面调度会影响性能。</p>
<p>尽管在运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫工作集或者常驻集合。</p>
<p>初始开销中，也就是将工作集页面调度到内存中，之后对这个工具集的引用将导致命中不会产生额外的磁盘流量。</p>
<p>在将工作集页面调度到内存中之后，接下来对这个工作集的引用将导致命中，不会产生额外的磁盘流量。</p>
<p>只要程序有良好的时间局部性，虚拟内存就可以工作的很好。</p>
<p>如果工作集的大小超出了物理内存的大小，那么程序将产生抖动，页面不断的换进换出，性能像爬一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以利用Linux的getrusage函数监测缺页数量（以及许多其他的信息）</span><br></pre></td></tr></table></figure>

<h2 id="9-4-虚拟内存作为内存管理的工具"><a href="#9-4-虚拟内存作为内存管理的工具" class="headerlink" title="9.4 虚拟内存作为内存管理的工具"></a>9.4 虚拟内存作为内存管理的工具</h2><p>早期系统支持的是一个比物理内存更小的虚拟地址空间。然而虚拟地址还是一个有用的机制，其大大简化的内存管理，并提供了一种自然保护内存的方法。</p>
<p>之前假设是一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上，操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.7.png" srcset="/img/loading.gif" lazyload alt="image-9.7"></p>
<p>多个虚拟页面可以映射到同一个共享物理页面上。</p>
<p>VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。</p>
<ul>
<li><p>简化链接</p>
<p>独立的地址空间允许每个进程的内存映像使用相同的基本格式，无论代码和数据实际存放在何处。</p>
<p>代码段总是从虚拟地址0x400000开始。数据段跟在代码段之后，中间有一段符合要求的对其空白。</p>
<p>栈占据用户进程地址空间最高部分，并向下生长，这样极大的简化了链接器的设计和实现，运行链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</p>
</li>
<li><p>简化加载</p>
<p>讯内存使得容易想内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，把标记无效的（未被缓存的），将页表条目指向目标文件中适当的位置。</p>
<p>加载器从不从磁盘到内存实际复制任何数据。在每个页初次被使用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。</p>
</li>
</ul>
<p>将一组连续的虚拟页映射到任意一个文件中任意位置的表示法为内存映射。Linux提供一个mmap允许应用程序自己做内存映射。</p>
<ul>
<li><p>简化共享</p>
<p>独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将对应的虚拟页映射到不连续的物理页面。</p>
</li>
</ul>
<p>在一些情况还是需要进程来共享代码和数据。例如每个进程都要调用相同的操作系统内核代码，每个C都会调用C标准库中的程序，操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码调度副本，而不是在每个进程中都包含内核和C标准库的副本。</p>
<ul>
<li><p>简化内存分配</p>
<p>虚拟内存为向用户进程提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时，操作系统分配一个适当的数字（k）个连续的虚拟内存页面，并将他们映射到物理内存中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配k个连续的物理内存页面。页面可以随机地分散在物理内存中。</p>
</li>
</ul>
<h2 id="9-5-虚拟内存作为内存保护的工具"><a href="#9-5-虚拟内存作为内存保护的工具" class="headerlink" title="9.5 虚拟内存作为内存保护的工具"></a>9.5 虚拟内存作为内存保护的工具</h2><p>计算机不应该允许一个用户进程修改它的只读代码段，也不应该允许它读或者修改任何内核中的代码和数据结构。不应该读其他进程的私有内存，而且不允许修改任何与其他进程共享的虚拟页面，除非所有共享者都显式的允许它这么做。</p>
<p>独立的地址空间使得区分不同进程的私有内存变得容易。但是地址翻译机制可以用自然的方式扩展到提供更好的访问控制。因为每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，所以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.8.png" srcset="/img/loading.gif" lazyload alt="image-9.8"></p>
<p>每个PTE中已经添加了三个许可位。SUP位表示进程是否必须运行在内核模式下才能访问该页。</p>
<p>运行在内核模式下可以反问任何页面，但是运行在用户模式的进程只允许访问那些SUP为0的页面。READ位和WRITE位控制对页面的读和写访问。例如进程i运行在用户模式下，那么它有读VP0和读写VP1的权限。然而，不允许它访问VP2。</p>
<p>如果一个指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell一般将这种异常报告为，段错误。</p>
<h2 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h2><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.9.png" srcset="/img/loading.gif" lazyload alt="image-9.9"></p>
<p>地址翻译是一个N元素的虚拟地址空间（VAS）中的元素和一个M元素的物理地址空间（PAS）中的元素之间的映射。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAP:VAS -&gt; PAS U ⌀</span><br></pre></td></tr></table></figure>

<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.10.png" srcset="/img/loading.gif" lazyload alt="image-9.10"></p>
<p>上图表示了MMU如何利用页表来实现这种映射。CPU中的一个控制寄存器，页表基址寄存器（PTBR）指向当前页表。</p>
<p>n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。</p>
<p>MMU将利用VPN来选择适当的PTE。</p>
<p>将页表条目中物理页号（PPN）和虚拟地址中的VPO串联起来，就得到相应的物理地址。</p>
<p>物理和虚拟页面都是p字节的，所以物理页面偏移（VPO）和PPO是相同的。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.11.png" srcset="/img/loading.gif" lazyload alt="image-9.11"></p>
<p>页面命中时，CPU硬件执行的步骤。</p>
<ul>
<li>第一步：处理器生成一个虚拟地址，并把它传送给MMU。</li>
<li>第二步：MMU生成PTE地址，并从高速缓存&#x2F;主存请求得到它。</li>
<li>第三步：高速缓存&#x2F;主存向MMU返回PTE。</li>
<li>第四步：MMU构造物理地址，并把它传送给高速缓存&#x2F;主存。</li>
<li>第五步：高速缓存&#x2F;主存返回所请求的数据字给处理器。</li>
</ul>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.12.png" srcset="/img/loading.gif" lazyload alt="image-9.12"></p>
<p>页面命中完全是由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成。</p>
<ul>
<li>第一步到第三步与命中完全相同。</li>
<li>第四步：PTE中的有效位是0，所以MMU触发来一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li>
<li>第五步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li>
<li>第六步：缺页处理程序页面调入新的页面，并更新内存中的PTE。</li>
<li>第七步：缺页程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中。</li>
</ul>
<h3 id="9-6-1-结合高速缓存和虚拟缓存"><a href="#9-6-1-结合高速缓存和虚拟缓存" class="headerlink" title="9.6.1 结合高速缓存和虚拟缓存"></a>9.6.1 结合高速缓存和虚拟缓存</h3><p>在任何使用虚拟内存又实用SRAM高速缓存的系统中，都有应该使用虚拟地址还是使用物理地址来访问SRAM高数缓存的问题。</p>
<p>大多数系统是物理寻址的。使用物理寻址，多个进程很容易同时在高速缓存中有存储块和共享来自相同虚拟页面的块。而且，改善缓存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.13.png" srcset="/img/loading.gif" lazyload alt="image-9.13"></p>
<p>将VM与物理寻址的高速缓存结合起来：VA：虚拟地址。PTEA：页表条目地址。PTE：页表条目。PA：物理地址</p>
<h3 id="9-6-2-利用TLB加速地址翻译"><a href="#9-6-2-利用TLB加速地址翻译" class="headerlink" title="9.6.2 利用TLB加速地址翻译"></a>9.6.2 利用TLB加速地址翻译</h3><p>CPU产生一个虚拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，会要求从内存多取一次数据，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么开销就下降到1个或2个周期。然而，许多系统都试图消除即使是这样的开销，他们在MMU中包括来一个关于PTE的小缓存，称为翻译后备缓冲器（TLB）。</p>
<p>TLB是一个小的虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.14.png" srcset="/img/loading.gif" lazyload alt="image-9.14"></p>
<p>用于组选择和行匹配度索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有T&#x3D;2^t个组，那么TLB索引是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.15.png" srcset="/img/loading.gif" lazyload alt="image-9.15"></p>
<p>当TLB命中时（通常情况）所包括的步骤。这里的关键是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常的块。</p>
<ul>
<li><p>第一步：CPU产生一个虚拟地址VA</p>
</li>
<li><p>第二步和第三步：MMU从TLB中取出对应的PTE。</p>
</li>
<li><p>第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存&#x2F;主存。</p>
</li>
<li><p>第五步：高速缓存&#x2F;主存将所请求的数据字返回给CPU。</p>
<p>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p>
</li>
</ul>
<h3 id="9-6-3-多级页表"><a href="#9-6-3-多级页表" class="headerlink" title="9.6.3 多级页表"></a>9.6.3 多级页表</h3><p>假设系统只用一个单独的页表来进行地址翻译。但是如果我们有一个32位的地址空间、4KB的页面和一个4字节的PTE，那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个4MB的页表驻留在内存中。对于地址空间为64位的系统来说，问题将变得更复杂。</p>
<p>压缩页表的常用方法是使用层次结构的页表。</p>
<p>假设32位虚拟地址空间被分为4KB的页，而每个页表条目都是4字节。</p>
<p>假设在这样时刻，虚拟地址空间有如下形式：内存的前2K页面分配给了代码和数据，接下来的6K个页面还未分配，再接下来的1023个页面也未被分配，接下来的1个页面分配给了用户栈。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.16.png" srcset="/img/loading.gif" lazyload alt="image-9.16"></p>
<p>为虚拟地址空间构造的两级的页表层次结构。</p>
<p>一级页表中的每个PTE负责映射虚拟地址空间中一个4MB的片，这里每一个片都是由1024个连续的页面组成的。比如，PTE0 映射第一片，PTE1 映射接下来的一片。</p>
<p>假设地址空间是4GB，1024个PTE一级足够覆盖整个空间了。</p>
<p>如果片i中的每个页面都未被分配，那么一级PTE i就为空。</p>
<p>上图片2～7是未被分配的。然而如果片i中至少有一个页是分配了的，那么一级PTE i 就指向一个二级页表的基址。</p>
<p>片0、1和8的所有或者已被分配，所以它们的一级PTE就指向二级页表。</p>
<p>二级页表中的每个PTE都负责映射一个4KB的虚拟内存页面，就像我们查看只有一级的页表一样。</p>
<p>使用4字节的PTE，每个一级和二级页表都是4KB字节，这刚好和一个页面的大小是一样的。</p>
<p>这种方法从两个方面减少了内存要求。</p>
<ul>
<li>第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就不会存在</li>
<li>第二，只有一级页表才需要总是在主存中；</li>
</ul>
<p>虚拟内存系统可以在需要时创建、页面调入和调出二级页表，这就减少了主存的压力，只有最经常使用的二级页表才需要缓存在主存中。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.17.png" srcset="/img/loading.gif" lazyload alt="image-9.17"></p>
<p>上图使用k级页表层次结构的地址翻译。虚拟地址被划分成为k个VPN和一个VPO。每个VPN i 都是一个到第i 级页表的索引，其中 1&lt;&#x3D;i&lt;&#x3D;k。</p>
<p>第j级页表中的每个PTE， 1&lt;&#x3D;j&lt;&#x3D;k-1，都指向第 j+1级的某个页表的基址。第k级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。</p>
<p>为了构造物理地址，在能够确定PPN之前，MMU必须访问k个PTE。对于只有一级的页表结构，PPO和VPO是相同的。</p>
<p>表面上，使用多级页表看上去昂贵，但是TLB能够在里面起作用，正是通过将不同层次上页表的PTE缓存起来。实际上，多级页表并不比单级页表慢很多。</p>
<h3 id="9-6-4-综合：端到端的地址翻译"><a href="#9-6-4-综合：端到端的地址翻译" class="headerlink" title="9.6.4 综合：端到端的地址翻译"></a>9.6.4 综合：端到端的地址翻译</h3><p>端到端的地址翻译示例，保证可管理性，做出如下假设</p>
<ul>
<li>内存是按字节寻址的</li>
<li>内存访问是针对1字节的字的（不是4字节的字）</li>
<li>虚拟地址是14位长的（n&#x3D;14）</li>
<li>物理地址是12位长的（m&#x3D;12）</li>
<li>页面大小是64字节（P&#x3D;64）</li>
<li>TLB是四路相联的，总共有16个条目</li>
<li>系统是物理寻址、直接映射的，行大小为4字节，而总共有16个组。</li>
</ul>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.18.png" srcset="/img/loading.gif" lazyload alt="image-9.18"></p>
<p>因为页大小是64字节的，所以虚拟地址和物理地址的低6位分别作为VPO和PPO。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.19.png" srcset="/img/loading.gif" lazyload alt="image-9.19"></p>
<ul>
<li><p>TLB</p>
<p>TLB是利用VPN的位进行虚拟寻址的。因为TLB有四组，所以VPN的低2位就作为组索引TLBI。VPN中的高6位作为标记（TLBT），用了区别可能映射到同一个TLB组的不同的VPN。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.20.png" srcset="/img/loading.gif" lazyload alt="image-9.20"></p>
</li>
<li><p>页表</p>
<p>这个页表是一个单级设计，一共有2^8&#x3D;256个页表条目（PTE）。然而，我们只对这些条目中的开头16个感兴趣。为了方便，我们用索引它的VPN来标识每个PTE；但这些VPN不是页表的一部分，也不存储在内存中。同时有效位为0的数据是没有意义的。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.21.png" srcset="/img/loading.gif" lazyload alt="image-9.21"></p>
</li>
<li><p>高速缓存</p>
<p>直接映射就是通过物理地址中的字段来寻址的。因为每个块都是4字节，所以物理地址的低2位作为块偏移（CO）。因为有16组，所以接下来的四位就用来标识组索引（CI）。剩下的6位作为标记（CT）。</p>
</li>
</ul>
<p>当CPU执行读一条0x03d4处字节的加载指令时会发生什么。</p>
<p>这是虚拟地址的各个位</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.22.png" srcset="/img/loading.gif" lazyload alt="image-9.22"></p>
<p>开始时，MMU从虚拟地址中抽取出VPN（0x0f），并且检查TLB，看它是否因为前面某个内存引用缓存来PTE0x0f的一个副本。TLB从VPN中抽取出TLB索引（0x03）和TLB标记（0x03），组0x03的第二个条目中有效匹配，所以命中，然后将缓存的PPN（0x0D）返回给MMU。</p>
<p>如果TLB不命中，那么MMU就需要从主存中取出相应的PTE。这样MMU就有了形成物理地址所需要的所有东西。通过来自PTE的PPN（0x0D）和来自虚拟地址的VPO（0x14）链接起来，这就形成来物理地址（0x354）。</p>
<p>接下来，MMU发送物理地址给缓存，缓存从物理地址中抽取出缓存偏移CO（0x0）、缓存组索引CI（0x05）以及缓存标记CT（0x0D）。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.23.png" srcset="/img/loading.gif" lazyload alt="image-9.23"></p>
<p>因为0x5中标记与CT相匹配，索引检测到一个命中，读出在偏移量CO处的数据字节（0x36），并将它返回给MMU，随后MMU将它传递回CPU。</p>
<p>如果TLB不命中，那么MMU就必须从页表中的PTE中取出PPN。如果得到的PTE是无效的就会产生一个缺页，内核就要调入合适的页面，重新运行这条加载指令。如果PTE是有效的，但是所需要的内存块在缓存中不命中。</p>
<h1 id="9-7-Linux虚拟内存系统"><a href="#9-7-Linux虚拟内存系统" class="headerlink" title="9.7 Linux虚拟内存系统"></a>9.7 Linux虚拟内存系统</h1><p>Linux为每一个进程维护了一个单独的虚拟地址空间，</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.24.png" srcset="/img/loading.gif" lazyload alt="image-9.24"></p>
<p>内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理界面。</p>
<p>例如每个进程共享内核的代码和全局数据结构。Linux也将一组连续的虚拟页面（大小等于系统中DRAM的总量）映射到相应的一组连续的物理页面。</p>
<p>这就为内核提供了一种便利的方法来访问物理内存中特定的位置，当它要访问页表，或者在设备上执行内存映射I&#x2F;O操作，而这些设备被映射到特定的物理内存位置时。</p>
<p>内核虚拟内存的其他区域包含每个进程都不相同的数据。比如，页表、内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p>
<h3 id="9-7-1-Linux虚拟内存区域"><a href="#9-7-1-Linux虚拟内存区域" class="headerlink" title="9.7.1 Linux虚拟内存区域"></a>9.7.1 Linux虚拟内存区域</h3><p>Linux将虚拟内存组织成一些区域（段）的集合。一个区域就是已经存在着的虚拟内存连续片，这些页以某种方式相关联。</p>
<p>代码段、数据段、堆、共享库段，以及用户栈都是不同的区域。每个存在的虚拟页都保存在某个区域中，不属于某个区域的虚拟页是不存在的，并且不能被进程引用。区域允许虚拟地址空间有间隙。内核不用记录那些不存在的虚拟页，而这样的页不用占用内存，或者是其他任何资源。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.25.png" srcset="/img/loading.gif" lazyload alt="image-9.25"></p>
<p>上图为一个进程中虚拟内存区域的内核数据结构。内核为系统中的每个进程维护一个单独的任务结构。（task_struct）任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（PID、指向用户栈的指针、可执行目标文件的名字、程序计数器）。</p>
<p>任务结构中的一个条目指向mm_struct，它描述来虚拟内存的当前状态。我们感兴趣的两个字段是pgd和mmap，其中pgd指向第一级页表（页全局目录）的基址，而mmap指向一个vm_area_structs（区域结构）的链表，其中每个vm_area_structs都描述来当前虚拟地址空间的一个区域。当内核运行这个进程时，就将pgd存放在CR3控制寄存器中。</p>
<p>一个具体区域结构包含下面的字段：</p>
<ul>
<li>vm_start：指向这个区域的起始处。</li>
<li>vm_end：指向这个区域的结束处。</li>
<li>vm_prot：描述这个区域内包含的所有页的读写许可权限。</li>
<li>vm_flags：描述这个区域内的页面是与其他进程共享的，还是这个进程私有的</li>
<li>vm_next：指向链表中下一个区域结构</li>
</ul>
<h3 id="9-7-2-Linux缺页异常处理"><a href="#9-7-2-Linux缺页异常处理" class="headerlink" title="9.7.2 Linux缺页异常处理"></a>9.7.2 Linux缺页异常处理</h3><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.26.png" srcset="/img/loading.gif" lazyload alt="image-9.26"></p>
<p>当MMU试图翻译某个虚拟地址A时，触发来一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤：</p>
<ul>
<li><p>1 虚拟地址A是合法的吗？A在某个区域结构定义的区域内吗？缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令不合法，那么缺页处理程序就触发一个段错误，从而终止这个进程（标识为1）。</p>
<p>因为一个进程可以创建任意数量的新虚拟内存区域（使用在下一节中的mmap），所以顺序搜索区域结构的链表花销可能会很大。在实际中，Linux使用某些我们没有显示出来的字段，Linux在链表中构建了一棵树，并在这棵树上进行查找。</p>
</li>
<li><p>2 试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个缺页是不是有一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字段造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。（标识2）</p>
</li>
<li><p>3 此刻，内核指导这个缺页是由对合法的模拟地址进行合法的操作造成的。</p>
<ul>
<li>它是这样处理缺页的<ul>
<li>选择一个牺牲页面，如果这个页面被修改过，那么久将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送到A到MMU。这回MMU就能正常翻译地址A。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9-8-内存映射"><a href="#9-8-内存映射" class="headerlink" title="9.8 内存映射"></a>9.8 内存映射</h2><p>Linux将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型的对象中的一种。</p>
<ul>
<li>1 Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。文件区（section）被分成页大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到CPU第一次引用到页面（即发射一个虚拟地址，落在地址空间这个页面的范围之内）。如果区域比文件区要大，那么就用0来填充这个区域余下部分。</li>
<li>2 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件由内核创建，全是二进制的0。CPU第一次引用这样的区域时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制0覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制0的页。</li>
</ul>
<p>无论怎样，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件之间换来换去。交换文件也叫交换空间，或者交换区域。</p>
<p>任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。</p>
<h3 id="9-8-1-再看共享对象"><a href="#9-8-1-再看共享对象" class="headerlink" title="9.8.1 再看共享对象"></a>9.8.1 再看共享对象</h3><p>如果讯内存系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到内存中的方法。</p>
<p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些把这个共享对象映射到他们虚拟内存的其他进程而言，也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。</p>
<p>另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟内存区域叫做共享区域。类似的，也有私有区域。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.27.png" srcset="/img/loading.gif" lazyload alt="image-9.27"></p>
<p>假设进程1将一个共享对象映射到它的虚拟内存的一个区域中。现在假设进程2将同一个共享对象映射到它的地址空间，因为每个对象有唯一文件名，内核可以迅速地判定进程1已经映射了这个对象，而且可以使进程2中的页表条目指向相应的物理页面。关键是即使对象被映射到啦多个共享区域，物理内存中也只需要存放共享对象的一个副本。</p>
<p>私有对象使用写时复制的技术被映射到虚拟内存中。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.28.png" srcset="/img/loading.gif" lazyload alt="image-9.28"></p>
<p>私有对象开始生命周期的方式与共享对象基本一样，在物理内存中只保存有私有对象的一份副本。</p>
<p>上图两个进程将一个私有对象映射到它们虚拟内存的不同区域，但共享同一个物理副本。对于每个映射啦私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程试图写他自己的私有区域，他们就可以继续共享物理内存中对象的一个单独副本。然而，只要有一个进程试图写私有区域的某个页面，那么这个写操作就会触发一个保护故障。</p>
<p>当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限。</p>
<p>如图当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。</p>
<h3 id="9-8-2-再看fork函数"><a href="#9-8-2-再看fork函数" class="headerlink" title="9.8.2 再看fork函数"></a>9.8.2 再看fork函数</h3><p>fork函数创建一个带有自己独立虚拟地址空间的新进程</p>
<p>当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。未来给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</p>
<p>当fork返回时，新进程现在的虚拟内存刚好和调用fork时的虚拟内存相同，当这两个进程中的任一个来进行写操作时，写时复制机制就会创建新页面。位每个进程保持来私有地址空间的抽象。</p>
<h3 id="9-8-3-再看execve函数"><a href="#9-8-3-再看execve函数" class="headerlink" title="9.8.3 再看execve函数"></a>9.8.3 再看execve函数</h3><p>假设运行在当前进程中的程序执行了如下的execve调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;a.out&quot;,NULL,NULL)</span><br></pre></td></tr></table></figure>

<p>execve函数在当前进程中加载并运行包含在a.out中的程序，用a.out替代了当前程序，加载并运行一共有一下几个步骤。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.29.png" srcset="/img/loading.gif" lazyload alt="image-9.29"></p>
<ul>
<li>删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li>
<li>映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区。bss区域是请求二进制0的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制0的，初始长度为0。</li>
<li>映射共享区域。如果a.out程序与共享对象（或目标）链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li>
<li>设置程序计数器（PC）。execve最后会设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux会根据需要换入代码和数据页面。</li>
</ul>
<h3 id="9-8-4-使用mmap函数的用户级内存映射"><a href="#9-8-4-使用mmap函数的用户级内存映射" class="headerlink" title="9.8.4 使用mmap函数的用户级内存映射"></a>9.8.4 使用mmap函数的用户级内存映射</h3><p>mmap被用来创建新的虚拟内存区域，并将对象映射到这些区域中。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.30.png" srcset="/img/loading.gif" lazyload alt="image-9.30"></p>
<p>mmap函数要求内核创建一个新的虚拟内存区域，最好从start开始的一个区域，并将文件描述符fd指定的对象的一个连续的片映射到这个新的区域。连续的对象片大小为length字节，从文件开始处偏移量为offset字节的地方开始。start地址仅仅是一个暗示，通常被定义为NULL。我们总是假设起始地址为NULL。</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.31.png" srcset="/img/loading.gif" lazyload alt="image-9.31"></p>
<p>prot包含描述新映射的虚拟内存区域的访问权限位（vm_prot位）</p>
<ul>
<li>PROT_EXEC：这个区域内的页面由可以被CPU执行的指令组成。</li>
<li>PROT_READ：这个区域内的页面可读。</li>
<li>PROT_WRITE：这个区域内的页面可写。</li>
<li>PROT_NONE：这个区域内的页面不能被访问。</li>
</ul>
<p>参数flags由描述被映射对象类型的位组成。如果设置了MAP_ANON标记位，那么被映射的对象就是匿名对象，相应的页面上请求二进制0的。</p>
<p>MAP_PRIVATE表示被映射的对象是一个私有的、写时复制对象，而MAP_SHARED表示是一个共享对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufp=Mmap(NULL,size,PROT_READ,MAP_PRIVATE|MAP_ANON,0,0)</span><br></pre></td></tr></table></figure>

<p>如果嗲用成功bufp包含新的区域地址。</p>
<p>munmap函数删除虚拟内存的区域：</p>
<p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.32.png" srcset="/img/loading.gif" lazyload alt="image-9.32"></p>
<p>munmap删除函数从start开始，到接下来length字节组成的区域，如果再引用已删除的区域会导致段错误。</p>
<h2 id="9-9-动态内存分配"><a href="#9-9-动态内存分配" class="headerlink" title="9.9 动态内存分配"></a>9.9 动态内存分配</h2><h2 id="9-10-垃圾收集"><a href="#9-10-垃圾收集" class="headerlink" title="9.10 垃圾收集"></a>9.10 垃圾收集</h2><p>如果程序猿分配了一块内存空间，但忘记释放这个块。它就是内存泄漏。</p>
<p>垃圾收集器定期识别垃圾块，并相应的调用free，将这些块放回到空闲链表中。</p>
<h3 id="9-10-1-垃圾收集器的基本知识"><a href="#9-10-1-垃圾收集器的基本知识" class="headerlink" title="9.10.1 垃圾收集器的基本知识"></a>9.10.1 垃圾收集器的基本知识</h3><p>垃圾收集器将内存视为一张有向可达图，该图的节点被分成一组根节点和一组堆节点。根节点对应一种不在堆中的位置，从根节点不可达的节点对应为垃圾。</p>
<p>需要堆空间时，调用malloc，如果找不到一个合适的空闲块，那么就调用垃圾收集器，希望能回收一些垃圾，收集器去调用free，返回后malloc重试。</p>
<h3 id="9-10-2-Mark-Sweep垃圾收集器"><a href="#9-10-2-Mark-Sweep垃圾收集器" class="headerlink" title="9.10.2 Mark&amp;Sweep垃圾收集器"></a>9.10.2 Mark&amp;Sweep垃圾收集器</h3><p>标记清除垃圾收集器</p>
<p>如果一个块不指向任何块，mark函数就立刻返回，否则就标记这个块，这样任何未标记的都被认为是不可达的，在清除阶段回收。</p>
<p>sweep在堆上反复循环，释放它所遇到所有未标记的已分配块。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="print-no-link">#计算机系统</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CSAPP深入理解计算机系统-第九章-虚拟内存</div>
      <div>http://example.com/2025/01/10/csapp/CSAPP深入理解计算机系统-第九章-虚拟内存/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>BoBoDai</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 10, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" title="CSAPP深入理解计算机系统-第十章-系统级IO">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSAPP深入理解计算机系统-第十章-系统级IO</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="CSAPP深入理解计算机系统-第八章-异常控制流">
                        <span class="hidden-mobile">CSAPP深入理解计算机系统-第八章-异常控制流</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
