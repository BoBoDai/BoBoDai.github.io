

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/header.png">
  <link rel="icon" href="/img/header.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="BoBoDai">
  <meta name="keywords" content="">
  
    <meta name="description" content="讲述了协作式多任务 和 Rust 的 async&#x2F;await 功能。将详细展示 Rust 中的 async&#x2F;await 是如何工作的， 包括 Future trait 的设计、状态机转换和 pinning。 然后，我们通过创建一个异步键盘任务和一个基本的执行器，为我们内核添加了对 async&#x2F;await 的基本支持。">
<meta property="og:type" content="article">
<meta property="og:title" content="Write-an-OS-in-Rust">
<meta property="og:url" content="http://example.com/2025/06/16/OS/%E8%AF%BBWrite-an-OS-in-Rust/index.html">
<meta property="og:site_name" content="Cactus Hole">
<meta property="og:description" content="讲述了协作式多任务 和 Rust 的 async&#x2F;await 功能。将详细展示 Rust 中的 async&#x2F;await 是如何工作的， 包括 Future trait 的设计、状态机转换和 pinning。 然后，我们通过创建一个异步键盘任务和一个基本的执行器，为我们内核添加了对 async&#x2F;await 的基本支持。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_1.png">
<meta property="og:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_2.png">
<meta property="og:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_3.png">
<meta property="og:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_4.png">
<meta property="article:published_time" content="2025-06-16T03:56:35.000Z">
<meta property="article:modified_time" content="2025-06-19T09:10:08.184Z">
<meta property="article:author" content="BoBoDai">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_1.png">
  
  
  
  <title>Write-an-OS-in-Rust - Cactus Hole</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>BoBoBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Write-an-OS-in-Rust"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-16 11:56" pubdate>
          June 16, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.2k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          69 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Write-an-OS-in-Rust</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="1-多任务"><a href="#1-多任务" class="headerlink" title="1. 多任务"></a>1. 多任务</h2><p>大多数操作系统的基本特性就是多任务，它同时执行多个任务。<br>实际上一个CPU核心一次只能执行一个任务，操作系统快速的在活动任务之间切换，这样实现了并发。<br>多核CPU能够真正的执行多任务，8核的CPU可以同时执行8个任务，实现了并行。</p>
<p>多任务有两种形式</p>
<ul>
<li>协作式多任务：要求任务定期放弃对CPU的控制，以便其他任务可以取得进展。</li>
<li>抢占式多任务：使用操作系统功能在任意时间点强制暂停线程来切换线程。</li>
</ul>
<h3 id="1-1-协作式多任务"><a href="#1-1-协作式多任务" class="headerlink" title="1.1. 协作式多任务"></a>1.1. 协作式多任务</h3><p>协作式多任务让每个任务运行到自愿放弃对CPU的控制，而不是在任意时间点强制暂停运行的任务，这使得任务可以在方便的时间点暂停自己，例如，需要等待IO操作时。</p>
<p>协作式多任务通常用于语言级别，比如协程或async&#x2F;await的形式。其思想上程序员或编译器在程序中插入yield操作，这样可以放弃对CPU的控制，让其他任务运行。</p>
<p>通常协作式多任务与异步操作结合在一起，当一个操作还没有完成，它不会阻止其他任务运行，而是返回一个未就绪的状态。 在这种情况下，等待的任务可以执行一个yield操作，让其他任务运行。</p>
<h4 id="1-1-1-状态保存"><a href="#1-1-1-状态保存" class="headerlink" title="1.1.1. 状态保存"></a>1.1.1. 状态保存</h4><p>既然任务自己定义了暂停点，他们不需要操作系统保存它们的状态。反之，它们可以在暂停自己之前保存他们需要的状态，这通常会带来更好的性能。比如一个刚完成了复杂计算的任务可能只需要备份计算的最终结果，因为它不再需要中间结果。</p>
<p>协作式多任务的语言级实现通常甚至能够在暂停之前备份调用栈的必要部分。例如，Rust的async&#x2F;await实现会在暂停之前备份所有仍然需要的本地变量到一个自动生成的结构体中。 通过在暂停之前备份调中栈的相关部分，所有任务都可以共享一个调用栈，这导致每个任务的内存消耗大大降低。这使得可以创建几乎任意数量的协作式任务不会耗尽内存。</p>
<h4 id="1-1-2-讨论"><a href="#1-1-2-讨论" class="headerlink" title="1.1.2. 讨论"></a>1.1.2. 讨论</h4><p>协作式多任务的缺点是一个不合作的任务可能运行无限长的时间。因此，一个恶意或有缺陷的任务可能会阻止其他任务运行，从而减慢甚至阻塞整个系统。因此，只有当所有的任务都知道合作时，协作式多任务才应该使用。让操作系统依赖于任务用户级程序的合作是不明智的。</p>
<p>然而，协作式多任务的强大性能和内存优势使得它成为程序内部使用的一个好方法，特别是与异步操作系统结合使用。由于操作系统内核是一个与异步硬件交互和性能关键型程序，协作式多任务似乎是一个实现并发性的一个好办法。</p>
<h3 id="1-2-抢占式多任务"><a href="#1-2-抢占式多任务" class="headerlink" title="1.2. 抢占式多任务"></a>1.2. 抢占式多任务</h3><p>抢占式多任务的思想是操作系统控制何时切换任务，它利用了操作系统在每次中断时重新获得对CPU的控制， 这使得在系统有新的输入时可以进行任务切换。操作系统还可以通过配置硬件计时器在一段时间后发送中断来确定任务允许运行的确切时间。</p>
<p>下图是硬件中断时的任务切换过程</p>
<p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_1.png" srcset="/img/loading.gif" lazyload alt="rust_os_1"></p>
<p>第一行中，CPU正在执行程序A的任务A1所有其他任务都被暂停了。在第二行中，硬件中断到达了CPU。<br>正如在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/hardware-interrupts/">硬件中断</a>中描述的那样,CPU立即停止了任务A1的执行。并跳转到中断描述表（IDT）<br>中定义的中断处理程序。通过这个中断处理程序，操作系统现在再次控制了CPU，之后切换到任务B1。</p>
<h4 id="1-2-1-状态保存"><a href="#1-2-1-状态保存" class="headerlink" title="1.2.1. 状态保存"></a>1.2.1. 状态保存</h4><p>任务在任意时间点被中断，可能在一些计算的中间，未来能够稍后恢复他们，操作系统必须备份整个状态，包括调用栈，和所有CPU寄存器的值，也叫上下文切换。</p>
<p>由于调用栈可能非常大，操作系统通常为每一个任务设置一个单独的调用栈，而不是在每次任务切换时备份调用栈内容。这种有自己的栈被称为执行线程也叫线程。 通过为每个任务使用单独的栈，只需要在上下文切换时保存寄存器内容。</p>
<h4 id="1-2-2-讨论"><a href="#1-2-2-讨论" class="headerlink" title="1.2.2. 讨论"></a>1.2.2. 讨论</h4><p>抢占式多任务主要的好处是操作系统可以完全控制任务的允许执行时间。这样，它可以保证每个任务都能公平的获得CPU的时间，不需要信任任务合作。</p>
<p>抢占式多任务的缺点是每个任务都需要自己的栈，和共享栈相比，导致每个任务的内存使用量更高，而且通常限制了系统中的任务数量。 另一个缺点是操作系统总是需要在每次任务切换时保存完整的CPU寄存器状态，即使任务只使用量寄存器的一小部分。</p>
<p>抢占式多任务和线程是操作系统的基本组件，因为他们使得运行不受信任的用户空间程序称为可能。本文将专注于协作式多任务。</p>
<h2 id="2-Async-Await-in-Rust"><a href="#2-Async-Await-in-Rust" class="headerlink" title="2. Async&#x2F;Await in Rust"></a>2. Async&#x2F;Await in Rust</h2><p>Rust语言提供了对多任务的第一级别支持，这种支持以async&#x2F;await的形式呈现。</p>
<h3 id="2-1-Futures"><a href="#2-1-Futures" class="headerlink" title="2.1. Futures"></a>2.1. Futures</h3><p>一个Future代表一个可能还没有可用的值。这可能是，例如，由另一个任务计算或从网络下载的文件。与等待值可用不同，future使得可以继续执行直到需要值。</p>
<h4 id="2-1-1-例子"><a href="#2-1-1-例子" class="headerlink" title="2.1.1. 例子"></a>2.1.1. 例子</h4><p>future的概念</p>
<p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_2.png" srcset="/img/loading.gif" lazyload alt="rust_os_2"></p>
<p>这个序列图展示了一个<code>main</code>函数，它从文件系统读取文件，然后调用一个<code>foo</code>函数，这个过程重复了两次：</p>
<ul>
<li>一次同步的<code>read_file</code>调用</li>
<li>一次是异步的<code>async_read_file</code>调用</li>
</ul>
<p>使用异步<code>async_read_file</code>调用，文件系统直接返回一个future，并在后台异步加载文件。这使得<code>main</code>函数可以更早的调用<code>foo</code>，这样它可以与文件加载并行运行。这个例子中，文件加载在<code>foo</code>返回之前完成了，所以<code>main</code>可以在<code>foo</code>返回后直接使用文件而不需要进一步等待。</p>
<h4 id="2-1-2-Future-in-Rust"><a href="#2-1-2-Future-in-Rust" class="headerlink" title="2.1.2. Future in Rust"></a>2.1.2. Future in Rust</h4><p>在Rust中，futures由<code>Future</code>trait表示，它看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Future</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>Output指定了异步值的类型，例如，上面的示例中<code>async_read_file</code>函数将返回一个<code>Output</code>设置为<code>File</code>的<code>Future</code>实例。</li>
<li>poll方法允许检查值是否已经可用。它返回一个<code>Poll</code>枚举，看起来这样。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Poll</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ready</span>(T),<br>    Pending,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当那个值已经可用（例如，文件已经读取完毕）。它被包装在<code>Ready</code>变体中返回。否则，返回<code>Penging</code>变体，这通知调用者该值尚不可用。</p>
<p>方法 <code>poll</code> 接受兩個參數：<code>self: Pin&lt;&amp;mut Self&gt;</code> 和 <code>cx: &amp;mut Context</code>。前者的行為與普通的 <code>&amp;mut self</code> 引用類似，只是 Self 值被 釘住 pinned 在它的內存位置。</p>
<p>参数<code>cx: &amp;mut Context</code>的目的是將一個 喚醒器 <code>Waker</code> 實例傳遞給異步任務，例如文件系統加載。 這個 <code>Waker</code> 允許異步任務發出信號，表明它已经完成。主任务知道当<code>Future</code>可用时它将被通知，所以它不需要一遍又一遍的调用<code>poll</code>。</p>
<h3 id="2-2-和Futures一起工作"><a href="#2-2-和Futures一起工作" class="headerlink" title="2.2. 和Futures一起工作"></a>2.2. 和Futures一起工作</h3><p>Futures 代表了异步任务的结果，这些结果可能还不可用。然而，在实践中，我们经常需要这些值來进行进一步的计算。 所以问题是：当我们需要时，我们如何有效地获取 future 的值？</p>
<h4 id="2-2-1-Waiting-on-Futures"><a href="#2-2-1-Waiting-on-Futures" class="headerlink" title="2.2.1. Waiting on Futures"></a>2.2.1. Waiting on Futures</h4><p>一个答案是等待直到future变得可用。这看起来像这样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">file_content</span> = <span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-keyword">match</span> future.<span class="hljs-title function_ invoke__">poll</span>(…) &#123;<br>        Poll::<span class="hljs-title function_ invoke__">Ready</span>(value) =&gt; <span class="hljs-keyword">break</span> value,<br>        Poll::Pending =&gt; &#123;&#125;, <span class="hljs-comment">// do nothing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述代码主动等待future，通过在一个循环中调用<code>poll</code>。这个<code>poll</code>的参数不重要。这个方案非常低效，因为我们一直占用CPU直到值变的可用。</p>
<p>更有效的方法可能是阻塞当前线程直到future变的可用。这种只有在线程作用下才可能，所以这个方法对内核无效。</p>
<h4 id="2-2-2-Future组合器"><a href="#2-2-2-Future组合器" class="headerlink" title="2.2.2. Future组合器"></a>2.2.2. Future组合器</h4><p>一个等待的替代方案是使用future组合器。Future组合器是像<code>map</code>这样的方法，它允许将future链接和组合在一起，类似于<code>Iterator</code>trait的方法。于等待future不同，这些组合器返回一个future，他们自己应用<code>poll</code>上的映射操作。</p>
<p>例子，一个简单的<code>string_len</code>组合器，它将<code>Future&lt;Output = String&gt;</code>转换成<code>Future&lt;Output = usize&gt;</code>可能看起来像这样。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StringLen</span>&lt;F&gt; &#123;<br>    inner_future: F,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;F&gt; Future <span class="hljs-keyword">for</span> <span class="hljs-title class_">StringLen</span>&lt;F&gt; <span class="hljs-keyword">where</span> F: Future&lt;Output = <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = <span class="hljs-type">usize</span>;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> Poll&lt;T&gt; &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.inner_future.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>            Poll::<span class="hljs-title function_ invoke__">Ready</span>(S) =&gt; Poll::<span class="hljs-title function_ invoke__">Ready</span>(s.<span class="hljs-title function_ invoke__">len</span>()),<br>            Poll::Pending =&gt; Poll::Pending,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">string_len</span>(string: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">String</span>&gt;)<br>    <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">usize</span>&gt;<br>&#123;<br>    StringLen &#123;<br>        inner_future: string,<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Usage</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">file_len</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">usize</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">file_content_future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>);<br>    <span class="hljs-title function_ invoke__">string_len</span>(file_content_future)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的例子，的基本思想是<code>string_len</code>函数将给定的<code>Future</code>实例包装到一个新的<code>StringLen</code>结构体中，它也体现了<code>Future</code>。当包装的future被调用时，它调用内部的future。如果值还不可用，从包装的future也返回<code>Poll::Pending</code>。如果值已可用。则从<code>Poll::Ready</code>变体中提取字符串并计算它的长度。然后，它再次包装在<code>Poll::Ready</code>中并返回。</p>
<p>用这个<code>string_len</code>函数，我们可以计算一个异步字符串的长度而不需要等待它。由于函数再次返回一个<code>Future</code>，调用者不能直接在返回的值上工作，但需要再次使用组合器函数。这样，整个调用图变成了异步的，我们柯宇在某个时候有效的等待多个futures，例如，在<code>main</code>函数中。</p>
<p>因为手工编写组合器函数是很困难的，他们通常由库提供。虽然Rust标准库本身含没有提供组合器方法，但是半官方的<code>futures</code>库提供了。它的<code>FutureExt</code>trait提供了高级组合器方法，比如<code>map</code>或<code>then</code>，它们可以用来使用任意的闭包来操作结果。</p>
<h4 id="2-2-3-优势"><a href="#2-2-3-优势" class="headerlink" title="2.2.3. 优势"></a>2.2.3. 优势</h4><p>Future组合器的一个巨大优势是它们保存来操作的异步性。与异步I&#x2F;O接口结合使用，这种方法可以带来非常高的性能。Future组合器作为具有trait实现的普通结构体，使得编辑器可以对他们进行极限优化。更多可以参考<a target="_blank" rel="noopener" href="https://aturon.github.io/blog/2016/08/11/futures/">Zero-cost futures in Rust</a>。</p>
<h4 id="2-2-4-缺点"><a href="#2-2-4-缺点" class="headerlink" title="2.2.4. 缺点"></a>2.2.4. 缺点</h4><p>当future组合器使得编写非常高效的代码成为可能，但它在一些情况下很难使用，这是因为类型系统和基于闭包的接口。例如下面的代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>).<span class="hljs-title function_ invoke__">then</span>(<span class="hljs-keyword">move</span> |content| &#123;<br>        <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; min_len &#123;<br>            Either::<span class="hljs-title function_ invoke__">Left</span>(<span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;bar.txt&quot;</span>).<span class="hljs-title function_ invoke__">map</span>(|s| content + &amp;s))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Either::<span class="hljs-title function_ invoke__">Right</span>(future::<span class="hljs-title function_ invoke__">ready</span>(content))<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里先是读取文件<code>foo.txt</code>,然后使用<code>then</code>组合器来链接基于文件内容的第二个future。如果内容的长度小于给定的<code>min_len</code>，我们读取一个不同的<code>bar.txt</code>文件并使用<code>map</code>组合器将它加到<code>context</code>上。否则返回<code>foo.txt的内容</code>。</p>
<p>我们需要使用<code>move</code>关键字来修复传递给<code>then</code>的闭包，因为否则<code>min_len</code>将会有一个声明周期错误。我们需要使用<code>Either</code>包装器，因为<code>if</code>和<code>else</code>块必须总是有相同的类型。由于我们在块中返回不同的future类型，我们必须使用包装器类型将它们统一到一个模型中。<code>ready</code>函数将一个值包装到一个future中，这个future立即就绪。这个函数在这里是必须的，因为Either包装器期望被包装的值实现了<code>Future</code></p>
<p>这能很快的导致对于大型项目来说非常复杂的代码。如果设计借用和不同的生命周期，它会变的特别复杂。因此，Rust在添加对async&#x2F;await的支持时投入了大量工作，使编写异步代码变的简单。</p>
<h3 id="2-3-The-Async-Await-Pattern"><a href="#2-3-The-Async-Await-Pattern" class="headerlink" title="2.3. The Async&#x2F;Await Pattern"></a>2.3. The Async&#x2F;Await Pattern</h3><p>使用<code>await</code>和<code>async</code>关键字可以将一个同步函数转换为一个返回future的异步函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// the above is roughly translated by the compiler to:</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">u32</span>&gt; &#123;<br>    future::<span class="hljs-title function_ invoke__">ready</span>(<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个关键字单独使用不是很有用。在<code>async</code>函数内部，<code>await</code>关键字可以用来获取future的异步值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span>;<br>    <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; min_len&#123;<br>        content + &amp; <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        content<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个函数使用了组合函数。使用.await运算符，可以获取future的值而不需要任何闭包或<code>Either</code>类型。因此，我们柯宇像写同步代码一样写异步代码。</p>
<h4 id="2-3-1-状态机转换"><a href="#2-3-1-状态机转换" class="headerlink" title="2.3.1. 状态机转换"></a>2.3.1. 状态机转换</h4><p>后面，编译器将<code>async</code>函数体转换成一状态机，其中每个<code>.await</code>调用代表一个不同的状态。对于上面的<code>example</code>函数，编译器创建了一个具有以下四个状态的状态机。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_3.png" srcset="/img/loading.gif" lazyload alt="rust_os_3"><br>每个状态都是不同的暂停点。</p>
<ul>
<li>“Start”和“End”代表了函数在执行的开始和结束。</li>
<li>“Waiting on foo.txt”状态代表了函数当前正在等待第一个<code>async_read_file</code>的结果。</li>
<li>同样的，“Waiting on bar.txt”状态代表了函数正在等待第二个<code>async_read_file</code>的结果暂停点。</li>
</ul>
<p>状态机通过使每个<code>poll</code>调用成为一个可能的状态转换来实现<code>Future</code>trait：<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_4.png" srcset="/img/loading.gif" lazyload alt="rust_os_4"><br>第一个<code>poll</code>调用启动了函数并让它运行直到它达到一个还未准备好的future。如果所有future都准备好了，函数可以运行到“End”状态，并在<code>Poll::Ready</code>中返回它的结果。否则，状态机进入等待状态并返回<code>Poll::Pending</code>。在下一个<code>poll</code>调用中，状态机从最后一个等待的状态开始，并重试最后一个操作。</p>
<h4 id="2-3-2-保存状态"><a href="#2-3-2-保存状态" class="headerlink" title="2.3.2. 保存状态"></a>2.3.2. 保存状态</h4><p>为了能从上一个等待状态继续，状态机必须在内部保存当前状态。此外，它必须保存所有需要在下一个<code>poll</code>调用中继续执行的变量。编译器知道那些变量何时使用，他可以自动生成具有确切所需变量的结构体。</p>
<p>编译器为上面的<code>example</code>函数生成下面这种结构体</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span>;<br>    <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; min_len &#123;<br>        content + &amp;<span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        content<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StartState</span> &#123;<br>    min_len: <span class="hljs-type">usize</span>,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WaitingOnFooTxtState</span> &#123;<br>    min_len: <span class="hljs-type">usize</span>,<br>    foo_txt_future: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Outtput = <span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WaitingOnBarTxState</span> &#123;<br>    context: <span class="hljs-type">String</span>,<br>    bar_txt_future: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">String</span>&gt;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EndState</span> &#123;&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>在”start”和”Waiting on foo.txt”状态中，<code>min_len</code>参数需要被保存以便于<code>content.len()</code>进行后续比较。</li>
<li>“Waiting on foo.txt”状态另外保存来一个<code>foo_txt_future</code>，它代表了<code>async_read_file</code>调用返回的future。当转改继续运行时，这个future需要被再次调用，所以它被保存。</li>
</ul>
<p>“Waiting on bar.txt”状态包含了<code>content</code>变量，以便在<code>bar.txt</code>可用时进行字符串拼接。它还保存来一个<code>bar_txt_future</code>，它代表了<code>bar.txt</code>的异步加载过程。这个结构体不包含<code>min_len</code>变量，因为在<code>content.len()</code>比较之后它不再需要了。在“end”状态中不保存任何变量，因为函数已经结束。</p>
<h4 id="2-3-3-完整的状态机模型"><a href="#2-3-3-完整的状态机模型" class="headerlink" title="2.3.3. 完整的状态机模型"></a>2.3.3. 完整的状态机模型</h4><p>我们可以将状态组合成一个<code>enum</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ExampleStateMachine</span>&#123;<br>    <span class="hljs-title function_ invoke__">Start</span>(StartState),<br>    <span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(WaitingOnFooTxtState),<br>    <span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(WaitingOnBarTxtState),<br>    <span class="hljs-title function_ invoke__">End</span>(EndState),<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们定义了一个独立的枚举来表示每个状态，并将相应的状态结构体作为每个变体的字段添加到其中。未来实现状态转换，编译器基于<code>example</code>函数生成了<code>Future</code>trait到实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">ExampleStateMachine</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = <span class="hljs-type">String</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt; &#123;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> &#123;<br>                ExampleStateMachine::<span class="hljs-title function_ invoke__">Start</span>(state) =&gt; &#123;…&#125;<br>                ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(state) =&gt; &#123;…&#125;<br>                ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(state) =&gt; &#123;…&#125;<br>                ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(state) =&gt; &#123;…&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该future的<code>Output</code>类型是<code>String</code>，因为它是<code>example</code>函数的返回类型。为了实现<code>poll</code>函数，我们在一个<code>loop</code>中使用<code>match</code>语句对当前状态进行分支。我们的想法是只要可能就切换到下一个状态，并在无法继续时显示的<code>return Poll::Pending</code>。</p>
<ul>
<li><code>Start</code>状态</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">Start</span>(state) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">foo_txt_future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">state</span> = WaitingOnFooTxtState &#123;<br>        min_len: state.min_len,<br>        foo_txt_future,<br>    &#125;;<br>    *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(state);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>状态机在函数处于<code>Start</code>状态。在这个情况下，执行所有代码直到第一个<code>.await</code>。为了处理<code>.await</code>操作，我们将状态机<code>self</code>的状态更改为<code>WaitingOnFooTxt</code>，这包括了<code>WaitingOnFooTxtState</code>结构体的构造。</p>
<p>因为<code>match self &#123;...&#125;</code>语句在一个循环中执行，所以执行直接跳到<code>WaitingOnFooTxt</code>分支：</p>
<ul>
<li>“WaitingOnFooTxt”的状态</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(state) =&gt; &#123;<br>    <span class="hljs-keyword">match</span> state.foo_txt_future.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>        Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,<br>        Poll::<span class="hljs-title function_ invoke__">Ready</span>(content) =&gt; &#123;<br>            <span class="hljs-comment">// from body of `example`</span><br>            <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; state.min_len &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">bar_txt_future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;bar.txt&quot;</span>);<br>                <span class="hljs-comment">// `.await` operation</span><br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">state</span> = WaitingOnBarTxtState &#123;<br>                    content,<br>                    bar_txt_future,<br>                &#125;;<br>                *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(state);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(EndState);<br>                <span class="hljs-keyword">return</span> Poll::<span class="hljs-title function_ invoke__">Ready</span>(content);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个<code>match</code>分支中，先调用<code>foo_txt_future</code>的<code>poll</code>函数。如果还没准备好，我们退出循环并返回<code>Poll::Pending</code>。由于这种情况下<code>self</code>保持在<code>WaitingOnFooTxt</code>状态，下一个<code>poll</code>调用将进入相同的<code>match</code>分支并重试<code>foo_txt_future</code>的轮询。</p>
<p>当<code>foo_txt_future</code>准备好时，我们将结果分配给<code>content</code>变量并继续执行<code>example</code>函数的代码：如果<code>content.len()</code>小于状态结构体中保存的<code>min_len</code>，我们异步读取<code>bar.txt</code>文件。我们再次将<code>.await</code>操作转换成一个状态变化，这次是到<code>WaitingOnBarTxt</code>状态。由于我们在一个循环中执行<code>match</code>，所以执行直接跳到新状态的<code>match</code>分支，并轮询<code>bar_txt_future</code>。</p>
<p>如果我们进入<code>else</code>分支，则不会进行下一步的<code>.await</code>操作，我们达到函数的结尾并将<code>content</code>包装在<code>Poll::ready</code>中返回。我们还将当前的状态更改为<code>End</code>状态。</p>
<ul>
<li>“WaitingOnBarTxt”的状态</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(state) =&gt; &#123;<br>    <span class="hljs-keyword">match</span> state.bar_txt_future.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>        Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,<br>        Poll::<span class="hljs-title function_ invoke__">Ready</span>(bar_txt) =&gt; &#123;<br>            *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(EndState);<br>            <span class="hljs-comment">// from body of `example`</span><br>            <span class="hljs-keyword">return</span> Poll::<span class="hljs-title function_ invoke__">Ready</span>(state.content + &amp;bar_txt);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们先轮询<code>bar_txt_future</code>。如果它还没有准备好，我们推出循环并返回<code>Poll::Pending</code>。反之，我们可以执行<code>example</code>函数的最后一个操作:将<code>content</code>变量与future的结果链接起来。我们将状态机更改为<code>End</code>并在<code>Poll::Ready</code>中返回结果。</p>
<ul>
<li>最后，<code>End</code>状态的代码如下</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(_) =&gt; &#123;<br><span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;poll called after Poll::Ready was returned&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Future在返回<code>Poll::Ready</code>后不应该再被轮询，所以在<code>End</code>状态下调用<code>poll</code>，会panic。</p>
<p>因为完整的函数体，在状态机实现，函数为宜需要做的事情是初始化状态机并返回它。生成的代码是这样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> ExampleStateMachine &#123;<br>    ExampleStateMachine::<span class="hljs-title function_ invoke__">Start</span>(StartState &#123;<br>        min_len,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个函数没有<code>async</code>，因为它明确的返回了一个实现了<code>Future</code>trait的<code>ExampleStateMachine</code>类型。状态机在<code>Start</code>状态中构造，相应的状态结果体被初始化为<code>min_len</code>参数。</p>
<h3 id="2-4-Pinning"><a href="#2-4-Pinning" class="headerlink" title="2.4. Pinning"></a>2.4. Pinning</h3><h4 id="2-4-1-Self-Referential-Structs"><a href="#2-4-1-Self-Referential-Structs" class="headerlink" title="2.4.1. Self-Referential Structs"></a>2.4.1. Self-Referential Structs</h4><h4 id="2-4-2-自引用結構體的問題"><a href="#2-4-2-自引用結構體的問題" class="headerlink" title="2.4.2. 自引用結構體的問題"></a>2.4.2. 自引用結構體的問題</h4><h4 id="2-4-3-可能的解決方案"><a href="#2-4-3-可能的解決方案" class="headerlink" title="2.4.3. 可能的解決方案"></a>2.4.3. 可能的解決方案</h4><h4 id="2-4-4-堆上之數值"><a href="#2-4-4-堆上之數值" class="headerlink" title="2.4.4. 堆上之數值"></a>2.4.4. 堆上之數值</h4><h4 id="2-4-5-栈上钉住-Pin"><a href="#2-4-5-栈上钉住-Pin" class="headerlink" title="2.4.5. 栈上钉住 Pin&lt;&amp;mut T&gt;"></a>2.4.5. 栈上钉住 Pin&lt;&amp;mut T&gt;</h4><h4 id="2-4-6-钉住操作和-Futures"><a href="#2-4-6-钉住操作和-Futures" class="headerlink" title="2.4.6. 钉住操作和 Futures"></a>2.4.6. 钉住操作和 Futures</h4><h3 id="2-5-执行器和唤醒器"><a href="#2-5-执行器和唤醒器" class="headerlink" title="2.5. 执行器和唤醒器"></a>2.5. 执行器和唤醒器</h3><p>使用 async&#x2F;await，我们可以使用完全异步的方式使用futures。然而futures在被轮询之前不会做任何事。这意味着我们必须在某个时刻调用<code>poll</code>，否则异步代码永远不会执行。</p>
<p>使用单独的future，我们可以手动循环等待每个future。然而，这种方法非常低效，对于大量future的程序来说并不实用。这个问题的常见解决方案是定义一个全局的执行器，它负责轮询系统中的所有的future直到它们完成。</p>
<h4 id="2-5-1-执行器Executors"><a href="#2-5-1-执行器Executors" class="headerlink" title="2.5.1. 执行器Executors"></a>2.5.1. 执行器Executors</h4><p>执行器的目的是允许future作为独立任务进行生成，通过<code>spawn</code>方法。然后执行器负责轮询所有的future直到它们完成。管理所有future的一个重要优势是，当future返回<code>Poll::Pending</code>时，执行器可以切换到另一个future。因此，异步操作是并行运行的，并且CPU保存忙碌。</p>
<p>许多执行器的实现可以利用多个CPU核心的系统。它们创建了一个线程池thread pool，如果有足够的空间可以用，它可以利用所有核心，利用工作窃取之类的技术来平衡核心之间的负载。还有一些针对嵌入式系统的特色执行器实现，优化来低延迟和内存开销。</p>
<p>为了避免重复轮询future的开销，执行器通常是利用Rust的futures支持的唤醒器 <em>waker API</em>。</p>
<h4 id="2-5-2-唤醒器-Wakers"><a href="#2-5-2-唤醒器-Wakers" class="headerlink" title="2.5.2. 唤醒器 Wakers"></a>2.5.2. 唤醒器 Wakers</h4><p>唤醒器的想法是，一个特殊的<code>Waker</code>类型被传递给每一个<code>poll</code>调用，它被包装在<code>Context</code>类型中。这个<code>Waker</code>类型是由执行器创建的，可以被异步任务来通知它的完成。因此，执行器不需要在之前返回<code>Poll::Pending</code>的future上调用<code>poll</code>，直到它被相应的唤醒器通知。</p>
<p>这通过一个例子说明</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_file</span>() &#123;<br>    <span class="hljs-title function_ invoke__">async_write_file</span>(<span class="hljs-string">&quot;foo.txxt&quot;</span>,<span class="hljs-string">&quot;Hello&quot;</span>).<span class="hljs-keyword">await</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个函数异步的将字符串“Hello”写入到“foo.txt”文件中。由于硬盘写入需要时间，这个future到第一次<code>poll</code>调用可能会返回<code>Poll::Pending</code>。然而，硬盘驱动程序将内部存储传递给<code>poll</code>调用的<code>Waker</code>，并在文件写入到硬盘时使用它来通知执行器。这样，执行器在收到唤醒器通知之前不需要浪费任何时间尝试再次<code>poll</code>这个future。</p>
<h3 id="2-6-协作式多任务？"><a href="#2-6-协作式多任务？" class="headerlink" title="2.6. 协作式多任务？"></a>2.6. 协作式多任务？</h3><p>抢占式多任务依赖操作系统强制在运行任务之间切换，但协作式多任务要求任务定期通过<code>yield</code>操作自愿放弃CPU控制。协作式方法的一个巨大优势就是任务可以自己保存他们的状态，这导致更有效的上下文切换，并且使得可以在任务之间共享相同的调用栈。</p>
<p>这可能不是显而易见，但futures和async&#x2F;await是协作式多任务模式的一组体现：</p>
<ul>
<li>每个添加到执行器的future基本上是一个协作式任务</li>
<li>不同于显示使用yield操作，futures通过返回<code>Poll::Pending</code>来放弃CPU控制（或者在结束时返回<code>Poll::Ready</code>）<ul>
<li>没有任何东西强制futures放弃CPU控制。如果他们想要，他们可以永远不从<code>poll</code>返回，例如通过在循环中无休止的旋转</li>
<li>由于每个future都可以阻塞执行器中的其他future的执行，我们需要相信他们不是恶意的。</li>
</ul>
</li>
<li>Future内部存储来所有他们需要的状态，以便在下一次<code>poll</code>调用时继续执行。使用async&#x2F;await，编译器自动检测所有需要的变量并将他们存储在生成的状态中。<ul>
<li>只保存了继续执行所需的最小状态</li>
<li>由于<code>poll</code>方法在返回时放弃了调用栈；他们只是使用了一些不同的术语。在接下来的内容中，任务和future两个术语混用。</li>
</ul>
</li>
</ul>
<h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><p><code>Future</code>trait是<code>core</code>库的一部分，而<code>async/await</code>是语言本身的一个特性，所以在<code>#![no_std]</code>内核中使用它时不需要做任何特殊的事情。</p>
<p>例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">async_number</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-number">42</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example_task</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-title function_ invoke__">async_number</span>().<span class="hljs-keyword">await</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;async number: &#123;&#125;&quot;</span>, number);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数<code>async_number</code>是一个<code>async fn</code>，所以编译器将它转换为一个实现了<code>Future</code>的状态机。由于函数只返回42，所以生成的future将在第一次<code>poll</code>调用时直接返回<code>Poll::Ready(42)</code>。像<code>async_number</code>一样，<code>example_task</code>函数也是一个<code>async fn</code>。它等待<code>async_number</code>返回的数字，然后打印出来。</p>
<p>为运行<code>example_task</code>返回future，我们需要在它上调用<code>poll</code>直到它通过返回<code>Poll::Ready</code>来标志它的完成。为了做到这一点，需要一个执行器类型。</p>
<h3 id="3-1-任务Task"><a href="#3-1-任务Task" class="headerlink" title="3.1. 任务Task"></a>3.1. 任务Task</h3><p>执行器之前需要一个<code>task</code>模块，里面包含一个<code>Task</code>类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> task;<br><br><span class="hljs-keyword">use</span> core::&#123;future::Future, pin::Pin&#125;;<br><span class="hljs-keyword">use</span> alloc::boxed::<span class="hljs-type">Box</span>;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> &#123;<br>    future: Pin&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Future&lt;Output = ()&gt;&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Task</code>结构体上一个对堆分配的、钉住的、动态分发的future的新型包装，它的输出类型是()</p>
<ul>
<li>我们要求任务关联的future返回<code>()</code>。这意味着任务不返回任何结果，他们只是执行他们的副作用。例如，我们在上面定义的<code>example_task</code>函数没有返回值，但它作为副作用打印来一些东西在屏幕上。</li>
<li>关键字<code>dyn</code>表示我们在<code>Box</code>中存储来一个trait object。这意味着future上的方法是动态分发的，允许不同类型的future存储在<code>Task</code>类型中。这很重要，因为每个<code>async fn</code>都有自己的类型，我们希望能够创建多个不同的任务。</li>
<li>Pin<Box>类型通过将值放在堆上并防止创建堆它的<code>&amp;mut</code>引用来确保在内存中不会被移动。这很重要，因为由async&#x2F;await生成的future可能是自引用的，即包含自己的指针，当future被移动时这些指针失效。<br>为允许从future创建新的<code>Task</code>，我们创建一个<code>new</code>函数。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// in src/task/mod.rs</span><br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(future: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = ()&gt; + <span class="hljs-symbol">&#x27;static</span>) <span class="hljs-punctuation">-&gt;</span> Task &#123;<br>        Task &#123;<br>            future: <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">pin</span>(future),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数带有一个任意的future，它的输出类型是<code>()</code>，并通过<code>Box::pin</code>函数在内存中钉住它。然后它将被包装的future放到<code>Task</code>结构体中并返回它。这里需要<code>‘static</code>生命周期，因为返回的<code>Task</code>可以存活在任意时间，所以future也需要在那个时间内有效。</p>
<p>增加里一个<code>poll</code>方法，允许执行器轮询持有的future：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// in src/task/mod.rs</span><br><br><span class="hljs-keyword">use</span> core::task::&#123;Context, Poll&#125;;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, context: &amp;<span class="hljs-keyword">mut</span> Context) <span class="hljs-punctuation">-&gt;</span> Poll&lt;()&gt; &#123;<br>        <span class="hljs-keyword">self</span>.future.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">poll</span>(context)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于<code>Future</code>trait的<code>poll</code>方法期望在<code>Pin&lt;&amp;mut T&gt;</code>类型上调用，我们首先使用<code>Pin::as_mut</code>方法<code>self.future</code>字段从<code>Pin&lt;Box&lt;T&gt;&gt;</code>类型转换为<code>Pin&lt;&amp;mut T&gt;</code>类型。然后我们在转换后的<code>self.future</code>字段上调用<code>poll</code>，并返回结果。由于<code>Task::poll</code>方法只应该由我们即将创建的执行器调用，我们将函数保持为<code>task</code>私有。</p>
<h3 id="3-2-简单的执行器"><a href="#3-2-简单的执行器" class="headerlink" title="3.2. 简单的执行器"></a>3.2. 简单的执行器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> simple_executor;<br><br><span class="hljs-keyword">use</span> super::Task;<br><span class="hljs-keyword">use</span> alloc::collections::VecDeque;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SimpleExecutor</span> &#123;<br>  task_queue: VecDeque&lt;Task&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SimpleExecutor</span> &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> SimpleExecutor &#123;<br>    SimpleExecutor &#123;<br>      task_queue: VecDeque::<span class="hljs-title function_ invoke__">new</span>(),<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">spawn</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, task: Task) &#123;<br>    <span class="hljs-keyword">self</span>.task_queue.<span class="hljs-title function_ invoke__">push_back</span>(task)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这结构体包含<code>task_queue</code>字段，类型是<code>VecDeque</code>，它基本上是一个允许在两端进行推送和弹出操作的向量。使用这种，我们可以通过<code>spawn</code>方法在末尾插入新的任务，并从前面弹出下一个任务进行执行，这样就有了一个简单的<code>FIFO queue</code>。</p>
<h4 id="3-2-1-摆设型唤醒器Dummy-Waker"><a href="#3-2-1-摆设型唤醒器Dummy-Waker" class="headerlink" title="3.2.1. 摆设型唤醒器Dummy Waker"></a>3.2.1. 摆设型唤醒器Dummy Waker</h4><p>为了调用<code>poll</code>方法，我们需要创建一个<code>Context</code>类型，它包装了一个<code>Waker</code>类型。为了简单起见，我们首先创建一个什么都不做的fake Waker。为此，我们创建了一个<code>RawWaker</code>实例，它定义了<code>Waker</code>的各种方法都实现，然后使用<code>Waker::from_raw</code>函数将它转换为<code>Waker</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::task::&#123;Waker, RawWaker&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dummy_raw_waker</span>() <span class="hljs-punctuation">-&gt;</span> RawWaker &#123;<br>    todo!();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dummy_waker</span>() <span class="hljs-punctuation">-&gt;</span> Waker &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123; Waker::<span class="hljs-title function_ invoke__">from_raw</span>(<span class="hljs-title function_ invoke__">dummy_raw_waker</span>()) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先理解一下<code>RawWaker</code>类型的工作原理</p>
<ul>
<li>RawWaker<br>类型<code>RawWaker</code>要求程序员定义一个虚拟方法表，它指定了在<code>RawWaker</code>被克隆、唤醒或丢弃时应该调用的函数。这个vtable的布局由<code>RawWakerVTable</code>类型定义。每个函数接收一个<code>*const()</code>参数，这是一个对某个值type-erased指针。使用<code>*const()</code>指针而不是正确的引用的原因是，<code>RawWaker</code>类型应该是非范型的，但仍支持任意类型。通过将它放入<code>RawWaker::new</code>的<code>data</code>参数中提供，这个函数只初始化了一个<code>RawWaker</code>。然后<code>Waker</code>使用这个<code>RawWaker</code>来使用<code>data</code>调用这个vtable函数。</li>
</ul>
<p>通常，<code>RawWaker</code>是为一些堆分配的结构体创建的，它被包装到<code>Box</code>或<code>Arc</code>类型中。对于这样的类型可以使用<code>Box::into_raw</code>这样的方法将<code>Box&lt;T&gt;</code>转换为<code>*const T</code>指针。然后可以将这个指针转换为匿名的<code>*const()</code>指针并传递给<code>RawWaker::new</code>。由于每个vtable函数都接收相同的<code>*const()</code>作为参数，所以函数可以安全的将指针转换会<code>Box&lt;T&gt;</code>或<code>&amp;T</code>来操作它。正如你所预料的，这个过程非常危险，并且很容易在出错时导致未定义的行为。因此不建议手动创建<code>RawWaker</code>。</p>
<ul>
<li>摆设型RawWaker</li>
</ul>
<p>手工创建不被推荐可以使用以下相对安全的方式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::task::RawWakerVTable;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dummy_raw_waker</span>() <span class="hljs-punctuation">-&gt;</span> RawWaker &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">no_op</span>(_: *<span class="hljs-title function_ invoke__">const</span> ()) &#123;&#125;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone</span>(_: *<span class="hljs-title function_ invoke__">const</span> ()) <span class="hljs-punctuation">-&gt;</span> RawWaker &#123;<br>    <span class="hljs-title function_ invoke__">dummy_raw_waker</span>()<br>  &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">vtable</span> = &amp;RawWakerVTable::<span class="hljs-title function_ invoke__">new</span>(clone, no_op, no_op, no_op);<br>    RawWaker::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> *<span class="hljs-title function_ invoke__">const</span> (), vtable)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里定义了两个函数<code>no_op</code>和<code>clone</code>。<code>no_op</code>函数接收一个<code>*const()</code>指针并且什么都不做。<code>clone</code>函数也接收一个<code>*const()</code>指针并且通过再次调用<code>dummy_raw_waker</code>返回一个新的<code>RawWaker</code>。我们使用这两个函数来创建一个最小的<code>RawWakerVTable: clone</code>函数用于克隆操作，<code>no_op</code>函数用于所有其他操作。由于<code>RawWaker</code>什么都不做，所以我们从<code>clone</code>返回一个新的&#96;&#96;RawWaker而不是克隆它。</p>
<p>创建<code>vtable</code>后，我们使用<code>RawWaker::new</code>函数创建<code>RawWaker</code>。传递的<code>*const()</code>没有关系，因为vtable函数都不使用它。因此，我们只传递了一个空指针。</p>
<ul>
<li>run方法<br>现在有了<code>Waker</code>实例的方法，我们可以使用它来在执行器上实现一个<code>run</code>方法。最简单的<code>run</code>方法是重复的在循环中轮询所有排队的任务，直到他们完成。这并不高效啊，因为它没有利用<code>Waker</code>类型的通知，但这是一个让执行器运行起来的方法：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::task::&#123;Context, Poll&#125;;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SimpleExecutor</span> &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">mut</span> task) = <span class="hljs-keyword">self</span>.task_queue.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-variable">waker</span> = <span class="hljs-title function_ invoke__">dummy_waker</span>();<br>      <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">context</span> = Context::<span class="hljs-title function_ invoke__">from_waker</span>(&amp;waker);<br>      <span class="hljs-keyword">match</span> task.<span class="hljs-title function_ invoke__">poll</span>(&amp;<span class="hljs-keyword">mut</span> context) &#123;<br>        Poll::<span class="hljs-title function_ invoke__">Ready</span>(()) =&gt; &#123;&#125; <span class="hljs-comment">// task done</span><br>        Poll::Pending =&gt; <span class="hljs-keyword">self</span>.task_queue.<span class="hljs-title function_ invoke__">push_back</span>(task),<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数使用<code>while let</code>循环来处理<code>task_queue</code>中所有的任务。对于每个任务，它首先通过包装<code>dummy_waker</code>函数返回的<code>Waker</code>实例来创建一个<code>Context</code>类型。然后它使用这个<code>context</code>调用<code>Task::poll</code>方法。如果<code>poll</code>方法返回<code>Poll::Ready</code>,则任务已完成，我们可以继续下一个任务。如果任务仍然是<code>Poll::Pending</code>，我们将它再次添加到队列末尾，这样它将在后续的循环迭代中再次被轮询。</p>
<ul>
<li>尝试</li>
</ul>
<p>我们有了<code>SimpleExecutor</code>类型，现在可以尝试运行任务。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// in src/main.rs</span><br><br><span class="hljs-keyword">use</span> blog_os::task::&#123;Task, simple_executor::SimpleExecutor&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">kernel_main</span>(boot_info: &amp;<span class="hljs-symbol">&#x27;static</span> BootInfo) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-comment">// […] initialization routines, including `init_heap`</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">executor</span> = SimpleExecutor::<span class="hljs-title function_ invoke__">new</span>();<br>    executor.<span class="hljs-title function_ invoke__">spawn</span>(Task::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">example_task</span>()));<br>    executor.<span class="hljs-title function_ invoke__">run</span>();<br><br>    <span class="hljs-comment">// […] test_main, &quot;it did not crash&quot; message, hlt_loop</span><br>&#125;<br><br><br><span class="hljs-comment">// Below is the example_task function again so that you don&#x27;t have to scroll up</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">async_number</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-number">42</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example_task</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-title function_ invoke__">async_number</span>().<span class="hljs-keyword">await</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;async number: &#123;&#125;&quot;</span>, number);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>首先，创建了一个新的<code>SimpleExecutor</code>类型的实例，它的<code>task_queue</code>是空的。</li>
<li>其次，我们调用异步<code>example_task</code>函数，它返回一个future。我们将这个future包装在<code>Task</code>类型中，这将它移动到堆上并钉住它，然后通过<code>spawn</code>方法将任务添加到执行器的<code>task_queue中</code>。</li>
<li>我们然后通过调用<code>run</code>方法来开始执行队列中的单个任务。包括<ul>
<li>从<code>task_queue</code>的前端弹出任务。</li>
<li>为任务创建一个<code>RawWaker</code>，将它转换为<code>Waker</code>实例，然后从中创建一个<code>Context</code>实例。</li>
<li>使用我们刚刚创建的<code>Context</code>调用任务的future的<code>poll</code>方法。</li>
<li>因为<code>example_task</code>不等待任何东西，它可以在第一次<code>poll</code>调用时直接运行到结束。这就是“async numbe”被打印的地方。</li>
<li>因为<code>example_task</code>直接返回<code>Poll::Ready</code>，它不会再次添加到任务队列中。</li>
</ul>
</li>
<li>方法<code>run</code>在<code>task_queue</code>变为空后返回。我们的<code>kernel_main</code>函数继续执行，并打印“It did not crash！”消息。</li>
</ul>
<h3 id="3-3-异步键盘输入"><a href="#3-3-异步键盘输入" class="headerlink" title="3.3. 异步键盘输入"></a>3.3. 异步键盘输入</h3><h3 id="3-4-带唤醒器支持的执行器"><a href="#3-4-带唤醒器支持的执行器" class="headerlink" title="3.4. 带唤醒器支持的执行器"></a>3.4. 带唤醒器支持的执行器</h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Rust/" class="print-no-link">#Rust</a>
      
        <a href="/tags/OS/" class="print-no-link">#OS</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Write-an-OS-in-Rust</div>
      <div>http://example.com/2025/06/16/OS/读Write-an-OS-in-Rust/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>BoBoDai</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 16, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/15/RUST%E9%97%B2%E8%B0%88%E6%9D%82%E8%AE%B0/RUST%E5%AE%8F/" title="RUST宏">
                        <span class="hidden-mobile">RUST宏</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
