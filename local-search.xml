<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>qemu安装</title>
    <link href="/2025/07/01/OS/qemu%E5%AE%89%E8%A3%85/"/>
    <url>/2025/07/01/OS/qemu%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p>一些包的安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \<br>              gawk build-essential bison flex texinfo gperf libtool patchutils bc \<br>              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev \<br>              git tmux python3 python3-pip ninja-build python3-venv wget<br></code></pre></td></tr></table></figure><h3 id="2-软件包下载和解压"><a href="#2-软件包下载和解压" class="headerlink" title="2. 软件包下载和解压"></a>2. 软件包下载和解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://download.qemu.org/qemu-10.0.2.tar.xz<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xvf qemu-10.0.2.tar.xz<br></code></pre></td></tr></table></figure><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd qemu-10.0.2<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure --target-list=riscv64-softmmu,riscv64-linux-user --prefix=/home/junbo.dai/qemu --enable-slirp<br></code></pre></td></tr></table></figure><h3 id="4-部署"><a href="#4-部署" class="headerlink" title="4. 部署"></a>4. 部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -j$(nproc)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网格图（DFS/BFS/综合应用）</title>
    <link href="/2025/06/27/%E7%AE%97%E6%B3%95/%E7%BD%91%E6%A0%BC%E5%9B%BE%EF%BC%88DFS-BFS-%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%EF%BC%89/"/>
    <url>/2025/06/27/%E7%AE%97%E6%B3%95/%E7%BD%91%E6%A0%BC%E5%9B%BE%EF%BC%88DFS-BFS-%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-DFS（深度优先）遍历框架"><a href="#1-DFS（深度优先）遍历框架" class="headerlink" title="1. DFS（深度优先）遍历框架"></a>1. DFS（深度优先）遍历框架</h2><p>通常来解决树或者图结构，岛屿问题是典型代表</p><p>DFS框架</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dfs</span>(grid: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">char</span>&gt;&gt;, i: <span class="hljs-type">usize</span>, j: <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">if</span> !<span class="hljs-title function_ invoke__">inArea</span>(grid, i, j) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-title function_ invoke__">dfs</span>(grid, i - <span class="hljs-number">1</span>, j);<br>    <span class="hljs-title function_ invoke__">dfs</span>(grid, i + <span class="hljs-number">1</span>, j);<br>    <span class="hljs-title function_ invoke__">dfs</span>(grid, i, j + <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_ invoke__">dfs</span>(grid, i, j - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_ invoke__">inArea</span>(grid: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">char</span>&gt;&gt;, i: <span class="hljs-type">usize</span>, j: <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用Docker</title>
    <link href="/2025/06/26/DevOps/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Docker/"/>
    <url>/2025/06/26/DevOps/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Docker/</url>
    
    <content type="html"><![CDATA[<h2 id="1-构建镜像-Dockerfile"><a href="#1-构建镜像-Dockerfile" class="headerlink" title="1. 构建镜像 Dockerfile"></a>1. 构建镜像 Dockerfile</h2><h3 id="1-1-常用关键字"><a href="#1-1-常用关键字" class="headerlink" title="1.1. 常用关键字"></a>1.1. 常用关键字</h3><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>定制的镜像都是基于FROM的镜像</p><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>RUN用于执行后面跟着的命令有两种形式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;命令行命令&gt;</span><br><span class="hljs-comment">#等同于在终端执行命令</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;可执行文件&quot;</span>, <span class="hljs-string">&quot;参数1&quot;</span>, <span class="hljs-string">&quot;参数2&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。</p><p>最好用一个RUN来解决问题。</p><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>复制指令，从上下文目录中复制文件道容器里指定的路径</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="hljs-string">&quot;&lt;源路径1&gt;&quot;</span>,...  <span class="hljs-string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><code>[--chown=&lt;user&gt;:&lt;group&gt;]</code>：可选参数，用户改变复制到容器内文件的拥有者和属组。<br>&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> hom* /mydir/</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span><br></code></pre></td></tr></table></figure><p>&lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>ADD指令和COPY指令类似，同样需求下推荐使用COPY</p><ul><li>ADD优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</li><li>ADD缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>类似于RUN，但是运行时机不同</p><ul><li>CMD在docker run时运行</li><li>RUN在docker build时运行<br>作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。<br>注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。<br>使用和RUN相同</li></ul><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。<br>但是, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。<br>优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。<br>注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;executeable&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param1&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;param2&gt;&quot;</span>,...]</span><br></code></pre></td></tr></table></figure><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>] <span class="hljs-comment">#定参</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="hljs-comment">#变参 </span></span><br></code></pre></td></tr></table></figure><p>如果docker run带参数，会覆盖CMD中的参数</p><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;<br><span class="hljs-keyword">ENV</span> &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...<br><span class="hljs-comment"># 可以通过$+key使用</span><br></code></pre></td></tr></table></figure><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。<br>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;&#x3D;&lt;值&gt; 来覆盖。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ARG</span> &lt;参数名&gt;[=&lt;默认值&gt;]<br></code></pre></td></tr></table></figure><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。<br>作用</p><ul><li>避免重要数据，因容器启动丢失</li><li>避免容器不断变大</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;&lt;路径1&gt;&quot;</span>, <span class="hljs-string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> &lt;路径&gt;</span><br></code></pre></td></tr></table></figure><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>  仅仅只是声明端口。</p><p>作用：<br>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。<br>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> &lt;端口<span class="hljs-number">1</span>&gt; [&lt;端口<span class="hljs-number">2</span>&gt;...]<br></code></pre></td></tr></table></figure><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户</p><h4 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h4><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span><br><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span><br><br><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</span><br></code></pre></td></tr></table></figure><h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>用于延迟构建命令的执行。<br>Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行，当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">ONBUILD</span> &lt;其它指令&gt;<br></code></pre></td></tr></table></figure><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="hljs-string">&quot;runoob&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="1-2-构建命令"><a href="#1-2-构建命令" class="headerlink" title="1.2. 构建命令"></a>1.2. 构建命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t &lt;镜像名&gt;:&lt;镜像标签&gt; .<br></code></pre></td></tr></table></figure><p>其中<code>.</code>为上下文路径，即需要用到的文件的位置，默认为Dockerfile所在的位置</p><h2 id="2-Docker-Compose"><a href="#2-Docker-Compose" class="headerlink" title="2. Docker Compose"></a>2. Docker Compose</h2><p>Compose使用的三个步骤</p><ul><li>使用Dockerfile定义应用程序的环境</li><li>使用docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li></ul><p>我们先有一个应用，之后创建对应的Dockerfile文件，之后创建 docker-compose.yml文件并运行。</p><h3 id="2-1-yml配置指令"><a href="#2-1-yml配置指令" class="headerlink" title="2.1. yml配置指令"></a>2.1. yml配置指令</h3><h4 id="2-1-1-version"><a href="#2-1-1-version" class="headerlink" title="2.1.1. version"></a>2.1.1. version</h4><p>指定yml依赖compose的哪个版本制定的。</p><h4 id="2-1-2-build"><a href="#2-1-2-build" class="headerlink" title="2.1.2. build"></a>2.1.2. build</h4><p>指定上下文路径为Dockerfile存在的位置构建的镜像</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./dir</span> <span class="hljs-comment"># 表示Dockerfile位于dir文件夹内</span><br></code></pre></td></tr></table></figure><p>或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">webapp:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">./dir</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">Dockerfile-alternate</span><br>      <span class="hljs-attr">args:</span><br>        <span class="hljs-attr">buildno:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;com.example.description=Accounting webapp&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;com.example.department=Finance&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;com.example.label-with-empty-value&quot;</span><br>      <span class="hljs-attr">target:</span> <span class="hljs-string">prod</span><br></code></pre></td></tr></table></figure><ul><li>context：上下文路径。 </li><li>dockerfile：指定构建镜像的 Dockerfile 文件名。 </li><li>args：添加构建参数，这是只能在构建过程中访问的环境变量。 </li><li>labels：设置构建镜像的标签。 </li><li>target：多层构建，可以指定构建哪一层。</li></ul><h4 id="2-1-3-cap-add-cap-drop"><a href="#2-1-3-cap-add-cap-drop" class="headerlink" title="2.1.3. cap_add, cap_drop"></a>2.1.3. cap_add, cap_drop</h4><p>添加或删除容器拥有的宿主机的内核功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cap_add:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ALL</span> <span class="hljs-comment"># 开启全部权限</span><br><span class="hljs-attr">cap_drop:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">SYS_PTRACE</span> <span class="hljs-comment"># 关闭 ptrace权限</span><br></code></pre></td></tr></table></figure><h4 id="2-1-4-cgroup-parent"><a href="#2-1-4-cgroup-parent" class="headerlink" title="2.1.4. cgroup_parent"></a>2.1.4. cgroup_parent</h4><p>为容器指定父 cgroup 组，意味着将继承该组的资源限制。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cgroup_parent:</span> <span class="hljs-string">m-executor-abcd</span><br></code></pre></td></tr></table></figure><h4 id="2-1-5-command"><a href="#2-1-5-command" class="headerlink" title="2.1.5. command"></a>2.1.5. command</h4><p>覆盖容器启动的默认命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bundle&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;thin&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;3000&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="2-1-6-container-name"><a href="#2-1-6-container-name" class="headerlink" title="2.1.6. container_name"></a>2.1.6. container_name</h4><p>指定自定义容器名称，而不是生成的默认名称。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">container_name:</span> <span class="hljs-string">my-web-container</span><br></code></pre></td></tr></table></figure><h4 id="2-1-7-depends-on"><a href="#2-1-7-depends-on" class="headerlink" title="2.1.7. depends_on"></a>2.1.7. depends_on</h4><p>设置依赖关系。</p><ul><li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li><li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li><li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres</span><br></code></pre></td></tr></table></figure><p>注意：web 服务不会等待 redis db 完全启动 之后才启动。</p><h4 id="2-1-8-deploy"><a href="#2-1-8-deploy" class="headerlink" title="2.1.8. deploy"></a>2.1.8. deploy</h4><p>指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:alpine</span><br>    <span class="hljs-attr">deploy:</span><br>      <span class="hljs-string">mode：replicated</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">6</span><br>      <span class="hljs-attr">endpoint_mode:</span> <span class="hljs-string">dnsrr</span><br>      <span class="hljs-attr">labels:</span> <br>        <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;This redis service label&quot;</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">limits:</span><br>          <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;0.50&#x27;</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">50M</span><br>        <span class="hljs-attr">reservations:</span><br>          <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;0.25&#x27;</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">20M</span><br>      <span class="hljs-attr">restart_policy:</span><br>        <span class="hljs-attr">condition:</span> <span class="hljs-string">on-failure</span><br>        <span class="hljs-attr">delay:</span> <span class="hljs-string">5s</span><br>        <span class="hljs-attr">max_attempts:</span> <span class="hljs-number">3</span><br>        <span class="hljs-attr">window:</span> <span class="hljs-string">120s</span><br></code></pre></td></tr></table></figure><ul><li>endpoint_mode：访问集群服务的方式。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">endpoint_mode:</span> <span class="hljs-string">vip</span> <br><span class="hljs-comment"># Docker 集群服务一个对外的虚拟 ip。所有的请求都会通过这个虚拟 ip 到达集群服务内部的机器。</span><br><span class="hljs-attr">endpoint_mode:</span> <span class="hljs-string">dnsrr</span><br><span class="hljs-comment"># DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群 ip 列表中的一个 ip 地址。</span><br></code></pre></td></tr></table></figure><ul><li><p>labels：在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</p></li><li><p>mode：指定服务提供的模式。</p><ul><li>replicated：复制服务，复制指定服务到集群的机器上。</li><li>global：全局服务，服务将部署至集群的每个节点。</li></ul></li><li><p>replicas：mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。</p></li><li><p>resources：配置服务器资源使用的限制，例如上例子，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用。避免占用资源过高出现异常。</p></li><li><p>restart_policy：配置如何在退出容器时重新启动容器。</p><ul><li>condition：可选 none，on-failure 或者 any（默认值：any）。</li><li>delay：设置多久之后重启（默认值：0）。</li><li>max_attempts：尝试重新启动容器的次数，超出次数，则不再尝试（默认值：一直重试）。</li><li>window：设置容器重启超时时间（默认值：0）。</li></ul></li><li><p>rollback_config：配置在更新失败的情况下应如何回滚服务。</p><ul><li>parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。</li><li>delay：每个容器组回滚之间等待的时间（默认为0s）。</li><li>failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。</li><li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li><li>max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。</li><li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。</li></ul></li><li><p>update_config：配置应如何更新服务，对于配置滚动更新很有用。</p><ul><li>parallelism：一次更新的容器数。</li><li>delay：在更新一组容器之间等待的时间。</li><li>failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。</li><li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li><li>max_failure_ratio：在更新过程中可以容忍的故障率。</li><li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。</li></ul></li></ul><h4 id="2-1-9-devices"><a href="#2-1-9-devices" class="headerlink" title="2.1.9. devices"></a>2.1.9. devices</h4><p>指定设备映射列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">devices:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-10-dns"><a href="#2-1-10-dns" class="headerlink" title="2.1.10. dns"></a>2.1.10. dns</h4><p>自定义 DNS 服务器，可以是单个值或列表的多个值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dns:</span> <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span><br><br><span class="hljs-attr">dns:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-number">9.9</span><span class="hljs-number">.9</span><span class="hljs-number">.9</span><br></code></pre></td></tr></table></figure><h4 id="2-1-11-dns-search"><a href="#2-1-11-dns-search" class="headerlink" title="2.1.11. dns_search"></a>2.1.11. dns_search</h4><p>自定义 DNS 搜索域。可以是单个值或列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dns_search:</span> <span class="hljs-string">example.com</span><br><br><span class="hljs-attr">dns_search:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">dc1.example.com</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">dc2.example.com</span><br></code></pre></td></tr></table></figure><h4 id="2-1-12-entrypoint"><a href="#2-1-12-entrypoint" class="headerlink" title="2.1.12. entrypoint"></a>2.1.12. entrypoint</h4><p>覆盖容器默认的 entrypoint。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">entrypoint:</span> <span class="hljs-string">/code/entrypoint.sh</span><br><span class="hljs-comment"># or</span><br><span class="hljs-attr">entrypoint:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">php</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">-d</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">-d</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">memory_limit=-1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">vendor/bin/phpunit</span><br></code></pre></td></tr></table></figure><h4 id="2-1-13-entrypoint"><a href="#2-1-13-entrypoint" class="headerlink" title="2.1.13. entrypoint"></a>2.1.13. entrypoint</h4><p>覆盖容器默认的 entrypoint。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">entrypoint:</span> <span class="hljs-string">/code/entrypoint.sh</span><br><span class="hljs-comment"># or</span><br><span class="hljs-attr">entrypoint:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">php</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">-d</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">-d</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">memory_limit=-1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">vendor/bin/phpunit</span><br></code></pre></td></tr></table></figure><h4 id="2-1-14-env-file"><a href="#2-1-14-env-file" class="headerlink" title="2.1.14. env_file"></a>2.1.14. env_file</h4><p>从文件添加环境变量。可以是单个值或列表的多个值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">env_file:</span> <span class="hljs-string">.env</span><br></code></pre></td></tr></table></figure><p>也可以是列表格式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">env_file:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">./common.env</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">./apps/web.env</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/secrets.env</span><br></code></pre></td></tr></table></figure><h4 id="2-1-15-environment"><a href="#2-1-15-environment" class="headerlink" title="2.1.15. environment"></a>2.1.15. environment</h4><p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">environment:</span><br>  <span class="hljs-attr">RACK_ENV:</span> <span class="hljs-string">development</span><br>  <span class="hljs-attr">SHOW:</span> <span class="hljs-string">&#x27;true&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-16-expose"><a href="#2-1-16-expose" class="headerlink" title="2.1.16. expose"></a>2.1.16. expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">expose:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8000&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-17-extra-hosts"><a href="#2-1-17-extra-hosts" class="headerlink" title="2.1.17. extra_hosts"></a>2.1.17. extra_hosts</h4><p>添加主机名映射。类似 docker client –add-host。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">extra_hosts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;somehost:162.242.195.82&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;otherhost:50.31.209.229&quot;</span><br></code></pre></td></tr></table></figure><p>以上会在此服务的内部容器中 &#x2F;etc&#x2F;hosts 创建一个具有 ip 地址和主机名的映射关系：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">162.242</span><span class="hljs-number">.195</span><span class="hljs-number">.82</span>  <span class="hljs-string">somehost</span><br><span class="hljs-number">50.31</span><span class="hljs-number">.209</span><span class="hljs-number">.229</span>   <span class="hljs-string">otherhost</span><br></code></pre></td></tr></table></figure><h4 id="2-1-18-healthcheck"><a href="#2-1-18-healthcheck" class="headerlink" title="2.1.18. healthcheck"></a>2.1.18. healthcheck</h4><p>用于检测 docker 服务是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">healthcheck:</span><br>  <span class="hljs-attr">test:</span> [<span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&quot;http://localhost&quot;</span>] <span class="hljs-comment"># 设置检测程序</span><br>  <span class="hljs-attr">interval:</span> <span class="hljs-string">1m30s</span> <span class="hljs-comment"># 设置检测间隔</span><br>  <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span> <span class="hljs-comment"># 设置检测超时时间</span><br>  <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 设置重试次数</span><br>  <span class="hljs-attr">start_period:</span> <span class="hljs-string">40s</span> <span class="hljs-comment"># 启动后，多少秒开始启动检测程序</span><br></code></pre></td></tr></table></figure><h4 id="2-1-19-image"><a href="#2-1-19-image" class="headerlink" title="2.1.19. image"></a>2.1.19. image</h4><p>指定容器运行的镜像。以下格式都可以：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">ubuntu:14.04</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">tutum/influxdb</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">example-registry.com:4000/postgresql</span><br><span class="hljs-attr">image:</span> <span class="hljs-string">a4bc65fd</span> <span class="hljs-comment"># 镜像id</span><br></code></pre></td></tr></table></figure><h4 id="2-1-20-logging"><a href="#2-1-20-logging" class="headerlink" title="2.1.20. logging"></a>2.1.20. logging</h4><p>服务的日志记录配置。<br>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">driver:</span> <span class="hljs-string">&quot;json-file&quot;</span><br><span class="hljs-attr">driver:</span> <span class="hljs-string">&quot;syslog&quot;</span><br><span class="hljs-attr">driver:</span> <span class="hljs-string">&quot;none&quot;</span><br></code></pre></td></tr></table></figure><p>仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">driver:</span> <span class="hljs-string">json-file</span><br>  <span class="hljs-attr">options:</span><br>    <span class="hljs-attr">max-size:</span> <span class="hljs-string">&quot;200k&quot;</span> <span class="hljs-comment"># 单个文件大小为200k</span><br>    <span class="hljs-attr">max-file:</span> <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-comment"># 最多10个文件</span><br></code></pre></td></tr></table></figure><p>当达到文件限制上限，会自动删除旧的文件。<br>syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">driver:</span> <span class="hljs-string">syslog</span><br>  <span class="hljs-attr">options:</span><br>    <span class="hljs-attr">syslog-address:</span> <span class="hljs-string">&quot;tcp://192.168.0.42:123&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-21-network-mode"><a href="#2-1-21-network-mode" class="headerlink" title="2.1.21. network_mode"></a>2.1.21. network_mode</h4><p>设置网络模式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;bridge&quot;</span><br><span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;host&quot;</span><br><span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;none&quot;</span><br><span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;service:[service name]&quot;</span><br><span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;container:[container name/id]&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-22-networks"><a href="#2-1-22-networks" class="headerlink" title="2.1.22. networks"></a>2.1.22. networks</h4><p>配置容器连接的网络，引用顶级 networks 下的条目 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">some-service:</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-attr">some-network:</span><br>        <span class="hljs-attr">aliases:</span><br>         <span class="hljs-bullet">-</span> <span class="hljs-string">alias1</span><br>      <span class="hljs-attr">other-network:</span><br>        <span class="hljs-attr">aliases:</span><br>         <span class="hljs-bullet">-</span> <span class="hljs-string">alias2</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">some-network:</span><br>    <span class="hljs-comment"># Use a custom driver</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">custom-driver-1</span><br>  <span class="hljs-attr">other-network:</span><br>    <span class="hljs-comment"># Use a custom driver which takes special options</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">custom-driver-2</span><br></code></pre></td></tr></table></figure><p>aliases ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</p><h4 id="2-1-23-restart"><a href="#2-1-23-restart" class="headerlink" title="2.1.23. restart"></a>2.1.23. restart</h4><ul><li>no：是默认的重启策略，在任何情况下都不会重启容器。</li><li>always：容器总是重新启动。</li><li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li><li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">restart:</span> <span class="hljs-string">&quot;no&quot;</span><br><span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br><span class="hljs-attr">restart:</span> <span class="hljs-string">on-failure</span><br><span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br></code></pre></td></tr></table></figure><p>注：swarm 集群模式，请改用 restart_policy。</p><h4 id="2-1-24-secrets"><a href="#2-1-24-secrets" class="headerlink" title="2.1.24. secrets"></a>2.1.24. secrets</h4><p>存储敏感数据，例如密码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.1&quot;</span><br><span class="hljs-attr">services:</span><br><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD_FILE:</span> <span class="hljs-string">/run/secrets/my_secret</span><br>    <span class="hljs-attr">secrets:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my_secret</span><br><br>  <span class="hljs-attr">secrets:</span><br>    <span class="hljs-attr">my_secret:</span><br>      <span class="hljs-attr">file:</span> <span class="hljs-string">./my_secret.txt</span><br></code></pre></td></tr></table></figure><h4 id="2-1-25-security-opt"><a href="#2-1-25-security-opt" class="headerlink" title="2.1.25. security_opt"></a>2.1.25. security_opt</h4><p>修改容器默认的 schema 标签。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">security-opt：</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">label:user:USER</span>   <span class="hljs-comment"># 设置容器的用户标签</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">label:role:ROLE</span>   <span class="hljs-comment"># 设置容器的角色标签</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">label:type:TYPE</span>   <span class="hljs-comment"># 设置容器的安全策略标签</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">label:level:LEVEL</span>  <span class="hljs-comment"># 设置容器的安全等级标签</span><br></code></pre></td></tr></table></figure><h4 id="2-1-26-stop-grace-period"><a href="#2-1-26-stop-grace-period" class="headerlink" title="2.1.26. stop_grace_period"></a>2.1.26. stop_grace_period</h4><p>指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">stop_grace_period:</span> <span class="hljs-string">1s</span> <span class="hljs-comment"># 等待 1 秒</span><br><span class="hljs-attr">stop_grace_period:</span> <span class="hljs-string">1m30s</span> <span class="hljs-comment"># 等待 1 分 30 秒 </span><br></code></pre></td></tr></table></figure><h4 id="2-1-27-stop-signal"><a href="#2-1-27-stop-signal" class="headerlink" title="2.1.27. stop_signal"></a>2.1.27. stop_signal</h4><p>设置停止容器的替代信号。默认情况下使用 SIGTERM 。<br>以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">stop_signal:</span> <span class="hljs-string">SIGUSR1</span><br></code></pre></td></tr></table></figure><h4 id="2-1-28-sysctls"><a href="#2-1-28-sysctls" class="headerlink" title="2.1.28. sysctls"></a>2.1.28. sysctls</h4><p>设置容器中的内核参数，可以使用数组或字典格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-attr">net.core.somaxconn:</span> <span class="hljs-number">1024</span><br>  <span class="hljs-attr">net.ipv4.tcp_syncookies:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">sysctls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.core.somaxconn=1024</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">net.ipv4.tcp_syncookies=0</span><br></code></pre></td></tr></table></figure><h4 id="2-1-29-tmpfs"><a href="#2-1-29-tmpfs" class="headerlink" title="2.1.29. tmpfs"></a>2.1.29. tmpfs</h4><p>在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tmpfs:</span> <span class="hljs-string">/run</span><br><br><span class="hljs-attr">tmpfs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/run</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/tmp</span><br></code></pre></td></tr></table></figure><h4 id="2-1-30-ulimits"><a href="#2-1-30-ulimits" class="headerlink" title="2.1.30. ulimits"></a>2.1.30. ulimits</h4><p>覆盖容器默认的 ulimit。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ulimits:</span><br>  <span class="hljs-attr">nproc:</span> <span class="hljs-number">65535</span><br>  <span class="hljs-attr">nofile:</span><br>    <span class="hljs-attr">soft:</span> <span class="hljs-number">20000</span><br>    <span class="hljs-attr">hard:</span> <span class="hljs-number">40000</span><br></code></pre></td></tr></table></figure><h4 id="2-1-31-volumes"><a href="#2-1-31-volumes" class="headerlink" title="2.1.31. volumes"></a>2.1.31. volumes</h4><p>将主机的数据卷或者文件挂载到容器里。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:latest</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/localhost/data:/var/lib/postgresql/data&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-构建和运行指令"><a href="#2-2-构建和运行指令" class="headerlink" title="2.2. 构建和运行指令"></a>2.2. 构建和运行指令</h3><h4 id="2-2-1-启动应用程序"><a href="#2-2-1-启动应用程序" class="headerlink" title="2.2.1 启动应用程序"></a>2.2.1 启动应用程序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up<br></code></pre></td></tr></table></figure><p>后台运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="3-Docker-使用命令"><a href="#3-Docker-使用命令" class="headerlink" title="3. Docker 使用命令"></a>3. Docker 使用命令</h2><h3 id="3-1-Docker-run-命令"><a href="#3-1-Docker-run-命令" class="headerlink" title="3.1. Docker run 命令"></a>3.1. Docker run 命令</h3><p>docker run命令用于创建并启动一个新的容器</p><h4 id="3-1-1-语法"><a href="#3-1-1-语法" class="headerlink" title="3.1.1. 语法"></a>3.1.1. 语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure><h4 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2. 使用"></a>3.1.2. 使用</h4><h4 id="3-1-2-1-基本使用"><a href="#3-1-2-1-基本使用" class="headerlink" title="3.1.2.1. 基本使用"></a>3.1.2.1. 基本使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run ubuntu<br></code></pre></td></tr></table></figure><p>拉取 ubuntu 镜像并在前台启动一个容器。</p><h4 id="3-1-2-2-后台运行容器"><a href="#3-1-2-2-后台运行容器" class="headerlink" title="3.1.2.2. 后台运行容器"></a>3.1.2.2. 后台运行容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d ubuntu<br></code></pre></td></tr></table></figure><p>在后台运行 ubuntu 容器并返回容器 ID。</p><h4 id="3-1-2-3-交互式运行并分配终端"><a href="#3-1-2-3-交互式运行并分配终端" class="headerlink" title="3.1.2.3. 交互式运行并分配终端"></a>3.1.2.3. 交互式运行并分配终端</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it ubuntu /bin/bash<br></code></pre></td></tr></table></figure><p>以交互模式运行 ubuntu 容器，并启动一个 Bash shell。</p><h4 id="3-1-2-4-指定容器名称"><a href="#3-1-2-4-指定容器名称" class="headerlink" title="3.1.2.4. 指定容器名称"></a>3.1.2.4. 指定容器名称</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name my_container ubuntu<br></code></pre></td></tr></table></figure><p>运行一个 ubuntu 容器，并将其命名为 my_container。</p><h4 id="3-1-2-5-端口映射"><a href="#3-1-2-5-端口映射" class="headerlink" title="3.1.2.5. 端口映射"></a>3.1.2.5. 端口映射</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -p 8080:80 nginx<br></code></pre></td></tr></table></figure><p>将本地主机的 8080 端口映射到容器内的 80 端口，运行 nginx 容器。</p><h4 id="3-1-2-6-挂载卷"><a href="#3-1-2-6-挂载卷" class="headerlink" title="3.1.2.6. 挂载卷"></a>3.1.2.6. 挂载卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -v /host/data:/container/data ubuntu<br></code></pre></td></tr></table></figure><p>将主机的 &#x2F;host&#x2F;data 目录挂载到容器内的 &#x2F;container&#x2F;data 目录。</p><h4 id="3-1-2-7-设置环境变量"><a href="#3-1-2-7-设置环境变量" class="headerlink" title="3.1.2.7. 设置环境变量"></a>3.1.2.7. 设置环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -e MY_ENV_VAR=my_value ubuntu<br></code></pre></td></tr></table></figure><p>设置环境变量 MY_ENV_VAR 的值为 my_value，运行 ubuntu 容器。</p><h4 id="3-1-2-8-使用网络模式"><a href="#3-1-2-8-使用网络模式" class="headerlink" title="3.1.2.8. 使用网络模式"></a>3.1.2.8. 使用网络模式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --network host nginx<br></code></pre></td></tr></table></figure><p>使用主机的网络模式运行 nginx 容器。</p><h4 id="3-1-2-9-指定重启策略"><a href="#3-1-2-9-指定重启策略" class="headerlink" title="3.1.2.9. 指定重启策略"></a>3.1.2.9. 指定重启策略</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --restart always nginx<br></code></pre></td></tr></table></figure><p>设置容器的重启策略为 always，即使容器停止也会自动重启。</p><h4 id="3-1-2-10-指定用户"><a href="#3-1-2-10-指定用户" class="headerlink" title="3.1.2.10. 指定用户"></a>3.1.2.10. 指定用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -u user123 ubuntu<br></code></pre></td></tr></table></figure><p>以 user123 用户运行 ubuntu 容器。</p><h4 id="3-1-2-11-组合多个选项"><a href="#3-1-2-11-组合多个选项" class="headerlink" title="3.1.2.11. 组合多个选项"></a>3.1.2.11. 组合多个选项</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 8080:80 -v /host/data:/data --name webserver nginx<br></code></pre></td></tr></table></figure><p>后台运行一个命名为 webserver 的 nginx 容器，将主机的 8080 端口映射到容器的 80 端口，并将主机的 &#x2F;host&#x2F;data 目录挂载到容器的 &#x2F;data 目录。</p><h3 id="3-2-Docker-start-stop-restart-命令"><a href="#3-2-Docker-start-stop-restart-命令" class="headerlink" title="3.2. Docker start&#x2F;stop&#x2F;restart 命令"></a>3.2. Docker start&#x2F;stop&#x2F;restart 命令</h3><p>docker start 命令用于启动一个或多个已经创建的容器。<br>docker stop 命令用于停止一个运行中的容器。<br>docker restart 命令用于重启容器。</p><h4 id="3-2-1-docker-start-命令"><a href="#3-2-1-docker-start-命令" class="headerlink" title="3.2.1. docker start 命令"></a>3.2.1. docker start 命令</h4><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><h5 id="3-2-1-1-启动一个容器"><a href="#3-2-1-1-启动一个容器" class="headerlink" title="3.2.1.1. 启动一个容器"></a>3.2.1.1. 启动一个容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start my_container<br></code></pre></td></tr></table></figure><p>启动名称为 my_container 的容器。</p><h5 id="3-2-1-2-启动并附加到容器"><a href="#3-2-1-2-启动并附加到容器" class="headerlink" title="3.2.1.2. 启动并附加到容器"></a>3.2.1.2. 启动并附加到容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start -a my_container<br></code></pre></td></tr></table></figure><p>启动容器并附加到它的标准输入输出流。</p><h5 id="3-2-1-3-同时启动多个容器"><a href="#3-2-1-3-同时启动多个容器" class="headerlink" title="3.2.1.3. 同时启动多个容器"></a>3.2.1.3. 同时启动多个容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start container1 container2 container3<br></code></pre></td></tr></table></figure><p>同时启动 container1、container2 和 container3 容器。</p><h4 id="3-2-2-docker-stop-命令"><a href="#3-2-2-docker-stop-命令" class="headerlink" title="3.2.2. docker stop 命令"></a>3.2.2. docker stop 命令</h4><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><h5 id="3-2-2-1-停止一个容器"><a href="#3-2-2-1-停止一个容器" class="headerlink" title="3.2.2.1. 停止一个容器"></a>3.2.2.1. 停止一个容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop my_container<br></code></pre></td></tr></table></figure><p>停止名称为 my_container 的容器。</p><h5 id="3-2-2-2-指定等待时间停止容器"><a href="#3-2-2-2-指定等待时间停止容器" class="headerlink" title="3.2.2.2. 指定等待时间停止容器"></a>3.2.2.2. 指定等待时间停止容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop -t 30 my_container<br></code></pre></td></tr></table></figure><p>等待 30 秒后停止容器。</p><h5 id="3-2-2-3-同时停止多个容器"><a href="#3-2-2-3-同时停止多个容器" class="headerlink" title="3.2.2.3. 同时停止多个容器"></a>3.2.2.3. 同时停止多个容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop container1 container2 container3<br></code></pre></td></tr></table></figure><p>同时停止 container1、container2 和 container3 容器。</p><h4 id="3-2-3-docker-restart-命令"><a href="#3-2-3-docker-restart-命令" class="headerlink" title="3.2.3. docker restart 命令"></a>3.2.3. docker restart 命令</h4><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><h5 id="3-2-3-1-重启一个容器"><a href="#3-2-3-1-重启一个容器" class="headerlink" title="3.2.3.1. 重启一个容器"></a>3.2.3.1. 重启一个容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart my_container<br></code></pre></td></tr></table></figure><p>重启名称为 my_container 的容器。</p><h5 id="3-2-3-2-指定等待时间重启容器"><a href="#3-2-3-2-指定等待时间重启容器" class="headerlink" title="3.2.3.2. 指定等待时间重启容器"></a>3.2.3.2. 指定等待时间重启容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart -t 15 my_container<br></code></pre></td></tr></table></figure><p>等待 15 秒后重启容器。</p><h5 id="3-2-3-3-同时重启多个容器"><a href="#3-2-3-3-同时重启多个容器" class="headerlink" title="3.2.3.3. 同时重启多个容器"></a>3.2.3.3. 同时重启多个容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker restart container1 container2 container3<br></code></pre></td></tr></table></figure><p>同时重启 container1、container2 和 container3 容器。</p><h3 id="3-3-docker-kill-命令"><a href="#3-3-docker-kill-命令" class="headerlink" title="3.3. docker kill 命令"></a>3.3. docker kill 命令</h3><p>docker kill 命令用于立即终止一个或多个正在运行的容器。<br>与 docker stop 命令不同，docker kill 命令会直接发送 SIGKILL 信号给容器的主进程，导致容器立即停止，而不会进行优雅的关闭。</p><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p>常用信号</p><p>SIGKILL: 强制终止进程（默认信号）。<br>SIGTERM: 请求进程终止。<br>SIGINT: 发送中断信号，通常表示用户请求终止。<br>SIGHUP: 挂起信号，通常表示终端断开。</p><h4 id="3-3-1-立即终止一个容器"><a href="#3-3-1-立即终止一个容器" class="headerlink" title="3.3.1 立即终止一个容器"></a>3.3.1 立即终止一个容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill my_container<br></code></pre></td></tr></table></figure><p>立即终止名称为 my_container 的容器。</p><h4 id="3-3-2-发送自定义信号"><a href="#3-3-2-发送自定义信号" class="headerlink" title="3.3.2 发送自定义信号"></a>3.3.2 发送自定义信号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill -s SIGTERM my_container<br></code></pre></td></tr></table></figure><p>向名称为 my_container 的容器发送 SIGTERM 信号，而不是默认的 SIGKILL 信号。</p><h4 id="3-3-3-同时终止多个容器"><a href="#3-3-3-同时终止多个容器" class="headerlink" title="3.3.3 同时终止多个容器"></a>3.3.3 同时终止多个容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker kill container1 container2 container3<br></code></pre></td></tr></table></figure><p>向名称为 my_container 的容器发送 SIGTERM 信号，而不是默认的 SIGKILL 信号。<br>立即终止 container1、container2 和 container3 容器。</p><p>docker kill 命令用于立即终止一个或多个正在运行的容器，通过发送信号（默认 SIGKILL）给容器的主进程实现。与 docker stop 不同，docker kill 不会等待容器优雅地停止，而是直接终止进程。该命令在需要快速停止容器时非常有用，但应谨慎使用以避免数据损失或不一致。</p><h3 id="3-4-Docker-rm-命令"><a href="#3-4-Docker-rm-命令" class="headerlink" title="3.4 Docker rm 命令"></a>3.4 Docker rm 命令</h3><p>docker rm 命令用于删除一个或多个已经停止的容器。<br>docker rm 命令不会删除正在运行的容器，如果你需要先停止容器，可以使用 docker stop 命令。</p><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm [OPTIONS] CONTAINER [CONTAINER...]<br></code></pre></td></tr></table></figure><p>CONTAINER [CONTAINER…]: 一个或多个要删除的容器的名称或 ID。<br>OPTIONS</p><ul><li>-f, –force: 强制删除正在运行的容器（使用 SIGKILL 信号）。</li><li>-l, –link: 删除指定的连接，而不是容器本身。</li><li>-v, –volumes: 删除容器挂载的卷。</li></ul><h4 id="3-4-1-删除单个容器"><a href="#3-4-1-删除单个容器" class="headerlink" title="3.4.1. 删除单个容器"></a>3.4.1. 删除单个容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm &lt;container_id_or_name&gt;<br></code></pre></td></tr></table></figure><p>你可以一次性删除多个容器，只需将容器 ID 或名称用空格分隔</p><h4 id="3-4-2-删除所有已停止的容器"><a href="#3-4-2-删除所有已停止的容器" class="headerlink" title="3.4.2. 删除所有已停止的容器"></a>3.4.2. 删除所有已停止的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker container prune<br>docker rm $(docker ps -a -q)<br></code></pre></td></tr></table></figure><h3 id="3-5-Docker-exec-命令"><a href="#3-5-Docker-exec-命令" class="headerlink" title="3.5. Docker exec 命令"></a>3.5. Docker exec 命令</h3><p>docker exec 命令用于在运行中的容器内执行一个新的命令。这对于调试、运行附加的进程或在容器内部进行管理操作非常有用。</p><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]<br></code></pre></td></tr></table></figure><h4 id="3-5-1-在容器内运行命令"><a href="#3-5-1-在容器内运行命令" class="headerlink" title="3.5.1. 在容器内运行命令"></a>3.5.1. 在容器内运行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec my_container ls /app<br></code></pre></td></tr></table></figure><p>在运行中的 my_container 容器内执行 ls &#x2F;app 命令，列出 &#x2F;app 目录的内容。</p><h4 id="3-5-2-以交互模式运行命令"><a href="#3-5-2-以交互模式运行命令" class="headerlink" title="3.5.2. 以交互模式运行命令"></a>3.5.2. 以交互模式运行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it my_container /bin/bash<br></code></pre></td></tr></table></figure><p>在运行中的 my_container 容器内启动一个交互式的 Bash shell。-i 保持标准输入打开，-t 分配一个伪终端。</p><h4 id="3-5-3-在后台运行命令"><a href="#3-5-3-在后台运行命令" class="headerlink" title="3.5.3. 在后台运行命令"></a>3.5.3. 在后台运行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -d my_container touch /app/newfile.txt<br></code></pre></td></tr></table></figure><p>在运行中的 my_container 容器内后台执行 touch &#x2F;app&#x2F;newfile.txt 命令，创建一个新文件。</p><h4 id="3-5-4-设置环境变量"><a href="#3-5-4-设置环境变量" class="headerlink" title="3.5.4. 设置环境变量"></a>3.5.4. 设置环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -e MY_ENV_VAR=my_value my_container env<br></code></pre></td></tr></table></figure><p>在运行中的 my_container 容器内执行 env 命令，并设置环境变量 MY_ENV_VAR 的值为 my_value。</p><h4 id="3-5-5-以指定用户身份运行命令"><a href="#3-5-5-以指定用户身份运行命令" class="headerlink" title="3.5.5. 以指定用户身份运行命令"></a>3.5.5. 以指定用户身份运行命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -u user123 my_container whoami<br></code></pre></td></tr></table></figure><p>在运行中的 my_container 容器内以 user123 用户身份执行 whoami 命令。</p><h4 id="3-5-6-指定工作目录"><a href="#3-5-6-指定工作目录" class="headerlink" title="3.5.6. 指定工作目录"></a>3.5.6. 指定工作目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -w /app my_container pwd<br></code></pre></td></tr></table></figure><p>在运行中的 my_container 容器内以 &#x2F;app 目录为工作目录执行 pwd 命令。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Write-an-OS-in-Rust</title>
    <link href="/2025/06/16/OS/%E8%AF%BBWrite-an-OS-in-Rust/"/>
    <url>/2025/06/16/OS/%E8%AF%BBWrite-an-OS-in-Rust/</url>
    
    <content type="html"><![CDATA[<h2 id="1-多任务"><a href="#1-多任务" class="headerlink" title="1. 多任务"></a>1. 多任务</h2><p>大多数操作系统的基本特性就是多任务，它同时执行多个任务。<br>实际上一个CPU核心一次只能执行一个任务，操作系统快速的在活动任务之间切换，这样实现了并发。<br>多核CPU能够真正的执行多任务，8核的CPU可以同时执行8个任务，实现了并行。</p><p>多任务有两种形式</p><ul><li>协作式多任务：要求任务定期放弃对CPU的控制，以便其他任务可以取得进展。</li><li>抢占式多任务：使用操作系统功能在任意时间点强制暂停线程来切换线程。</li></ul><h3 id="1-1-协作式多任务"><a href="#1-1-协作式多任务" class="headerlink" title="1.1. 协作式多任务"></a>1.1. 协作式多任务</h3><p>协作式多任务让每个任务运行到自愿放弃对CPU的控制，而不是在任意时间点强制暂停运行的任务，这使得任务可以在方便的时间点暂停自己，例如，需要等待IO操作时。</p><p>协作式多任务通常用于语言级别，比如协程或async&#x2F;await的形式。其思想上程序员或编译器在程序中插入yield操作，这样可以放弃对CPU的控制，让其他任务运行。</p><p>通常协作式多任务与异步操作结合在一起，当一个操作还没有完成，它不会阻止其他任务运行，而是返回一个未就绪的状态。 在这种情况下，等待的任务可以执行一个yield操作，让其他任务运行。</p><h4 id="1-1-1-状态保存"><a href="#1-1-1-状态保存" class="headerlink" title="1.1.1. 状态保存"></a>1.1.1. 状态保存</h4><p>既然任务自己定义了暂停点，他们不需要操作系统保存它们的状态。反之，它们可以在暂停自己之前保存他们需要的状态，这通常会带来更好的性能。比如一个刚完成了复杂计算的任务可能只需要备份计算的最终结果，因为它不再需要中间结果。</p><p>协作式多任务的语言级实现通常甚至能够在暂停之前备份调用栈的必要部分。例如，Rust的async&#x2F;await实现会在暂停之前备份所有仍然需要的本地变量到一个自动生成的结构体中。 通过在暂停之前备份调中栈的相关部分，所有任务都可以共享一个调用栈，这导致每个任务的内存消耗大大降低。这使得可以创建几乎任意数量的协作式任务不会耗尽内存。</p><h4 id="1-1-2-讨论"><a href="#1-1-2-讨论" class="headerlink" title="1.1.2. 讨论"></a>1.1.2. 讨论</h4><p>协作式多任务的缺点是一个不合作的任务可能运行无限长的时间。因此，一个恶意或有缺陷的任务可能会阻止其他任务运行，从而减慢甚至阻塞整个系统。因此，只有当所有的任务都知道合作时，协作式多任务才应该使用。让操作系统依赖于任务用户级程序的合作是不明智的。</p><p>然而，协作式多任务的强大性能和内存优势使得它成为程序内部使用的一个好方法，特别是与异步操作系统结合使用。由于操作系统内核是一个与异步硬件交互和性能关键型程序，协作式多任务似乎是一个实现并发性的一个好办法。</p><h3 id="1-2-抢占式多任务"><a href="#1-2-抢占式多任务" class="headerlink" title="1.2. 抢占式多任务"></a>1.2. 抢占式多任务</h3><p>抢占式多任务的思想是操作系统控制何时切换任务，它利用了操作系统在每次中断时重新获得对CPU的控制， 这使得在系统有新的输入时可以进行任务切换。操作系统还可以通过配置硬件计时器在一段时间后发送中断来确定任务允许运行的确切时间。</p><p>下图是硬件中断时的任务切换过程</p><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/os_1.png" alt="rust_os_1"></p><p>第一行中，CPU正在执行程序A的任务A1所有其他任务都被暂停了。在第二行中，硬件中断到达了CPU。<br>正如在<a href="https://os.phil-opp.com/hardware-interrupts/">硬件中断</a>中描述的那样,CPU立即停止了任务A1的执行。并跳转到中断描述表（IDT）<br>中定义的中断处理程序。通过这个中断处理程序，操作系统现在再次控制了CPU，之后切换到任务B1。</p><h4 id="1-2-1-状态保存"><a href="#1-2-1-状态保存" class="headerlink" title="1.2.1. 状态保存"></a>1.2.1. 状态保存</h4><p>任务在任意时间点被中断，可能在一些计算的中间，未来能够稍后恢复他们，操作系统必须备份整个状态，包括调用栈，和所有CPU寄存器的值，也叫上下文切换。</p><p>由于调用栈可能非常大，操作系统通常为每一个任务设置一个单独的调用栈，而不是在每次任务切换时备份调用栈内容。这种有自己的栈被称为执行线程也叫线程。 通过为每个任务使用单独的栈，只需要在上下文切换时保存寄存器内容。</p><h4 id="1-2-2-讨论"><a href="#1-2-2-讨论" class="headerlink" title="1.2.2. 讨论"></a>1.2.2. 讨论</h4><p>抢占式多任务主要的好处是操作系统可以完全控制任务的允许执行时间。这样，它可以保证每个任务都能公平的获得CPU的时间，不需要信任任务合作。</p><p>抢占式多任务的缺点是每个任务都需要自己的栈，和共享栈相比，导致每个任务的内存使用量更高，而且通常限制了系统中的任务数量。 另一个缺点是操作系统总是需要在每次任务切换时保存完整的CPU寄存器状态，即使任务只使用量寄存器的一小部分。</p><p>抢占式多任务和线程是操作系统的基本组件，因为他们使得运行不受信任的用户空间程序称为可能。本文将专注于协作式多任务。</p><h2 id="2-Async-Await-in-Rust"><a href="#2-Async-Await-in-Rust" class="headerlink" title="2. Async&#x2F;Await in Rust"></a>2. Async&#x2F;Await in Rust</h2><p>Rust语言提供了对多任务的第一级别支持，这种支持以async&#x2F;await的形式呈现。</p><h3 id="2-1-Futures"><a href="#2-1-Futures" class="headerlink" title="2.1. Futures"></a>2.1. Futures</h3><p>一个Future代表一个可能还没有可用的值。这可能是，例如，由另一个任务计算或从网络下载的文件。与等待值可用不同，future使得可以继续执行直到需要值。</p><h4 id="2-1-1-例子"><a href="#2-1-1-例子" class="headerlink" title="2.1.1. 例子"></a>2.1.1. 例子</h4><p>future的概念</p><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/os_2.png" alt="rust_os_2"></p><p>这个序列图展示了一个<code>main</code>函数，它从文件系统读取文件，然后调用一个<code>foo</code>函数，这个过程重复了两次：</p><ul><li>一次同步的<code>read_file</code>调用</li><li>一次是异步的<code>async_read_file</code>调用</li></ul><p>使用异步<code>async_read_file</code>调用，文件系统直接返回一个future，并在后台异步加载文件。这使得<code>main</code>函数可以更早的调用<code>foo</code>，这样它可以与文件加载并行运行。这个例子中，文件加载在<code>foo</code>返回之前完成了，所以<code>main</code>可以在<code>foo</code>返回后直接使用文件而不需要进一步等待。</p><h4 id="2-1-2-Future-in-Rust"><a href="#2-1-2-Future-in-Rust" class="headerlink" title="2.1.2. Future in Rust"></a>2.1.2. Future in Rust</h4><p>在Rust中，futures由<code>Future</code>trait表示，它看起来像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Future</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中</p><ul><li>Output指定了异步值的类型，例如，上面的示例中<code>async_read_file</code>函数将返回一个<code>Output</code>设置为<code>File</code>的<code>Future</code>实例。</li><li>poll方法允许检查值是否已经可用。它返回一个<code>Poll</code>枚举，看起来这样。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Poll</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ready</span>(T),<br>    Pending,<br>&#125;<br></code></pre></td></tr></table></figure><p>当那个值已经可用（例如，文件已经读取完毕）。它被包装在<code>Ready</code>变体中返回。否则，返回<code>Penging</code>变体，这通知调用者该值尚不可用。</p><p>方法 <code>poll</code> 接受兩個參數：<code>self: Pin&lt;&amp;mut Self&gt;</code> 和 <code>cx: &amp;mut Context</code>。前者的行為與普通的 <code>&amp;mut self</code> 引用類似，只是 Self 值被 釘住 pinned 在它的內存位置。</p><p>参数<code>cx: &amp;mut Context</code>的目的是將一個 喚醒器 <code>Waker</code> 實例傳遞給異步任務，例如文件系統加載。 這個 <code>Waker</code> 允許異步任務發出信號，表明它已经完成。主任务知道当<code>Future</code>可用时它将被通知，所以它不需要一遍又一遍的调用<code>poll</code>。</p><h3 id="2-2-和Futures一起工作"><a href="#2-2-和Futures一起工作" class="headerlink" title="2.2. 和Futures一起工作"></a>2.2. 和Futures一起工作</h3><p>Futures 代表了异步任务的结果，这些结果可能还不可用。然而，在实践中，我们经常需要这些值來进行进一步的计算。 所以问题是：当我们需要时，我们如何有效地获取 future 的值？</p><h4 id="2-2-1-Waiting-on-Futures"><a href="#2-2-1-Waiting-on-Futures" class="headerlink" title="2.2.1. Waiting on Futures"></a>2.2.1. Waiting on Futures</h4><p>一个答案是等待直到future变得可用。这看起来像这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">file_content</span> = <span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-keyword">match</span> future.<span class="hljs-title function_ invoke__">poll</span>(…) &#123;<br>        Poll::<span class="hljs-title function_ invoke__">Ready</span>(value) =&gt; <span class="hljs-keyword">break</span> value,<br>        Poll::Pending =&gt; &#123;&#125;, <span class="hljs-comment">// do nothing</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码主动等待future，通过在一个循环中调用<code>poll</code>。这个<code>poll</code>的参数不重要。这个方案非常低效，因为我们一直占用CPU直到值变的可用。</p><p>更有效的方法可能是阻塞当前线程直到future变的可用。这种只有在线程作用下才可能，所以这个方法对内核无效。</p><h4 id="2-2-2-Future组合器"><a href="#2-2-2-Future组合器" class="headerlink" title="2.2.2. Future组合器"></a>2.2.2. Future组合器</h4><p>一个等待的替代方案是使用future组合器。Future组合器是像<code>map</code>这样的方法，它允许将future链接和组合在一起，类似于<code>Iterator</code>trait的方法。于等待future不同，这些组合器返回一个future，他们自己应用<code>poll</code>上的映射操作。</p><p>例子，一个简单的<code>string_len</code>组合器，它将<code>Future&lt;Output = String&gt;</code>转换成<code>Future&lt;Output = usize&gt;</code>可能看起来像这样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StringLen</span>&lt;F&gt; &#123;<br>    inner_future: F,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;F&gt; Future <span class="hljs-keyword">for</span> <span class="hljs-title class_">StringLen</span>&lt;F&gt; <span class="hljs-keyword">where</span> F: Future&lt;Output = <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = <span class="hljs-type">usize</span>;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> Poll&lt;T&gt; &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.inner_future.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>            Poll::<span class="hljs-title function_ invoke__">Ready</span>(S) =&gt; Poll::<span class="hljs-title function_ invoke__">Ready</span>(s.<span class="hljs-title function_ invoke__">len</span>()),<br>            Poll::Pending =&gt; Poll::Pending,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">string_len</span>(string: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">String</span>&gt;)<br>    <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">usize</span>&gt;<br>&#123;<br>    StringLen &#123;<br>        inner_future: string,<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Usage</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">file_len</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">usize</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">file_content_future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>);<br>    <span class="hljs-title function_ invoke__">string_len</span>(file_content_future)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子，的基本思想是<code>string_len</code>函数将给定的<code>Future</code>实例包装到一个新的<code>StringLen</code>结构体中，它也体现了<code>Future</code>。当包装的future被调用时，它调用内部的future。如果值还不可用，从包装的future也返回<code>Poll::Pending</code>。如果值已可用。则从<code>Poll::Ready</code>变体中提取字符串并计算它的长度。然后，它再次包装在<code>Poll::Ready</code>中并返回。</p><p>用这个<code>string_len</code>函数，我们可以计算一个异步字符串的长度而不需要等待它。由于函数再次返回一个<code>Future</code>，调用者不能直接在返回的值上工作，但需要再次使用组合器函数。这样，整个调用图变成了异步的，我们柯宇在某个时候有效的等待多个futures，例如，在<code>main</code>函数中。</p><p>因为手工编写组合器函数是很困难的，他们通常由库提供。虽然Rust标准库本身含没有提供组合器方法，但是半官方的<code>futures</code>库提供了。它的<code>FutureExt</code>trait提供了高级组合器方法，比如<code>map</code>或<code>then</code>，它们可以用来使用任意的闭包来操作结果。</p><h4 id="2-2-3-优势"><a href="#2-2-3-优势" class="headerlink" title="2.2.3. 优势"></a>2.2.3. 优势</h4><p>Future组合器的一个巨大优势是它们保存来操作的异步性。与异步I&#x2F;O接口结合使用，这种方法可以带来非常高的性能。Future组合器作为具有trait实现的普通结构体，使得编辑器可以对他们进行极限优化。更多可以参考<a href="https://aturon.github.io/blog/2016/08/11/futures/">Zero-cost futures in Rust</a>。</p><h4 id="2-2-4-缺点"><a href="#2-2-4-缺点" class="headerlink" title="2.2.4. 缺点"></a>2.2.4. 缺点</h4><p>当future组合器使得编写非常高效的代码成为可能，但它在一些情况下很难使用，这是因为类型系统和基于闭包的接口。例如下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>).<span class="hljs-title function_ invoke__">then</span>(<span class="hljs-keyword">move</span> |content| &#123;<br>        <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; min_len &#123;<br>            Either::<span class="hljs-title function_ invoke__">Left</span>(<span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;bar.txt&quot;</span>).<span class="hljs-title function_ invoke__">map</span>(|s| content + &amp;s))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Either::<span class="hljs-title function_ invoke__">Right</span>(future::<span class="hljs-title function_ invoke__">ready</span>(content))<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里先是读取文件<code>foo.txt</code>,然后使用<code>then</code>组合器来链接基于文件内容的第二个future。如果内容的长度小于给定的<code>min_len</code>，我们读取一个不同的<code>bar.txt</code>文件并使用<code>map</code>组合器将它加到<code>context</code>上。否则返回<code>foo.txt的内容</code>。</p><p>我们需要使用<code>move</code>关键字来修复传递给<code>then</code>的闭包，因为否则<code>min_len</code>将会有一个声明周期错误。我们需要使用<code>Either</code>包装器，因为<code>if</code>和<code>else</code>块必须总是有相同的类型。由于我们在块中返回不同的future类型，我们必须使用包装器类型将它们统一到一个模型中。<code>ready</code>函数将一个值包装到一个future中，这个future立即就绪。这个函数在这里是必须的，因为Either包装器期望被包装的值实现了<code>Future</code></p><p>这能很快的导致对于大型项目来说非常复杂的代码。如果设计借用和不同的生命周期，它会变的特别复杂。因此，Rust在添加对async&#x2F;await的支持时投入了大量工作，使编写异步代码变的简单。</p><h3 id="2-3-The-Async-Await-Pattern"><a href="#2-3-The-Async-Await-Pattern" class="headerlink" title="2.3. The Async&#x2F;Await Pattern"></a>2.3. The Async&#x2F;Await Pattern</h3><p>使用<code>await</code>和<code>async</code>关键字可以将一个同步函数转换为一个返回future的异步函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// the above is roughly translated by the compiler to:</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">u32</span>&gt; &#123;<br>    future::<span class="hljs-title function_ invoke__">ready</span>(<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个关键字单独使用不是很有用。在<code>async</code>函数内部，<code>await</code>关键字可以用来获取future的异步值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span>;<br>    <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; min_len&#123;<br>        content + &amp; <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        content<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数使用了组合函数。使用.await运算符，可以获取future的值而不需要任何闭包或<code>Either</code>类型。因此，我们柯宇像写同步代码一样写异步代码。</p><h4 id="2-3-1-状态机转换"><a href="#2-3-1-状态机转换" class="headerlink" title="2.3.1. 状态机转换"></a>2.3.1. 状态机转换</h4><p>后面，编译器将<code>async</code>函数体转换成一状态机，其中每个<code>.await</code>调用代表一个不同的状态。对于上面的<code>example</code>函数，编译器创建了一个具有以下四个状态的状态机。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/os_3.png" alt="rust_os_3"><br>每个状态都是不同的暂停点。</p><ul><li>“Start”和“End”代表了函数在执行的开始和结束。</li><li>“Waiting on foo.txt”状态代表了函数当前正在等待第一个<code>async_read_file</code>的结果。</li><li>同样的，“Waiting on bar.txt”状态代表了函数正在等待第二个<code>async_read_file</code>的结果暂停点。</li></ul><p>状态机通过使每个<code>poll</code>调用成为一个可能的状态转换来实现<code>Future</code>trait：<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/os_4.png" alt="rust_os_4"><br>第一个<code>poll</code>调用启动了函数并让它运行直到它达到一个还未准备好的future。如果所有future都准备好了，函数可以运行到“End”状态，并在<code>Poll::Ready</code>中返回它的结果。否则，状态机进入等待状态并返回<code>Poll::Pending</code>。在下一个<code>poll</code>调用中，状态机从最后一个等待的状态开始，并重试最后一个操作。</p><h4 id="2-3-2-保存状态"><a href="#2-3-2-保存状态" class="headerlink" title="2.3.2. 保存状态"></a>2.3.2. 保存状态</h4><p>为了能从上一个等待状态继续，状态机必须在内部保存当前状态。此外，它必须保存所有需要在下一个<code>poll</code>调用中继续执行的变量。编译器知道那些变量何时使用，他可以自动生成具有确切所需变量的结构体。</p><p>编译器为上面的<code>example</code>函数生成下面这种结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span>;<br>    <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; min_len &#123;<br>        content + &amp;<span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        content<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StartState</span> &#123;<br>    min_len: <span class="hljs-type">usize</span>,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WaitingOnFooTxtState</span> &#123;<br>    min_len: <span class="hljs-type">usize</span>,<br>    foo_txt_future: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Outtput = <span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WaitingOnBarTxState</span> &#123;<br>    context: <span class="hljs-type">String</span>,<br>    bar_txt_future: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">String</span>&gt;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EndState</span> &#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>在”start”和”Waiting on foo.txt”状态中，<code>min_len</code>参数需要被保存以便于<code>content.len()</code>进行后续比较。</li><li>“Waiting on foo.txt”状态另外保存来一个<code>foo_txt_future</code>，它代表了<code>async_read_file</code>调用返回的future。当转改继续运行时，这个future需要被再次调用，所以它被保存。</li></ul><p>“Waiting on bar.txt”状态包含了<code>content</code>变量，以便在<code>bar.txt</code>可用时进行字符串拼接。它还保存来一个<code>bar_txt_future</code>，它代表了<code>bar.txt</code>的异步加载过程。这个结构体不包含<code>min_len</code>变量，因为在<code>content.len()</code>比较之后它不再需要了。在“end”状态中不保存任何变量，因为函数已经结束。</p><h4 id="2-3-3-完整的状态机模型"><a href="#2-3-3-完整的状态机模型" class="headerlink" title="2.3.3. 完整的状态机模型"></a>2.3.3. 完整的状态机模型</h4><p>我们可以将状态组合成一个<code>enum</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ExampleStateMachine</span>&#123;<br>    <span class="hljs-title function_ invoke__">Start</span>(StartState),<br>    <span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(WaitingOnFooTxtState),<br>    <span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(WaitingOnBarTxtState),<br>    <span class="hljs-title function_ invoke__">End</span>(EndState),<br>&#125;<br></code></pre></td></tr></table></figure><p>我们定义了一个独立的枚举来表示每个状态，并将相应的状态结构体作为每个变体的字段添加到其中。未来实现状态转换，编译器基于<code>example</code>函数生成了<code>Future</code>trait到实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">ExampleStateMachine</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = <span class="hljs-type">String</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt; &#123;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> &#123;<br>                ExampleStateMachine::<span class="hljs-title function_ invoke__">Start</span>(state) =&gt; &#123;…&#125;<br>                ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(state) =&gt; &#123;…&#125;<br>                ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(state) =&gt; &#123;…&#125;<br>                ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(state) =&gt; &#123;…&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该future的<code>Output</code>类型是<code>String</code>，因为它是<code>example</code>函数的返回类型。为了实现<code>poll</code>函数，我们在一个<code>loop</code>中使用<code>match</code>语句对当前状态进行分支。我们的想法是只要可能就切换到下一个状态，并在无法继续时显示的<code>return Poll::Pending</code>。</p><ul><li><code>Start</code>状态</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">Start</span>(state) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">foo_txt_future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">state</span> = WaitingOnFooTxtState &#123;<br>        min_len: state.min_len,<br>        foo_txt_future,<br>    &#125;;<br>    *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(state);<br>&#125;<br></code></pre></td></tr></table></figure><p>状态机在函数处于<code>Start</code>状态。在这个情况下，执行所有代码直到第一个<code>.await</code>。为了处理<code>.await</code>操作，我们将状态机<code>self</code>的状态更改为<code>WaitingOnFooTxt</code>，这包括了<code>WaitingOnFooTxtState</code>结构体的构造。</p><p>因为<code>match self &#123;...&#125;</code>语句在一个循环中执行，所以执行直接跳到<code>WaitingOnFooTxt</code>分支：</p><ul><li>“WaitingOnFooTxt”的状态</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(state) =&gt; &#123;<br>    <span class="hljs-keyword">match</span> state.foo_txt_future.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>        Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,<br>        Poll::<span class="hljs-title function_ invoke__">Ready</span>(content) =&gt; &#123;<br>            <span class="hljs-comment">// from body of `example`</span><br>            <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; state.min_len &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">bar_txt_future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;bar.txt&quot;</span>);<br>                <span class="hljs-comment">// `.await` operation</span><br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">state</span> = WaitingOnBarTxtState &#123;<br>                    content,<br>                    bar_txt_future,<br>                &#125;;<br>                *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(state);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(EndState);<br>                <span class="hljs-keyword">return</span> Poll::<span class="hljs-title function_ invoke__">Ready</span>(content);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>match</code>分支中，先调用<code>foo_txt_future</code>的<code>poll</code>函数。如果还没准备好，我们退出循环并返回<code>Poll::Pending</code>。由于这种情况下<code>self</code>保持在<code>WaitingOnFooTxt</code>状态，下一个<code>poll</code>调用将进入相同的<code>match</code>分支并重试<code>foo_txt_future</code>的轮询。</p><p>当<code>foo_txt_future</code>准备好时，我们将结果分配给<code>content</code>变量并继续执行<code>example</code>函数的代码：如果<code>content.len()</code>小于状态结构体中保存的<code>min_len</code>，我们异步读取<code>bar.txt</code>文件。我们再次将<code>.await</code>操作转换成一个状态变化，这次是到<code>WaitingOnBarTxt</code>状态。由于我们在一个循环中执行<code>match</code>，所以执行直接跳到新状态的<code>match</code>分支，并轮询<code>bar_txt_future</code>。</p><p>如果我们进入<code>else</code>分支，则不会进行下一步的<code>.await</code>操作，我们达到函数的结尾并将<code>content</code>包装在<code>Poll::ready</code>中返回。我们还将当前的状态更改为<code>End</code>状态。</p><ul><li>“WaitingOnBarTxt”的状态</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(state) =&gt; &#123;<br>    <span class="hljs-keyword">match</span> state.bar_txt_future.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>        Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,<br>        Poll::<span class="hljs-title function_ invoke__">Ready</span>(bar_txt) =&gt; &#123;<br>            *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(EndState);<br>            <span class="hljs-comment">// from body of `example`</span><br>            <span class="hljs-keyword">return</span> Poll::<span class="hljs-title function_ invoke__">Ready</span>(state.content + &amp;bar_txt);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先轮询<code>bar_txt_future</code>。如果它还没有准备好，我们推出循环并返回<code>Poll::Pending</code>。反之，我们可以执行<code>example</code>函数的最后一个操作:将<code>content</code>变量与future的结果链接起来。我们将状态机更改为<code>End</code>并在<code>Poll::Ready</code>中返回结果。</p><ul><li>最后，<code>End</code>状态的代码如下</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(_) =&gt; &#123;<br><span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;poll called after Poll::Ready was returned&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Future在返回<code>Poll::Ready</code>后不应该再被轮询，所以在<code>End</code>状态下调用<code>poll</code>，会panic。</p><p>因为完整的函数体，在状态机实现，函数为宜需要做的事情是初始化状态机并返回它。生成的代码是这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> ExampleStateMachine &#123;<br>    ExampleStateMachine::<span class="hljs-title function_ invoke__">Start</span>(StartState &#123;<br>        min_len,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数没有<code>async</code>，因为它明确的返回了一个实现了<code>Future</code>trait的<code>ExampleStateMachine</code>类型。状态机在<code>Start</code>状态中构造，相应的状态结果体被初始化为<code>min_len</code>参数。</p><h3 id="2-4-Pinning"><a href="#2-4-Pinning" class="headerlink" title="2.4. Pinning"></a>2.4. Pinning</h3><h4 id="2-4-1-Self-Referential-Structs"><a href="#2-4-1-Self-Referential-Structs" class="headerlink" title="2.4.1. Self-Referential Structs"></a>2.4.1. Self-Referential Structs</h4><h4 id="2-4-2-自引用結構體的問題"><a href="#2-4-2-自引用結構體的問題" class="headerlink" title="2.4.2. 自引用結構體的問題"></a>2.4.2. 自引用結構體的問題</h4><h4 id="2-4-3-可能的解決方案"><a href="#2-4-3-可能的解決方案" class="headerlink" title="2.4.3. 可能的解決方案"></a>2.4.3. 可能的解決方案</h4><h4 id="2-4-4-堆上之數值"><a href="#2-4-4-堆上之數值" class="headerlink" title="2.4.4. 堆上之數值"></a>2.4.4. 堆上之數值</h4><h4 id="2-4-5-栈上钉住-Pin"><a href="#2-4-5-栈上钉住-Pin" class="headerlink" title="2.4.5. 栈上钉住 Pin&lt;&amp;mut T&gt;"></a>2.4.5. 栈上钉住 Pin&lt;&amp;mut T&gt;</h4><h4 id="2-4-6-钉住操作和-Futures"><a href="#2-4-6-钉住操作和-Futures" class="headerlink" title="2.4.6. 钉住操作和 Futures"></a>2.4.6. 钉住操作和 Futures</h4><h3 id="2-5-执行器和唤醒器"><a href="#2-5-执行器和唤醒器" class="headerlink" title="2.5. 执行器和唤醒器"></a>2.5. 执行器和唤醒器</h3><p>使用 async&#x2F;await，我们可以使用完全异步的方式使用futures。然而futures在被轮询之前不会做任何事。这意味着我们必须在某个时刻调用<code>poll</code>，否则异步代码永远不会执行。</p><p>使用单独的future，我们可以手动循环等待每个future。然而，这种方法非常低效，对于大量future的程序来说并不实用。这个问题的常见解决方案是定义一个全局的执行器，它负责轮询系统中的所有的future直到它们完成。</p><h4 id="2-5-1-执行器Executors"><a href="#2-5-1-执行器Executors" class="headerlink" title="2.5.1. 执行器Executors"></a>2.5.1. 执行器Executors</h4><p>执行器的目的是允许future作为独立任务进行生成，通过<code>spawn</code>方法。然后执行器负责轮询所有的future直到它们完成。管理所有future的一个重要优势是，当future返回<code>Poll::Pending</code>时，执行器可以切换到另一个future。因此，异步操作是并行运行的，并且CPU保存忙碌。</p><p>许多执行器的实现可以利用多个CPU核心的系统。它们创建了一个线程池thread pool，如果有足够的空间可以用，它可以利用所有核心，利用工作窃取之类的技术来平衡核心之间的负载。还有一些针对嵌入式系统的特色执行器实现，优化来低延迟和内存开销。</p><p>为了避免重复轮询future的开销，执行器通常是利用Rust的futures支持的唤醒器 <em>waker API</em>。</p><h4 id="2-5-2-唤醒器-Wakers"><a href="#2-5-2-唤醒器-Wakers" class="headerlink" title="2.5.2. 唤醒器 Wakers"></a>2.5.2. 唤醒器 Wakers</h4><p>唤醒器的想法是，一个特殊的<code>Waker</code>类型被传递给每一个<code>poll</code>调用，它被包装在<code>Context</code>类型中。这个<code>Waker</code>类型是由执行器创建的，可以被异步任务来通知它的完成。因此，执行器不需要在之前返回<code>Poll::Pending</code>的future上调用<code>poll</code>，直到它被相应的唤醒器通知。</p><p>这通过一个例子说明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_file</span>() &#123;<br>    <span class="hljs-title function_ invoke__">async_write_file</span>(<span class="hljs-string">&quot;foo.txxt&quot;</span>,<span class="hljs-string">&quot;Hello&quot;</span>).<span class="hljs-keyword">await</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数异步的将字符串“Hello”写入到“foo.txt”文件中。由于硬盘写入需要时间，这个future到第一次<code>poll</code>调用可能会返回<code>Poll::Pending</code>。然而，硬盘驱动程序将内部存储传递给<code>poll</code>调用的<code>Waker</code>，并在文件写入到硬盘时使用它来通知执行器。这样，执行器在收到唤醒器通知之前不需要浪费任何时间尝试再次<code>poll</code>这个future。</p><h3 id="2-6-协作式多任务？"><a href="#2-6-协作式多任务？" class="headerlink" title="2.6. 协作式多任务？"></a>2.6. 协作式多任务？</h3><p>抢占式多任务依赖操作系统强制在运行任务之间切换，但协作式多任务要求任务定期通过<code>yield</code>操作自愿放弃CPU控制。协作式方法的一个巨大优势就是任务可以自己保存他们的状态，这导致更有效的上下文切换，并且使得可以在任务之间共享相同的调用栈。</p><p>这可能不是显而易见，但futures和async&#x2F;await是协作式多任务模式的一组体现：</p><ul><li>每个添加到执行器的future基本上是一个协作式任务</li><li>不同于显示使用yield操作，futures通过返回<code>Poll::Pending</code>来放弃CPU控制（或者在结束时返回<code>Poll::Ready</code>）<ul><li>没有任何东西强制futures放弃CPU控制。如果他们想要，他们可以永远不从<code>poll</code>返回，例如通过在循环中无休止的旋转</li><li>由于每个future都可以阻塞执行器中的其他future的执行，我们需要相信他们不是恶意的。</li></ul></li><li>Future内部存储来所有他们需要的状态，以便在下一次<code>poll</code>调用时继续执行。使用async&#x2F;await，编译器自动检测所有需要的变量并将他们存储在生成的状态中。<ul><li>只保存了继续执行所需的最小状态</li><li>由于<code>poll</code>方法在返回时放弃了调用栈；他们只是使用了一些不同的术语。在接下来的内容中，任务和future两个术语混用。</li></ul></li></ul><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><p><code>Future</code>trait是<code>core</code>库的一部分，而<code>async/await</code>是语言本身的一个特性，所以在<code>#![no_std]</code>内核中使用它时不需要做任何特殊的事情。</p><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">async_number</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-number">42</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example_task</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-title function_ invoke__">async_number</span>().<span class="hljs-keyword">await</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;async number: &#123;&#125;&quot;</span>, number);<br>&#125;<br></code></pre></td></tr></table></figure><p>函数<code>async_number</code>是一个<code>async fn</code>，所以编译器将它转换为一个实现了<code>Future</code>的状态机。由于函数只返回42，所以生成的future将在第一次<code>poll</code>调用时直接返回<code>Poll::Ready(42)</code>。像<code>async_number</code>一样，<code>example_task</code>函数也是一个<code>async fn</code>。它等待<code>async_number</code>返回的数字，然后打印出来。</p><p>为运行<code>example_task</code>返回future，我们需要在它上调用<code>poll</code>直到它通过返回<code>Poll::Ready</code>来标志它的完成。为了做到这一点，需要一个执行器类型。</p><h3 id="3-1-任务Task"><a href="#3-1-任务Task" class="headerlink" title="3.1. 任务Task"></a>3.1. 任务Task</h3><p>执行器之前需要一个<code>task</code>模块，里面包含一个<code>Task</code>类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> task;<br><br><span class="hljs-keyword">use</span> core::&#123;future::Future, pin::Pin&#125;;<br><span class="hljs-keyword">use</span> alloc::boxed::<span class="hljs-type">Box</span>;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> &#123;<br>    future: Pin&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Future&lt;Output = ()&gt;&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Task</code>结构体上一个对堆分配的、钉住的、动态分发的future的新型包装，它的输出类型是()</p><ul><li>我们要求任务关联的future返回<code>()</code>。这意味着任务不返回任何结果，他们只是执行他们的副作用。例如，我们在上面定义的<code>example_task</code>函数没有返回值，但它作为副作用打印来一些东西在屏幕上。</li><li>关键字<code>dyn</code>表示我们在<code>Box</code>中存储来一个trait object。这意味着future上的方法是动态分发的，允许不同类型的future存储在<code>Task</code>类型中。这很重要，因为每个<code>async fn</code>都有自己的类型，我们希望能够创建多个不同的任务。</li><li>Pin<Box>类型通过将值放在堆上并防止创建堆它的<code>&amp;mut</code>引用来确保在内存中不会被移动。这很重要，因为由async&#x2F;await生成的future可能是自引用的，即包含自己的指针，当future被移动时这些指针失效。<br>为允许从future创建新的<code>Task</code>，我们创建一个<code>new</code>函数。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// in src/task/mod.rs</span><br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(future: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = ()&gt; + <span class="hljs-symbol">&#x27;static</span>) <span class="hljs-punctuation">-&gt;</span> Task &#123;<br>        Task &#123;<br>            future: <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">pin</span>(future),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数带有一个任意的future，它的输出类型是<code>()</code>，并通过<code>Box::pin</code>函数在内存中钉住它。然后它将被包装的future放到<code>Task</code>结构体中并返回它。这里需要<code>‘static</code>生命周期，因为返回的<code>Task</code>可以存活在任意时间，所以future也需要在那个时间内有效。</p><p>增加里一个<code>poll</code>方法，允许执行器轮询持有的future：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// in src/task/mod.rs</span><br><br><span class="hljs-keyword">use</span> core::task::&#123;Context, Poll&#125;;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, context: &amp;<span class="hljs-keyword">mut</span> Context) <span class="hljs-punctuation">-&gt;</span> Poll&lt;()&gt; &#123;<br>        <span class="hljs-keyword">self</span>.future.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">poll</span>(context)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于<code>Future</code>trait的<code>poll</code>方法期望在<code>Pin&lt;&amp;mut T&gt;</code>类型上调用，我们首先使用<code>Pin::as_mut</code>方法<code>self.future</code>字段从<code>Pin&lt;Box&lt;T&gt;&gt;</code>类型转换为<code>Pin&lt;&amp;mut T&gt;</code>类型。然后我们在转换后的<code>self.future</code>字段上调用<code>poll</code>，并返回结果。由于<code>Task::poll</code>方法只应该由我们即将创建的执行器调用，我们将函数保持为<code>task</code>私有。</p><h3 id="3-2-简单的执行器"><a href="#3-2-简单的执行器" class="headerlink" title="3.2. 简单的执行器"></a>3.2. 简单的执行器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> simple_executor;<br><br><span class="hljs-keyword">use</span> super::Task;<br><span class="hljs-keyword">use</span> alloc::collections::VecDeque;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SimpleExecutor</span> &#123;<br>  task_queue: VecDeque&lt;Task&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SimpleExecutor</span> &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> SimpleExecutor &#123;<br>    SimpleExecutor &#123;<br>      task_queue: VecDeque::<span class="hljs-title function_ invoke__">new</span>(),<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">spawn</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, task: Task) &#123;<br>    <span class="hljs-keyword">self</span>.task_queue.<span class="hljs-title function_ invoke__">push_back</span>(task)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这结构体包含<code>task_queue</code>字段，类型是<code>VecDeque</code>，它基本上是一个允许在两端进行推送和弹出操作的向量。使用这种，我们可以通过<code>spawn</code>方法在末尾插入新的任务，并从前面弹出下一个任务进行执行，这样就有了一个简单的<code>FIFO queue</code>。</p><h4 id="3-2-1-摆设型唤醒器Dummy-Waker"><a href="#3-2-1-摆设型唤醒器Dummy-Waker" class="headerlink" title="3.2.1. 摆设型唤醒器Dummy Waker"></a>3.2.1. 摆设型唤醒器Dummy Waker</h4><p>为了调用<code>poll</code>方法，我们需要创建一个<code>Context</code>类型，它包装了一个<code>Waker</code>类型。为了简单起见，我们首先创建一个什么都不做的fake Waker。为此，我们创建了一个<code>RawWaker</code>实例，它定义了<code>Waker</code>的各种方法都实现，然后使用<code>Waker::from_raw</code>函数将它转换为<code>Waker</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::task::&#123;Waker, RawWaker&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dummy_raw_waker</span>() <span class="hljs-punctuation">-&gt;</span> RawWaker &#123;<br>    todo!();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dummy_waker</span>() <span class="hljs-punctuation">-&gt;</span> Waker &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123; Waker::<span class="hljs-title function_ invoke__">from_raw</span>(<span class="hljs-title function_ invoke__">dummy_raw_waker</span>()) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先理解一下<code>RawWaker</code>类型的工作原理</p><ul><li>RawWaker<br>类型<code>RawWaker</code>要求程序员定义一个虚拟方法表，它指定了在<code>RawWaker</code>被克隆、唤醒或丢弃时应该调用的函数。这个vtable的布局由<code>RawWakerVTable</code>类型定义。每个函数接收一个<code>*const()</code>参数，这是一个对某个值type-erased指针。使用<code>*const()</code>指针而不是正确的引用的原因是，<code>RawWaker</code>类型应该是非范型的，但仍支持任意类型。通过将它放入<code>RawWaker::new</code>的<code>data</code>参数中提供，这个函数只初始化了一个<code>RawWaker</code>。然后<code>Waker</code>使用这个<code>RawWaker</code>来使用<code>data</code>调用这个vtable函数。</li></ul><p>通常，<code>RawWaker</code>是为一些堆分配的结构体创建的，它被包装到<code>Box</code>或<code>Arc</code>类型中。对于这样的类型可以使用<code>Box::into_raw</code>这样的方法将<code>Box&lt;T&gt;</code>转换为<code>*const T</code>指针。然后可以将这个指针转换为匿名的<code>*const()</code>指针并传递给<code>RawWaker::new</code>。由于每个vtable函数都接收相同的<code>*const()</code>作为参数，所以函数可以安全的将指针转换会<code>Box&lt;T&gt;</code>或<code>&amp;T</code>来操作它。正如你所预料的，这个过程非常危险，并且很容易在出错时导致未定义的行为。因此不建议手动创建<code>RawWaker</code>。</p><ul><li>摆设型RawWaker</li></ul><p>手工创建不被推荐可以使用以下相对安全的方式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::task::RawWakerVTable;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dummy_raw_waker</span>() <span class="hljs-punctuation">-&gt;</span> RawWaker &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">no_op</span>(_: *<span class="hljs-title function_ invoke__">const</span> ()) &#123;&#125;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone</span>(_: *<span class="hljs-title function_ invoke__">const</span> ()) <span class="hljs-punctuation">-&gt;</span> RawWaker &#123;<br>    <span class="hljs-title function_ invoke__">dummy_raw_waker</span>()<br>  &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">vtable</span> = &amp;RawWakerVTable::<span class="hljs-title function_ invoke__">new</span>(clone, no_op, no_op, no_op);<br>    RawWaker::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> *<span class="hljs-title function_ invoke__">const</span> (), vtable)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里定义了两个函数<code>no_op</code>和<code>clone</code>。<code>no_op</code>函数接收一个<code>*const()</code>指针并且什么都不做。<code>clone</code>函数也接收一个<code>*const()</code>指针并且通过再次调用<code>dummy_raw_waker</code>返回一个新的<code>RawWaker</code>。我们使用这两个函数来创建一个最小的<code>RawWakerVTable: clone</code>函数用于克隆操作，<code>no_op</code>函数用于所有其他操作。由于<code>RawWaker</code>什么都不做，所以我们从<code>clone</code>返回一个新的&#96;&#96;RawWaker而不是克隆它。</p><p>创建<code>vtable</code>后，我们使用<code>RawWaker::new</code>函数创建<code>RawWaker</code>。传递的<code>*const()</code>没有关系，因为vtable函数都不使用它。因此，我们只传递了一个空指针。</p><ul><li>run方法<br>现在有了<code>Waker</code>实例的方法，我们可以使用它来在执行器上实现一个<code>run</code>方法。最简单的<code>run</code>方法是重复的在循环中轮询所有排队的任务，直到他们完成。这并不高效啊，因为它没有利用<code>Waker</code>类型的通知，但这是一个让执行器运行起来的方法：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::task::&#123;Context, Poll&#125;;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SimpleExecutor</span> &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">mut</span> task) = <span class="hljs-keyword">self</span>.task_queue.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-variable">waker</span> = <span class="hljs-title function_ invoke__">dummy_waker</span>();<br>      <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">context</span> = Context::<span class="hljs-title function_ invoke__">from_waker</span>(&amp;waker);<br>      <span class="hljs-keyword">match</span> task.<span class="hljs-title function_ invoke__">poll</span>(&amp;<span class="hljs-keyword">mut</span> context) &#123;<br>        Poll::<span class="hljs-title function_ invoke__">Ready</span>(()) =&gt; &#123;&#125; <span class="hljs-comment">// task done</span><br>        Poll::Pending =&gt; <span class="hljs-keyword">self</span>.task_queue.<span class="hljs-title function_ invoke__">push_back</span>(task),<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数使用<code>while let</code>循环来处理<code>task_queue</code>中所有的任务。对于每个任务，它首先通过包装<code>dummy_waker</code>函数返回的<code>Waker</code>实例来创建一个<code>Context</code>类型。然后它使用这个<code>context</code>调用<code>Task::poll</code>方法。如果<code>poll</code>方法返回<code>Poll::Ready</code>,则任务已完成，我们可以继续下一个任务。如果任务仍然是<code>Poll::Pending</code>，我们将它再次添加到队列末尾，这样它将在后续的循环迭代中再次被轮询。</p><ul><li>尝试</li></ul><p>我们有了<code>SimpleExecutor</code>类型，现在可以尝试运行任务。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// in src/main.rs</span><br><br><span class="hljs-keyword">use</span> blog_os::task::&#123;Task, simple_executor::SimpleExecutor&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">kernel_main</span>(boot_info: &amp;<span class="hljs-symbol">&#x27;static</span> BootInfo) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-comment">// […] initialization routines, including `init_heap`</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">executor</span> = SimpleExecutor::<span class="hljs-title function_ invoke__">new</span>();<br>    executor.<span class="hljs-title function_ invoke__">spawn</span>(Task::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">example_task</span>()));<br>    executor.<span class="hljs-title function_ invoke__">run</span>();<br><br>    <span class="hljs-comment">// […] test_main, &quot;it did not crash&quot; message, hlt_loop</span><br>&#125;<br><br><br><span class="hljs-comment">// Below is the example_task function again so that you don&#x27;t have to scroll up</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">async_number</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-number">42</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example_task</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-title function_ invoke__">async_number</span>().<span class="hljs-keyword">await</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;async number: &#123;&#125;&quot;</span>, number);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先，创建了一个新的<code>SimpleExecutor</code>类型的实例，它的<code>task_queue</code>是空的。</li><li>其次，我们调用异步<code>example_task</code>函数，它返回一个future。我们将这个future包装在<code>Task</code>类型中，这将它移动到堆上并钉住它，然后通过<code>spawn</code>方法将任务添加到执行器的<code>task_queue中</code>。</li><li>我们然后通过调用<code>run</code>方法来开始执行队列中的单个任务。包括<ul><li>从<code>task_queue</code>的前端弹出任务。</li><li>为任务创建一个<code>RawWaker</code>，将它转换为<code>Waker</code>实例，然后从中创建一个<code>Context</code>实例。</li><li>使用我们刚刚创建的<code>Context</code>调用任务的future的<code>poll</code>方法。</li><li>因为<code>example_task</code>不等待任何东西，它可以在第一次<code>poll</code>调用时直接运行到结束。这就是“async numbe”被打印的地方。</li><li>因为<code>example_task</code>直接返回<code>Poll::Ready</code>，它不会再次添加到任务队列中。</li></ul></li><li>方法<code>run</code>在<code>task_queue</code>变为空后返回。我们的<code>kernel_main</code>函数继续执行，并打印“It did not crash！”消息。</li></ul><h3 id="3-3-异步键盘输入"><a href="#3-3-异步键盘输入" class="headerlink" title="3.3. 异步键盘输入"></a>3.3. 异步键盘输入</h3><h3 id="3-4-带唤醒器支持的执行器"><a href="#3-4-带唤醒器支持的执行器" class="headerlink" title="3.4. 带唤醒器支持的执行器"></a>3.4. 带唤醒器支持的执行器</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RUST宏</title>
    <link href="/2025/06/15/RUST%E9%97%B2%E8%B0%88%E6%9D%82%E8%AE%B0/RUST%E5%AE%8F/"/>
    <url>/2025/06/15/RUST%E9%97%B2%E8%B0%88%E6%9D%82%E8%AE%B0/RUST%E5%AE%8F/</url>
    
    <content type="html"><![CDATA[<p>在 Rust 中宏分为两大类：</p><ul><li>声明式宏( declarative macros ) macro_rules! </li><li>和三种过程宏( procedural macros ):<ul><li>#[derive]，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 Debug 特征</li><li>类属性宏(Attribute-like macro)，用于为目标添加自定义的属性</li><li>类函数宏(Function-like macro)，看上去就像是函数调用</li></ul></li></ul><h2 id="1-宏和函数的区别"><a href="#1-宏和函数的区别" class="headerlink" title="1. 宏和函数的区别"></a>1. 宏和函数的区别</h2><h3 id="1-1-元编程"><a href="#1-1-元编程" class="headerlink" title="1.1. 元编程"></a>1.1. 元编程</h3><p>元编程（Metaprogramming）是编写能够读取、生成、修改或操作其他程序（包括自身）的程序的技术。简单来说，元编程就是“写代码来写代码” 。<br>宏也是通过一种代码生成另一种代码， 元编程可以帮我们减少所需编写的代码，也可以一定程度上减少维护的成本，虽然函数复用也有类似的作用，但是宏依然拥有自己独特的优势。</p><h3 id="1-2-可变参数"><a href="#1-2-可变参数" class="headerlink" title="1.2.可变参数"></a>1.2.可变参数</h3><p>宏可以拥有可变数量的参数，例如可以调用一个参数的 <code>println!(&quot;hello&quot;)</code>，也可以调用两个参数的 <code>println!(&quot;hello &#123;&#125;&quot;, name)</code>。</p><h3 id="1-3-宏展开"><a href="#1-3-宏展开" class="headerlink" title="1.3.宏展开"></a>1.3.宏展开</h3><p>宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。</p><h3 id="1-4-宏的缺点"><a href="#1-4-宏的缺点" class="headerlink" title="1.4. 宏的缺点"></a>1.4. 宏的缺点</h3><p>宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。</p><h2 id="2-声明式宏-macro-rules"><a href="#2-声明式宏-macro-rules" class="headerlink" title="2. 声明式宏 macro_rules!"></a>2. 声明式宏 macro_rules!</h2><p><strong>也称示例宏</strong><br>声明式宏允许我们写出类似 match 的代码。其接收一个表达式，然后将表达式的结果与多个模式进行匹配。<br><strong>宏也是将一个值跟对应的模式进行匹配，且该模式会与特定的代码相关联。</strong></p><p>与 match 不同的是，宏里的值是一段 Rust 源代码(字面量)。模式用于跟这段源代码的结构相比较，一旦匹配，传入宏的那段源代码将被模式关联的代码所替换，最终实现宏展开。<strong>所有的这些都是在编译期发生，并没有运行期的性能损耗。</strong></p><p>例如：使用vec!初始化一个动态数组</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><span class="hljs-built_in">macro_rules!</span> vec &#123;    ( $( $x:expr ),* ) =&gt; &#123;        &#123;            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">temp_vec</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();            $(                temp_vec.<span class="hljs-title function_ invoke__">push</span>($x);            )*            temp_vec        &#125;    &#125;;&#125;</code></pre></div><ul><li>#[macro_export]：宏导出，其他的包可以将宏引入到当前作用域</li><li>( $( $x:expr ),* )：模式解析，关联代码在&#x3D;&gt;之后，一旦成功匹配就会替换传入的代码<ul><li>( … )：包含整个宏模式</li><li>$( … )：括号中匹配的代码会被捕获，用于替换</li><li>$x:expr：会匹配任何匹配表达式并命名为：$x</li><li>$( … ),：逗号说明 $() 所匹配的代码使用逗号分隔</li><li>$( … ),*：*说明 *之前的模式会被匹配0或任意多次</li></ul></li></ul><p>更多关于元变量可以查看<a href="https://rustwiki.org/zh-CN/reference/macros-by-example.html">RUST参考手册</a><br>Rust 计划在未来使用新的声明式宏来替换它，关于声明宏更细致的可以查看<a href="https://zjp-cn.github.io/tlborm/introduction.html">RUST宏小册</a></p><h2 id="3-过程宏"><a href="#3-过程宏" class="headerlink" title="3. 过程宏"></a>3. 过程宏</h2><p>过程宏和函数较为相像，过程宏是使用源代码作为输入参数，经过操作后输出全新的代码。</p><p>过程宏允许在执行函数时创建句法扩展，过程宏有三种形式</p><ul><li>函数式宏：实现 <code>$name！</code>,<code>$input</code> 功能的宏</li><li>派生宏：derive式，自定义derive</li><li>属性式宏：实现 #[$input] 功能的属性</li></ul><p>过程宏允许在编译时运行对Rust句法进行操作的代码，它可以在消耗掉一些Rust句法输入的同时产生新的Rust句法输出。</p><p>过程宏必须在 crate 类型为 proc-macro 的 crate 中定义。<br>定义过程宏的 crate 的配置文件里要使用 proc-macro键做如下设置：</p><div class="code-wrapper"><pre><code class="hljs rust">[lib]proc-<span class="hljs-keyword">macro</span> = <span class="hljs-literal">true</span></code></pre></div><p>过程宏是非卫生的，需要在库中程序项使用绝对路径</p><h3 id="3-1-函数宏"><a href="#3-1-函数宏" class="headerlink" title="3.1 函数宏"></a>3.1 函数宏</h3><p>类函数过程宏是使用宏调用运算符（!）调用的过程宏。</p><p>这种宏是由一个带有 <code>proc_macro</code>属性和 <code>(TokenStream) -&gt; TokenStream</code>签名的 公有可见性函数定义。输入 <code>TokenStream</code> 是由宏调用的定界符界定的内容，输出 <code>TokenStream</code> 将替换整个宏调用。</p><p>类函数宏可以让我们定义像函数那样调用的宏，从这个角度来看，它跟声明宏 macro_rules 较为类似。</p><p>类函数过程宏可以在任何宏调用位置调用，这些位置包括语句、表达式、模式、类型表达式、程序项可以出现的位置</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[proc_macro]</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">name</span>(input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;  TokenStream::<span class="hljs-title function_ invoke__">new</span>()&#125;</code></pre></div><h3 id="3-2-属性宏"><a href="#3-2-属性宏" class="headerlink" title="3.2 属性宏"></a>3.2 属性宏</h3><p>属性宏定义可以附加到程序项上的新的外部属性，这些程序项包括外部(extern)块、固有实现、trate实现，以及 trait声明中的各类程序项。</p><p>属性宏由带有<code>proc_macro_attribute</code>属性和 <code>(TokenStream, TokenStream) -&gt; TokenStream</code>签名的公有可见性函数定义。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[proc_macro_attribute]</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">name</span>(attr: TokenStream, input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;    TokenStream::<span class="hljs-title function_ invoke__">new</span>()&#125;</code></pre></div><p>签名中的第一个 TokenStream 是属性名称后面的定界 token树(delimited token tree)（不包括外层定界符）。如果该属性作为裸属性(bare attribute)给出，则第一个 TokenStream 值为空。第二个 TokenStream 是程序项的其余部分，包括该程序项的其他属性。</p><p>使用举例</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[route(GET, <span class="hljs-string">&quot;/&quot;</span>)]</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">index</span>() &#123;</code></pre></div><p>对应宏</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[proc_macro_attribute]</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">route</span>(attr: TokenStream, item: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;</code></pre></div><ul><li>第一个参数时用于说明属性包含的内容：Get, “&#x2F;“ 部分</li><li>第二个是属性所标注的类型项，在这里是 fn index() {…}，注意，函数体也被包含其中</li></ul><p>接受输入流并按原样返回，实际上对属性并无操作例子</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#![crate_type = <span class="hljs-string">&quot;proc-macro&quot;</span>]</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> proc_macro;<span class="hljs-keyword">use</span> proc_macro::TokenStream;<span class="hljs-meta">#[proc_macro_attribute]</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_as_is</span>(_attr: TokenStream, item: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;    item&#125;</code></pre></div><p>下面属性宏看到的字符串化的 <code>TokenStream</code>。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// my-macro/src/lib.rs</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> proc_macro;<span class="hljs-keyword">use</span> proc_macro::TokenStream;<span class="hljs-meta">#[proc_macro_attribute]</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show_streams</span>(attr: TokenStream, item: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;attr: \&quot;&#123;&#125;\&quot;&quot;</span>, attr.<span class="hljs-title function_ invoke__">to_string</span>());    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;item: \&quot;&#123;&#125;\&quot;&quot;</span>, item.<span class="hljs-title function_ invoke__">to_string</span>());    item&#125;</code></pre></div><p>使用和输出</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// src/lib.rs</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> my_macro;<span class="hljs-keyword">use</span> my_macro::show_streams;<span class="hljs-comment">// 示例: 基础函数</span><span class="hljs-meta">#[show_streams]</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">invoke1</span>() &#123;&#125;<span class="hljs-comment">// out: attr: &quot;&quot;</span><span class="hljs-comment">// out: item: &quot;fn invoke1() &#123; &#125;&quot;</span><span class="hljs-comment">// 示例: 带输入参数的属性</span><span class="hljs-meta">#[show_streams(bar)]</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">invoke2</span>() &#123;&#125;<span class="hljs-comment">// out: attr: &quot;bar&quot;</span><span class="hljs-comment">// out: item: &quot;fn invoke2() &#123;&#125;&quot;</span><span class="hljs-comment">// 示例: 输入参数中有多个 token 的</span><span class="hljs-meta">#[show_streams(multiple =&gt; tokens)]</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">invoke3</span>() &#123;&#125;<span class="hljs-comment">// out: attr: &quot;multiple =&gt; tokens&quot;</span><span class="hljs-comment">// out: item: &quot;fn invoke3() &#123;&#125;&quot;</span><span class="hljs-comment">// 示例:</span><span class="hljs-meta">#[show_streams &#123; delimiters &#125;]</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">invoke4</span>() &#123;&#125;<span class="hljs-comment">// out: attr: &quot;delimiters&quot;</span><span class="hljs-comment">// out: item: &quot;fn invoke3() &#123;&#125;&quot;</span></code></pre></div><h3 id="3-3-派生宏"><a href="#3-3-派生宏" class="headerlink" title="3.3 派生宏"></a>3.3 派生宏</h3><p>派生宏为derive属性定义新输入，这类宏在给定输入结构体（struct）、枚举（enum）或联合体（union）token流的情况下创建新的程序项，可以定义派生宏辅助属性。</p><p>函数定义如下</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[proc_macro_derive(Name)]</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">my_derive</span>(input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;    TokenStream::<span class="hljs-title function_ invoke__">new</span>()&#125;</code></pre></div><ul><li>输入<code>TokenStream</code>是带有derive属性的程序项token流，输出<code>TokenStream</code>必须是一组程序项，然后将这组程序项追加到输入<code>TokenStream</code>中的那条程序项所在的模块或块中。</li></ul><p>一个例子</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> proc_macro;<span class="hljs-keyword">use</span> proc_macro::TokenStream;<span class="hljs-meta">#[proc_macro_derive(AnswerFn)]</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">derive_answer_fn</span>(_item: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;  <span class="hljs-string">&quot;fn answer() -&gt; u32 &#123; 42 &#125;&quot;</span>.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>()&#125;</code></pre></div><p>之后使用这个派生宏</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> proc_macro_examples;<span class="hljs-keyword">use</span> proc_macro_examples::AnswerFn;<span class="hljs-meta">#[derive(AnswerFn)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Struct</span>;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">42</span>, <span class="hljs-title function_ invoke__">answer</span>());&#125;</code></pre></div><p>目前只能在单独的包中定义过程宏，宏所在的包名自然也有要求，必须以 derive 为后缀</p><p>定义过程要使用到<code>syn</code></p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> proc_macro;<span class="hljs-keyword">use</span> proc_macro::TokenStream;<span class="hljs-keyword">use</span> quote::quote;<span class="hljs-keyword">use</span> syn;<span class="hljs-keyword">use</span> syn::DeriveInput;<span class="hljs-meta">#[proc_macro_derive(HelloMacro)]</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_macro_derive</span>(input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;    <span class="hljs-comment">// 基于 input 构建 AST 语法树</span>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ast</span>:DeriveInput = syn::<span class="hljs-title function_ invoke__">parse</span>(input).<span class="hljs-title function_ invoke__">unwrap</span>();    <span class="hljs-comment">// 构建特征实现代码</span>    <span class="hljs-title function_ invoke__">impl_hello_macro</span>(&amp;ast)&#125;</code></pre></div><p>syn将字符串形式的代码解析为一个AST树的数据结构，该结构可以在之后的函数中进行操作，最后操作结果会被quote包转换回Rust代码。</p><p>一个结构体由以下部分组成</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// vis，可视范围         ident，标识符   generic,范型     fields:结构体的字段</span><span class="hljs-keyword">pub</span>             <span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>           &lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;         &#123;    <span class="hljs-comment">// vis   ident    type</span>    <span class="hljs-keyword">pub</span>       name:   &amp;<span class="hljs-symbol">&#x27;a</span> T,&#125;</code></pre></div><p>syn::parse 调用会返回一个 DeriveInput 结构体来代表解析后的 Rust 代码:</p><div class="code-wrapper"><pre><code class="hljs rust">DeriveInput &#123;    <span class="hljs-comment">// --snip--</span>    vis: Visibility,    ident: Ident &#123;        ident: <span class="hljs-string">&quot;Sunfei&quot;</span>,        span: #<span class="hljs-number">0</span> <span class="hljs-title function_ invoke__">bytes</span>(<span class="hljs-number">95</span>..<span class="hljs-number">103</span>)    &#125;,    generics: Generics,    <span class="hljs-comment">// Data是一个枚举，分别是DataStruct，DataEnum，DataUnion，这里以 DataStruct 为例</span>    data: <span class="hljs-title function_ invoke__">Data</span>(        DataStruct &#123;            struct_token: Struct,            fields: Fields,            semi_token: <span class="hljs-title function_ invoke__">Some</span>(                Semi            )        &#125;    )&#125;</code></pre></div><ul><li>fields: Fields 是一个枚举类型，Fields::Named, Fields::Unnamed, Fields::Unit 分别表示结构体中的显式命名字段（如例子所示），元组或元组变体中的匿名字段(例如Some(T))，单元类型或单元变体字段（例如None ）。 </li><li>ident: “Sunfei” 说明类型名称为 Sunfei， ident 是标识符 identifier 的简写</li></ul><p>下面来看看如何构建特征实现的代码，也是过程宏的核心目标:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">impl_hello_macro</span>(ast: &amp;syn::DeriveInput) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = &amp;ast.ident;    <span class="hljs-keyword">let</span> <span class="hljs-variable">gen</span> = quote! &#123;        <span class="hljs-keyword">impl</span> <span class="hljs-title class_">HelloMacro</span> <span class="hljs-keyword">for</span> #name &#123;            <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_macro</span>() &#123;                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, Macro! My name is &#123;&#125;!&quot;</span>, <span class="hljs-built_in">stringify!</span>(#name));            &#125;        &#125;    &#125;;    gen.<span class="hljs-title function_ invoke__">into</span>()&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RUST数据结构-线性数据结构</title>
    <link href="/2025/04/01/rust%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RUST%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2025/04/01/rust%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RUST%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1 链表"></a>1 链表</h2><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Link</span>&lt;T&gt; = <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&lt;T&gt;&gt;&gt;;<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>&lt;T&gt; &#123;    size: <span class="hljs-type">usize</span>,    head: Link&lt;T&gt;,&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;    elem: T,    next: Link&lt;T&gt;,&#125;<span class="hljs-keyword">impl</span>&lt;T&gt; List&lt;T&gt; &#123;    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> List&lt;T&gt; &#123;        <span class="hljs-keyword">Self</span> &#123;            size: <span class="hljs-number">0</span>,            head: <span class="hljs-literal">None</span>,        &#125;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_empty</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;        <span class="hljs-keyword">self</span>.size == <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">len</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;        <span class="hljs-keyword">self</span>.size    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clear</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">self</span>.size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">self</span>.head = <span class="hljs-literal">None</span>;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, elem: T) &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">node</span> = Node &#123;            elem,            next: <span class="hljs-keyword">self</span>.head.<span class="hljs-title function_ invoke__">take</span>(),        &#125;;        <span class="hljs-keyword">self</span>.head = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(node));        <span class="hljs-keyword">self</span>.size += <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">pop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt; &#123;        <span class="hljs-keyword">self</span>.head.<span class="hljs-title function_ invoke__">take</span>().<span class="hljs-title function_ invoke__">map</span>(|node| &#123;            <span class="hljs-keyword">self</span>.head = node.next;            <span class="hljs-keyword">self</span>.size -= <span class="hljs-number">1</span>;            node.elem        &#125;)    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">peek</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;T&gt; &#123;        <span class="hljs-keyword">self</span>.head.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">map</span>(|node| &amp;node.elem)    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">peek_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> T&gt; &#123;        <span class="hljs-keyword">self</span>.head.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">map</span>(|node| &amp;<span class="hljs-keyword">mut</span> node.elem)    &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>rust数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron_跨平台项目构建</title>
    <link href="/2025/03/10/electron/electron_%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    <url>/2025/03/10/electron/electron_%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>推荐vite + react + electron</p><p>第一步 安装</p><div class="code-wrapper"><pre><code class="hljs sh">npm i electron-vite -D</code></pre></div><p>搭建第一个 electron-vite 项目<br>在命令行中运行以下命令：</p><div class="code-wrapper"><pre><code class="hljs sh">yarn create @quick-start/electron</code></pre></div><p>选择一些选项构建项目</p>]]></content>
    
    
    
    <tags>
      
      <tag>跨平台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC_V体系结构编程与实践</title>
    <link href="/2025/03/09/riscv/RISC_V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/03/09/riscv/RISC_V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="RISC-V体系结构编程与实践"><a href="#RISC-V体系结构编程与实践" class="headerlink" title="RISC-V体系结构编程与实践"></a>RISC-V体系结构编程与实践</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><ul><li><p>执行环境接口(Execution Environment Interface, EEI)：包括程序的初始状态、CPU的类型和数量、支持的S(Supervisor)模式、内存和I&#x2F;O区域的可访问性与属性、在每个CPU上执行指令的行为以及任何异常（包括中断、系统调用）的处理等。常见的RISC-V执行环境接口包括Linux应用程序二进制接口(Application Binary Interface, ABI)以及RISC-V管理员二进制接口(Supervisor Binary Interface, SBI)。一个RISC-V执行环境接口可以由纯硬件、纯软件或者软硬件结合实现</p></li><li><p>裸机程序：程序直接通过ABI访问硬件资源</p></li><li><p>操作系统：提供U(User)模式的执行环境并复用到物理处理器线程中，同时提供虚拟内存机制。 它在操作系统与管理员执行环境(Supervisor Execution Environment, SEE)之间提供一层SBI，对所有RISC-V硬件平台中共性的功能做了抽象，为操作系统访问M(Machine)模式的硬件资源提供服务 SBI，对所有RISC-V硬件平台中共性的功能做了抽象，为操作系统访问M(Machine)模式的硬件资源提供服务</p></li><li><p>虚拟化：为客户操作系统提供多个特权模式的执行环境。每个客户操作系统通过SBI访问虚拟化管理程序</p></li></ul><p><img src="/2025/03/09/riscv/RISC_V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/riscv.1.png"></p><ul><li>特权级别(privilege level)包括RISC-V处理器提供的3种模式。<ul><li>机器模式（M模式）：以M模式运行的代码通常在本质上是可信的，因为它具有对机器实现的全部访问权限，常用于管理RISC-V上的安全执行环境。通常在M模式下运行SBI固件，为操作系统提供服务。</li><li>特权模式（S模式）：通常用来运行操作系统的内核，为应用程序提供服务。</li><li>用户模式（U模式）：特权级别最低，通常用来运行应用程序。</li></ul></li><li>使能了虚拟化扩展后，新增如下特权模式。<ul><li>HS模式：把原有的S模式扩展为HS模式，用来运行虚拟化管理程序。</li><li>VS模式：通常用来运行虚拟机操作系统内核。</li><li>VU模式：通常用来运行虚拟机操作系统中的应用程序。<br>所有硬件的实现必须提供M模式，因为这是唯一可以不受限制地访问整个机器的资源。简单的RISC-V系统（如嵌入式系统）只提供M模式</li></ul></li></ul><p><img src="/2025/03/09/riscv/RISC_V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/riscv.2.png"></p><h2 id="1-1-RISC-V寄存器"><a href="#1-1-RISC-V寄存器" class="headerlink" title="1.1 RISC-V寄存器"></a>1.1 RISC-V寄存器</h2><h3 id="1-1-1-通用寄存器"><a href="#1-1-1-通用寄存器" class="headerlink" title="1.1.1 通用寄存器"></a>1.1.1 通用寄存器</h3><p> 64&#x2F;32 位的RISC-V体系结构提供 <strong>32</strong> 个64位&#x2F;32位的整型通用寄存器。<br>分别是 x0 - x31。</p><p>对于浮点数运算，64位的RISC-V体系结构也提供32个浮点数通用寄存器，分别为 f0 - f31。</p><p>每个寄存器都有别名，可以直接使用别名。</p><p><img src="/2025/03/09/riscv/RISC_V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/riscv.3.png"></p><table><thead><tr><th>寄存器</th><th>别名</th><th>作用</th><th>维护者</th></tr></thead><tbody><tr><td>x0</td><td>zero</td><td>寄存器的内容全是0，可以用作源寄存器，也可以用作目标寄存器，读取时总为0，写入时不起任何效果</td><td>N&#x2F;A</td></tr><tr><td>x1</td><td>ra</td><td>链接寄存器，用于保存函数返回地址。（return address）</td><td>Caller</td></tr><tr><td>x2</td><td>sp</td><td>栈指针寄存器，指向栈的地址 （stack pointer）</td><td>Callee</td></tr><tr><td>x3</td><td>gp</td><td>用于链接器松弛优化。</td><td></td></tr><tr><td>x4</td><td>tp</td><td>线程寄存器，通常在操作系统中用于保存指向进程控制块——task_struct数据结构的指针。</td><td></td></tr><tr><td>x5～x7 x28～x31</td><td>t0～t2，t3～t6</td><td>临时寄存器（temporaries），Callee 可能会使用这些寄存器，Callee 不保证这些寄存器中的值在函数调用过程中保持不变，对于Caller来说，如果需要的话，Caller需要自己在调用Callee之前保持临时寄存器中的值</td><td>Caller</td></tr><tr><td>x8～x9 x18～x27</td><td>s0，s1，s2～s11</td><td>保存寄存器 （saved），Callee 需要保证这些寄存器的值在函数返回后仍然维持函数调用之前的原值，所以一旦Callee在自己的函数中会用到这些寄存器则需要在栈中备份并在退出函数时进行恢复</td><td>Callee</td></tr><tr><td>x10,x11</td><td>a0,a1</td><td>参数寄存器（argument）用于在调用函数过程中保存第一个和第二个参数，以及在函数返回时传递返回值和返回结果。</td><td>Caller</td></tr><tr><td>x12～x17</td><td>a2～a7</td><td>参数寄存器（argument）用于在调用函数时需要传递更多的参数，可以用这些寄存器，但注意传递参数的寄存器最多只有8个（a0～a7），如果还有更多的参数则要使用栈。</td><td>Caller</td></tr></tbody></table><p>如果函数调用过程中要使用t0 - t6 s0 - s11寄存器，需要先保存到栈里。另外，s0寄存器可以用作栈帧指针(Frame Pointer, FP)。</p><ul><li>函数调用过程中函数跳转和返回指令的编程约定</li></ul><table><thead><tr><th>伪指令</th><th>等价指令</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>jal offset</td><td>jal x1, offset</td><td>跳转到 offset 指定位置，保存返回地址到x1（ra）</td><td>jal foo</td></tr><tr><td>jalr rs</td><td>jalr x1, 0(rs)</td><td>跳转到 rs 中值所指定的位置，保存返回地址到x1（ra）</td><td>jalr s1</td></tr><tr><td>j offset</td><td>jal x0, offset</td><td>跳转到 offset 指定位置，不保存返回地址</td><td>j loop</td></tr><tr><td>jr rs</td><td>jalr x0, 0(rs)</td><td>跳转到 rs 中所指定的位置，不保存返回地址</td><td>jr s1</td></tr><tr><td>call offset</td><td>auipc x1, offset[31:12] + offset[11];jalr x1, offset<a href="x1">11:0</a></td><td>长跳转调用函数</td><td>call off</td></tr><tr><td>tail offset</td><td>auipc x6, offset[31:12] + offset[11];jalr x0, offset<a href="x6">11:0</a></td><td>长跳转尾调用（最后一次调用，不需要保存返回地址）</td><td>tail foo</td></tr><tr><td>ret</td><td>jalr x0, 0(x1)</td><td>从 Callee 返回</td><td>ret</td></tr></tbody></table><h3 id="1-1-2-系统寄存器"><a href="#1-1-2-系统寄存器" class="headerlink" title="1.1.2 系统寄存器"></a>1.1.2 系统寄存器</h3><p>RISC-V体系结构支持以下3类系统寄存器。</p><ul><li>M模式的系统寄存器。</li><li>S模式的系统寄存器。</li><li>U模式的系统寄存器。</li></ul><p>程序可以通过CSR指令（如CSRRW指令）访问系统寄存器</p><p>CSR指令编码中预留了12位编码空间(csr[11:0])用来索引系统寄存器</p><p><img src="/2025/03/09/riscv/RISC_V%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/riscv.4.png"></p><p>RISC-V体系结构对12位CSR编码空间做了约定。其中，Bit[11:10]用来表示系统寄存器的读写属性，0b11表示只读，其余表示可读可写。Bit[9:8]表示允许访问该系统寄存器的处理器模式，0b00表示U模式，0b01表示S模式，0b10表示HS&#x2F;VS模式，0b11表示M模式。剩余的位用作寄存器的索引。使用CSR地址的最高位对默认的访问权限进行编码，简化了硬件中的错误检查流程，并提供了更大的CSR编码空间，但限制了CSR到地址空间的映射。CSR地址空间映射如表1.3所示。</p><h5 id="1-mhartid"><a href="#1-mhartid" class="headerlink" title="1 mhartid"></a>1 mhartid</h5><ul><li>该 CSR 只读</li><li>包含了运行当前指令的hart的ID</li><li>多个hart的ID必须是唯一的，且必须有一个hart的ID值为0（第一个hart的ID）</li></ul><h4 id="1-1-2-1-S模式下的系统寄存器"><a href="#1-1-2-1-S模式下的系统寄存器" class="headerlink" title="1.1.2.1 S模式下的系统寄存器"></a>1.1.2.1 S模式下的系统寄存器</h4><h5 id="1-sstatus寄存器"><a href="#1-sstatus寄存器" class="headerlink" title="1 sstatus寄存器"></a>1 sstatus寄存器</h5><p>sstatus寄存器表示S模式下的处理器状态</p><h5 id="2-sie寄存器"><a href="#2-sie寄存器" class="headerlink" title="2 sie寄存器"></a>2 sie寄存器</h5><p>sie寄存器用来使能和关闭S模式下的中断。</p><h5 id="3-stvec寄存器"><a href="#3-stvec寄存器" class="headerlink" title="3 stvec寄存器"></a>3 stvec寄存器</h5><p>stvec寄存器用来在S模式下配置异常向量表入口地址和异常访问模式。</p><h5 id="4-satp寄存器"><a href="#4-satp寄存器" class="headerlink" title="4 satp寄存器"></a>4 satp寄存器</h5><p>satp寄存器用于地址转换</p><h4 id="1-1-2-2-M模式下的系统寄存器"><a href="#1-1-2-2-M模式下的系统寄存器" class="headerlink" title="1.1.2.2 M模式下的系统寄存器"></a>1.1.2.2 M模式下的系统寄存器</h4><h5 id="1-mepc寄存器"><a href="#1-mepc寄存器" class="headerlink" title="1 mepc寄存器"></a>1 mepc寄存器</h5><p>当处理器陷入M模式时，会将中断或遇到异常的指令的虚拟地址写入mepc寄存器中</p><h2 id="1-2-指令编码格式"><a href="#1-2-指令编码格式" class="headerlink" title="1.2 指令编码格式"></a>1.2 指令编码格式</h2><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/5.png"></p><p>指令长度： ILEN1 &#x3D; 32bit<br>指令对齐：IALIGN &#x3D; 32bit<br>32个bit划分成不同的域（field）<br>funct3&#x2F;funct7 和 opcode 一起决定最终的指令类型<br>指令在内存中按照小端序排列</p><p>6种指令格式</p><ul><li>R-type（Register），每条指令中有三个 fields，用于指定3个寄存器参数</li><li>I-type（Immediate）立即数指令，每条指令除了带有两个寄存器参数除外，还有一个立即数参数</li><li>S-type（Store）访问内存指令，</li><li>B-type（Branch）</li><li>U-type（Upper）</li><li>J-type（Jump）</li></ul><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/6.png"></p><h3 id="1-2-1-算数运算指令"><a href="#1-2-1-算数运算指令" class="headerlink" title="1.2.1 算数运算指令"></a>1.2.1 算数运算指令</h3><h4 id="1-加法"><a href="#1-加法" class="headerlink" title="1 加法"></a>1 加法</h4><table><thead><tr><th>语法</th><th>ADD RD, RS1, RS2</th><th></th></tr></thead><tbody><tr><td>例子</td><td>add x5, x6, x7</td><td>x5 &#x3D; x6 + x7</td></tr></tbody></table><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.png"></p><ul><li>编码格式： R-type<ul><li>opcode（7）：0110011（OP）</li><li>funct3 取值 000； funct7 取值 0000000</li><li>rs1 (5) 第一个operand</li><li>rs2 (5) 第二个operand</li><li>rd (5)： “destination register” 用于存放求和的结果</li></ul></li></ul><h4 id="2-减法"><a href="#2-减法" class="headerlink" title="2 减法"></a>2 减法</h4><table><thead><tr><th>语法</th><th>SUB RD, RS1, RS2</th><th></th></tr></thead><tbody><tr><td>例子</td><td>sub x5, x6, x7</td><td>x5 &#x3D; x6 - x7</td></tr></tbody></table><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.png"></p><ul><li>编码格式： R-type<ul><li>opcode（7）：0110011（OP）</li><li>funct3 取值 000； funct7 取值 0000000</li><li>rs1 (5) 第一个operand</li><li>rs2 (5) 第二个operand</li><li>rd (5)： “destination register” 用于存放求和的结果</li></ul></li></ul><h4 id="3-立即数加法"><a href="#3-立即数加法" class="headerlink" title="3 立即数加法"></a>3 立即数加法</h4><table><thead><tr><th>语法</th><th>ADDI RD, RS1, IMM</th><th></th></tr></thead><tbody><tr><td>例子</td><td>addi x5, x6, 1</td><td>x5 &#x3D; x6 + 1</td></tr></tbody></table><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/8.png"></p><ul><li>编码格式： I-type<ul><li>opcode（7）：0010011（OP）</li><li>rs1 (5) 第一个operand</li><li>rd (5)： “destination register” 用于存放求和的结果</li><li>imm (12): “immediate”, 立即数占12位，在参与算数运算前该immediate会被“符号扩展”长一个32位的数 可表达范围为：【-2^11,+2^11),[-2048,2047).</li></ul></li></ul><h4 id="4-一些伪指令"><a href="#4-一些伪指令" class="headerlink" title="4 一些伪指令"></a>4 一些伪指令</h4><table><thead><tr><th>伪指令</th><th>语法</th><th>等价指令</th><th>指令描述</th><th>例子</th></tr></thead><tbody><tr><td>NEG</td><td>NEG RD，RS</td><td>SUB RD, x0, RS</td><td>对 RS 中的值取反并将结果存放在RD中</td><td>neg x5，x6</td></tr><tr><td>MV</td><td>MV RD, RS</td><td>ADDI RD, RS, 0</td><td>将 RS 中的值拷贝到 RD 中</td><td>mv x5，x6</td></tr><tr><td>NOP</td><td>NOP</td><td>ADDI x0, x0, 0</td><td>什么也不做</td><td>nop</td></tr></tbody></table><h3 id="1-2-2-加载指令"><a href="#1-2-2-加载指令" class="headerlink" title="1.2.2 加载指令"></a>1.2.2 加载指令</h3><table><thead><tr><th>语法</th><th>LUI RD, IMM</th><th></th></tr></thead><tbody><tr><td>例子</td><td>lui x5, 0x12345</td><td>x5 &#x3D; 0x12345 &lt;&lt; 12</td></tr></tbody></table><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/9.png"></p><ul><li>编码格式： U-type<ul><li>opcode（7）：0110111（OP）</li><li>rd (5)： “destination register” 用于存放求和的结果</li><li>imm (20): “immediate”,立即数 LUI 指令会构造一个32bit的立即数，这个立即数的高20位对应指令中的imm，低12位清零，这个立即数作为结果存放在RD中，</li></ul></li></ul><h4 id="1-加载立即数"><a href="#1-加载立即数" class="headerlink" title="1 加载立即数"></a>1 加载立即数</h4><table><thead><tr><th>语法</th><th>LI RD, IMM</th><th></th></tr></thead><tbody><tr><td>例子</td><td>lui x5, 0x12345678</td><td>x5 &#x3D; 0x12345678</td></tr></tbody></table><ul><li>li 是一个伪指令<ul><li>会根据IMM的实际情况自动生成正确的真实指令。</li></ul></li></ul><h4 id="2-AUIPC"><a href="#2-AUIPC" class="headerlink" title="2 AUIPC"></a>2 AUIPC</h4><table><thead><tr><th>语法</th><th>AUIPC RD, IMM</th><th></th></tr></thead><tbody><tr><td>例子</td><td>auipc x5, 0x12345</td><td>x5 &#x3D; 0x12345 &lt;&lt; 12 + pc</td></tr></tbody></table><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/9.png"></p><ul><li>编码格式： U-type<ul><li>和LUI指令类似，AUIPC指令也会构造一个32 bits 的立即数，这个立即数的高20位对应指令中的 imm， 低 12 位清零。但和 LUI 不同的是，AUIPC 会先将这个立即数和PC值相加，将相加后的结果放在RD中。</li></ul></li></ul><h4 id="3-LA-加载地址"><a href="#3-LA-加载地址" class="headerlink" title="3 LA 加载地址"></a>3 LA 加载地址</h4><table><thead><tr><th>语法</th><th>LA RD, LABEL</th><th></th></tr></thead><tbody><tr><td>例子</td><td>la x5, foo</td><td></td></tr></tbody></table><ul><li><p>LA是一个伪指令</p><ul><li>编程时给出需要加载的label，编译器会根据时间情况利用auipc和其他指令自动生成正确的指令序列</li><li>常用语加载一个函数或者变量的地址。</li></ul></li><li><p>逻辑运算指令</p></li></ul><table><thead><tr><th>指令</th><th>格式</th><th>语法</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>AND</td><td>R-type</td><td>AND RD, RS1, RS2</td><td>RD &#x3D; RS1 &amp; RS2</td><td>and x5, x6, x7</td></tr><tr><td>OR</td><td>R-type</td><td>OR RD, RS1, RS2</td><td>RD &#x3D; RS1 ｜ RS2</td><td>or x5, x6, x7</td></tr><tr><td>XOR</td><td>R-type</td><td>XOR RD, RS1, RS2</td><td>RD &#x3D; RS1 ^ RS2</td><td>xor x5, x6, x7</td></tr><tr><td>ANDI</td><td>I-type</td><td>ANDI RD, RS1, IMM</td><td>RD &#x3D; RS1 &amp; IMM</td><td>andi x5, x6, 20</td></tr><tr><td>ORI</td><td>I-type</td><td>ORI RD, RS1, IMM</td><td>RD &#x3D; RS1 ｜ IMM</td><td>or x5, x6, 20</td></tr><tr><td>XORI</td><td>I-type</td><td>XORI RD, RS1, IMM</td><td>RD &#x3D; RS1 ^ IMM</td><td>xor x5, x6, 20</td></tr></tbody></table><ul><li>所有逻辑指令都是按位操作</li><li>XOR：两个bit值不同（异）则取值为1（达到类似取1为OR的效果）；如果两个bit相同则取值为0.</li></ul><table><thead><tr><th>伪指令</th><th>语法</th><th>等价指令</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>NOT</td><td>NOT RD, RS</td><td>XORI RD, RS, -1</td><td>对RS的值按位取反，结果存在RD中</td><td>not x5, x6</td></tr></tbody></table><h3 id="1-2-3-移位运算指令（逻辑移位）"><a href="#1-2-3-移位运算指令（逻辑移位）" class="headerlink" title="1.2.3 移位运算指令（逻辑移位）"></a>1.2.3 移位运算指令（逻辑移位）</h3><table><thead><tr><th>指令</th><th>格式</th><th>语法</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>SSL</td><td>R-type</td><td>SSL RD, RS1, RS2</td><td>逻辑左移 RD &#x3D; RS1 &lt;&lt; RS2</td><td>sll x5, x6, x7</td></tr><tr><td>SRL</td><td>R-type</td><td>SRL RD, RS1, RS2</td><td>逻辑右移 RD &#x3D; RS1 &gt;&gt; RS2</td><td>srl x5, x6, x7</td></tr><tr><td>SLLI</td><td>I-type</td><td>SLLI RD, RS1, IMM</td><td>逻辑左移立即数 RD &#x3D; RS1 &lt;&lt; IMM</td><td>slli x5, x6, 3</td></tr><tr><td>SRL</td><td>R-type</td><td>SRLI RD, RS1, IMM</td><td>逻辑右移立即数 RD &#x3D; RS1 &gt;&gt; IMM</td><td>srli x5, x6, 3</td></tr></tbody></table><p>无论是逻辑左移还是逻辑右移，补足的都是0</p><h4 id="1-移位运算指令（算数移位）"><a href="#1-移位运算指令（算数移位）" class="headerlink" title="1 移位运算指令（算数移位）"></a>1 移位运算指令（算数移位）</h4><table><thead><tr><th>指令</th><th>格式</th><th>语法</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>SRA</td><td>R-type</td><td>SSL RD, RS1, RS2</td><td>算数右移 RD &#x3D; RS1 &gt;&gt; RS2</td><td>sra x5, x6, x7</td></tr><tr><td>SRAI</td><td>I-type</td><td>SRL RD, RS1, IMM</td><td>算数右移立即数 RD &#x3D; RS1 &gt;&gt; IMM</td><td>srai x5, x6, 3</td></tr></tbody></table><h3 id="1-2-4-内存读写指令"><a href="#1-2-4-内存读写指令" class="headerlink" title="1.2.4 内存读写指令"></a>1.2.4 内存读写指令</h3><h4 id="1-内存读"><a href="#1-内存读" class="headerlink" title="1 内存读"></a>1 内存读</h4><table><thead><tr><th>指令</th><th>格式</th><th>语法</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>LB</td><td>I-type</td><td>LB RD, IMM(RS1)</td><td>Load Byte 从内存中读取一个8 bits 的数据到 RD 内存中，内存地址 &#x3D; RS1 + IMM，数据在保存到RD之前会执行 sign-extended</td><td>lb x5, 40(x6)</td></tr><tr><td>LBU</td><td>I-type</td><td>LBU RD, IMM(RS1)</td><td>Load Byte Unsigned 从内存中读取一个8 bits 的数据到 RD 内存中，内存地址 &#x3D; RS1 + IMM，数据在保存到RD之前会执行 zero-extended</td><td>lbu x5, 40(x6)</td></tr><tr><td>LH</td><td>I-type</td><td>LH RD, IMM(RS1)</td><td>Load HalfWord 从内存中读取一个16 bits 的数据到 RD 内存中，内存地址 &#x3D; RS1 + IMM，数据在保存到RD之前会执行 zero-extended</td><td>lh x5, 40(x6)</td></tr><tr><td>LHU</td><td>I-type</td><td>LHU RD, IMM(RS1)</td><td>Load HalfWord Unsigned 从内存中读取一个16 bits 的数据到 RD 内存中，内存地址 &#x3D; RS1 + IMM，数据在保存到RD之前会执行 zero-extended</td><td>lhu x5, 40(x6)</td></tr><tr><td>LW</td><td>I-type</td><td>LW RD, IMM(RS1)</td><td>Load Word 从内存中读取一个32 bits 的数据到 RD 内存中，内存地址 &#x3D; RS1 + IMM，数据在保存到RD之前会执行 zero-extended</td><td>lw x5, 40(x6)</td></tr></tbody></table><h4 id="2-内存写"><a href="#2-内存写" class="headerlink" title="2 内存写"></a>2 内存写</h4><table><thead><tr><th>指令</th><th>格式</th><th>语法</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>SB</td><td>I-type</td><td>SB RS2, IMM(RS1)</td><td>Store Byte 将RS2寄存器中低8 bits 的数据写出到内存中，内存地址 &#x3D; RS1 + IMM</td><td>sb x5, 40(x6)</td></tr><tr><td>SH</td><td>I-type</td><td>SH RS2, IMM(RS1)</td><td>Store HalfWord 将 RS2 寄存器中低16 bits 的数据写出到内存中，内存地址 &#x3D; RS1 + IMM</td><td>sh x5, 40(x6)</td></tr><tr><td>SW</td><td>I-type</td><td>SW RS2, IMM(RS1)</td><td>Store Word 将RS2寄存器中的32bit 的数据写出到内存中，内存地址 &#x3D; RS1 + IMM</td><td>lw x5, 40(x6)</td></tr></tbody></table><h3 id="1-2-5-条件分支指令"><a href="#1-2-5-条件分支指令" class="headerlink" title="1.2.5 条件分支指令"></a>1.2.5 条件分支指令</h3><table><thead><tr><th>指令</th><th>格式</th><th>语法</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>BEQ</td><td>B-type</td><td>BEQ RS1, RS2, IMM</td><td>Branch if Equal 比较RS1和RS2的值，如果相等，则执行路径跳转到新地址</td><td>beq x5, x6，100</td></tr><tr><td>BNE</td><td>B-type</td><td>BNE RS1, RS2, IMM</td><td>Branch if Not Equal 比较RS1和RS2的值，如果不相等，则执行路径跳转到一个新地址</td><td>bne x5, x6，100</td></tr><tr><td>BLT</td><td>B-type</td><td>BLT RS1，RS2, IMM</td><td>Branch if Less Than 按照有符号的方式比较RS1和RS2的值，如果RS1&lt;RS2，则执行路径跳转到一个新的地址</td><td>blt x5, x6，100</td></tr><tr><td>BLTU</td><td>B-type</td><td>BLTU RS1，RS2, IMM</td><td>Branch if Less Than (Unsigned) 按照无符号的方式比较RS1和RS2的值，如果RS1 &lt; RS2，则执行路径跳转到一个新的地址</td><td>bltu x5, x6，100</td></tr><tr><td>BGE</td><td>B-type</td><td>BGE RS1，RS2, IMM</td><td>Branch if Greater than or Equal 按照有符号的方式比较RS1和RS2的值，如果RS1 &gt;&#x3D; RS2，则执行路径跳转到一个新的地址</td><td>bge x5, x6，100</td></tr><tr><td>BGEU</td><td>B-type</td><td>BGEU RS1，RS2, IMM</td><td>Branch if Greater than or Equal (Unsigned) 按照无符号的方式比较RS1和RS2的值，如果RS1 &gt;&#x3D; RS2，则执行路径跳转到一个新的地址</td><td>bgeu x5, x6，100</td></tr></tbody></table><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/10.png"></p><p>跳转的目标地址计算方法：先将IMM x 2，符号扩展后和PC值相加得到最终的目标地址，所以跳转范围是以 PC 为基准的，+&#x2F;- 4KB 左右（[-4096, 4094]）</p><p>具体编程时，不会直接写IMM，而是用标号代替，交由链接器来最终决定 IMM 的值</p><h4 id="1-条件分支伪指令"><a href="#1-条件分支伪指令" class="headerlink" title="1 条件分支伪指令"></a>1 条件分支伪指令</h4><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/11.png"></p><h3 id="1-2-6-跳转指令"><a href="#1-2-6-跳转指令" class="headerlink" title="1.2.6 跳转指令"></a>1.2.6 跳转指令</h3><h4 id="1-无条件跳转指令"><a href="#1-无条件跳转指令" class="headerlink" title="1 无条件跳转指令"></a>1 无条件跳转指令</h4><table><thead><tr><th>语法</th><th>JAL RD, LABEL</th></tr></thead><tbody><tr><td>例子</td><td>jal x1，label</td></tr></tbody></table><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/12.png"></p><ul><li>JAL 指令使用 J-type 编码格式</li><li>JAL指令用于调用子过程</li><li>子过程地址计算方法：首先对20bits宽的 IMM x 2 后进行 sign-extended，然后将符号扩展后的值和PC的值相加。因此该函数跳转的范围是以 PC 为基准的，上下 +&#x2F;- 1MB</li><li>JAL 指令的下一跳指令的地址写入 RD， 保存为返回地址。</li><li>实际编程时，用label给出的跳转的目标，具体IMM值由编译器和连接器最终负责生成。</li></ul><h4 id="2-JALR-Jump-And-Link-Register"><a href="#2-JALR-Jump-And-Link-Register" class="headerlink" title="2 JALR (Jump And Link Register)"></a>2 JALR (Jump And Link Register)</h4><table><thead><tr><th>语法</th><th>JALR RD, IMM(RS1)</th></tr></thead><tbody><tr><td>例子</td><td>jalr x0，0(x5)</td></tr></tbody></table><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/8.png"></p><ul><li>JALR 指令使用 I-type 编码格式</li><li>JALR指令用于调用子过程</li><li>子过程地址计算方法：首先对12 bits宽的 IMM 进行 sign-extended，然后将符号扩展后的值和 RS1 的值相加。得到最终的结果后将其最低位设置为0 （确保地址按 2 字节对齐）。因此该函数跳转是以 RS1 为基准， 上下 +&#x2F;- 2KB</li><li>JALR 指令的下一跳指令的地址写入 RD， 保存为返回地址。</li></ul><p>跳转后不需要返回，可以用 x0代替 JAL 和 JALR 中的 RD</p><table><thead><tr><th>伪指令</th><th>语法</th><th>等价指令</th><th>例子</th></tr></thead><tbody><tr><td>J</td><td>J OFFSET</td><td>JAL X0, OFFSET</td><td>j leap</td></tr><tr><td>JR</td><td>JR RS</td><td>JALR X0, 0(RS)</td><td>jr x2</td></tr></tbody></table><h3 id="1-2-7-寻址模式"><a href="#1-2-7-寻址模式" class="headerlink" title="1.2.7 寻址模式"></a>1.2.7 寻址模式</h3><table><thead><tr><th>寻址模式</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>立即数寻址</td><td>操作数是指令本身的一部分</td><td>addi x5, x6, 20</td></tr><tr><td>寄存器寻址</td><td>操作数存在寄存器中，指令中指定访问的寄存器从而获取该操作数</td><td>add x5, x6, x7</td></tr><tr><td>基址寻址</td><td>操作数在内存中，指令中通过指定寄存器和立即数（偏移量），通过 base + offset 的方式获得操作数在内存中的地址从而获取该操作数</td><td>sw x5, 40(x6)</td></tr><tr><td>PC相对寻址</td><td>在指令中通过 PC 和指令中的立即数相加获得目标地址的值</td><td>beq x5, x6, 100</td></tr></tbody></table><h3 id="1-2-8-CSR系统指令"><a href="#1-2-8-CSR系统指令" class="headerlink" title="1.2.8 CSR系统指令"></a>1.2.8 CSR系统指令</h3><h4 id="1-CSRRW-Atomic-Read-Write-CSR-读和写-CSR"><a href="#1-CSRRW-Atomic-Read-Write-CSR-读和写-CSR" class="headerlink" title="1 CSRRW (Atomic Read&#x2F;Write CSR) 读和写 CSR"></a>1 CSRRW (Atomic Read&#x2F;Write CSR) 读和写 CSR</h4><table><thead><tr><th>语法</th><th>CSRRW RD, CSR，RS1</th><th></th></tr></thead><tbody><tr><td>例子</td><td>csrrw t6, mscratch, t6</td><td>t6 &#x3D; mscrath; mscrath &#x3D; t6</td></tr></tbody></table><ul><li>CSRRW 先读出 CSR 中的值，将其按 XLEN 位的宽度进行 “零扩展 （zero-extend）” 后写入 RD； 然后将RS1的值写入CSR</li><li>以上两步操作以“原子性（atomically）”方式完成</li><li>如果 RD 是X0，则不对CSR执行读的过程</li></ul><h4 id="1-1-伪指令"><a href="#1-1-伪指令" class="headerlink" title="1.1 伪指令"></a>1.1 伪指令</h4><p>对 csr 的写操作</p><table><thead><tr><th>csrw csr, rs</th><th>csrrw x0,csr,rs</th><th>Write CSR</th></tr></thead></table><h4 id="2-CSRRS-Atomic-Read-and-Set-Bits-in-CSR"><a href="#2-CSRRS-Atomic-Read-and-Set-Bits-in-CSR" class="headerlink" title="2 CSRRS&#x2F;(Atomic Read and Set Bits in CSR)"></a>2 CSRRS&#x2F;(Atomic Read and Set Bits in CSR)</h4><table><thead><tr><th>语法</th><th>CSRRS RD, CSR，RS1</th><th></th></tr></thead><tbody><tr><td>例子</td><td>csrrs x5, mie, x6</td><td>x5 &#x3D; mie; mie ｜&#x3D; x6</td></tr></tbody></table><ul><li>CSRRW 先读出 CSR 中的值，将其按 XLEN 位的宽度进行 “零扩展 （zero-extend）” 后写入 RD； 然后逐个检查RS1中的值，如果某一位位1则对CSR的对应位置为1，否则保持不变。</li><li>以上两步操作以“原子性（atomically）”方式完成</li><li>如果 RD 是X0，则不对CSR执行读的过程</li></ul><h4 id="2-1-伪指令"><a href="#2-1-伪指令" class="headerlink" title="2.1 伪指令"></a>2.1 伪指令</h4><p>对csr的读操作</p><table><thead><tr><th>csrr rd, csr</th><th>csrrs rd,csr,x0</th><th>Read CSR</th></tr></thead></table><h2 id="2-RISC-V汇编语言编程"><a href="#2-RISC-V汇编语言编程" class="headerlink" title="2 RISC-V汇编语言编程"></a>2 RISC-V汇编语言编程</h2><p>一个完整的 RISC-V 汇编程序有多条语句（statement）组成<br>一条典型的RISC-V汇编语句由3部分组成</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-attr">[label:]</span> <span class="hljs-selector-attr">[operation]</span> <span class="hljs-selector-attr">[comment]</span></code></pre></div><ul><li>label: 标号：GNU汇编中，任何以冒号结尾的标识符都被认为是一个标号</li><li>operation 可以有以下多种指令<ul><li>instruction（指令）：直接对应二进制机器指令的字符串</li><li>pseudo-instruction（伪指令）：为了提高编写代码的效率，可以用一条伪指令指示汇编器产生多条实际的指令</li><li>directive（指示&#x2F;伪操作）：通过类似指令的形式（以“.”开头），通知汇编器如何控制代码的产生等，不对应具体的指令。<ul><li>.text 数据存放段</li><li>.global 全局可见</li></ul></li><li>macro：采用 .macro&#x2F;.endm 自定义的宏，.macro 和 .endm 之间的是宏</li></ul></li><li>comment<ul><li>注释，“#” 开始到当前行结束</li></ul></li></ul><h2 id="3-函数开始过程"><a href="#3-函数开始过程" class="headerlink" title="3 函数开始过程"></a>3 函数开始过程</h2><table><thead><tr><th>函数起始部分</th></tr></thead><tbody><tr><td>减少sp的值，根据本函数中使用saved寄存器的情况以及local变量的多少开辟一个栈帧</td></tr><tr><td>将 saved 寄存器的值保存到栈中</td></tr><tr><td>如果函数中还会调用其他函数，则将ra寄存器的值保存在栈中</td></tr><tr><td>执行函数</td></tr><tr><td>函数退出部分</td></tr><tr><td>从栈中恢复 saved 寄存器</td></tr><tr><td>需要的话，从栈中恢复 ra 寄存器</td></tr><tr><td>增加 sp 的值，恢复到进入本函数之前的状态。（出栈）</td></tr><tr><td>调用 ret 返回</td></tr></tbody></table><h2 id="4-函数调用规范与栈"><a href="#4-函数调用规范与栈" class="headerlink" title="4 函数调用规范与栈"></a>4 函数调用规范与栈</h2><h3 id="4-1-函数调用规范"><a href="#4-1-函数调用规范" class="headerlink" title="4.1 函数调用规范"></a>4.1 函数调用规范</h3><p>是用来描述父子函数如何编译和链接的，包括栈道布局、参数的传递等。</p><p>主要使用x1 - x31 寄存器， x0寄存器为0</p><table><thead><tr><th>寄存器</th><th>别名</th><th>作用</th></tr></thead><tbody><tr><td>x0</td><td>zero</td><td>寄存器的内容全是0</td></tr><tr><td>x1</td><td>ra</td><td>保存函数返回地址。（return address）</td></tr><tr><td>x2</td><td>sp</td><td>栈指针寄存器，指向栈的地址 （stack pointer）</td></tr><tr><td>x3</td><td>gp</td><td>保存全局指针。</td></tr><tr><td>x4</td><td>tp</td><td>保存线程指针</td></tr><tr><td>x5～x7 x28～x31</td><td>t0～t2，t3～t6</td><td>临时寄存器（temporaries）</td></tr><tr><td>x8～x9 x18～x27</td><td>s0，s1，s2～s11</td><td>保存寄存器 （saved），被调用者需要保存的寄存器</td></tr><tr><td>x10,x11</td><td>a0,a1</td><td>参数寄存器（argument）用于在调用函数过程中保存第一个和第二个参数，以及在函数返回时传递返回值和返回结果。</td></tr><tr><td>x12～x17</td><td>a2～a7</td><td>参数寄存器（argument）用于在调用函数时需要传递更多的参数，可以用这些寄存器，但注意传递参数的寄存器最多只有8个（a0～a7），如果还有更多的参数则要使用栈。</td></tr></tbody></table><ul><li>如果传递的参数小于64位，就先符号扩展到32位，再扩展到64位，如果参数是128位，就会用一对寄存器来传递该参数。</li><li>函数的返回参数保存在a0和a1寄存器中</li><li>函数的返回地址保存在ra寄存器中</li><li>如果子函数里使用s0～s11寄存器，那么子函数在使用前需要把这些寄存器的内容保存到栈中之后再从栈中将内容恢复到寄存器中。</li><li>栈向下增长，sp寄存器在进入函数时要对齐到16字节边界上。传递给栈道第一个参数位于sp寄存器偏移量0处，后续的参数存储在相应的较高地址处。</li></ul><h3 id="入栈和出栈"><a href="#入栈和出栈" class="headerlink" title="入栈和出栈"></a>入栈和出栈</h3><p>栈帧指针（FP）指向栈底。栈在函数调用中，包含存储函数使用的局部变量，传递参数。在RISCV体系结构中，每个栈帧的大小至少为16字节，栈底存储函数的返回地址和FP的值。</p><ul><li>栈内布局的关键点<ul><li>所有函数调用栈都是从高地址向低地址扩展</li><li>SP永远指向栈顶（栈道最低地址）</li><li>调用了子函数，函数的返回地址需要保存到栈里，即 s_ra 位置</li><li>栈的大小为16字节的倍数</li><li>返回时需要先把返回地址从栈s_ra中恢复到rs寄存器，然后执行ret指令</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>RISC-V 硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RUST数据结构-查找算法</title>
    <link href="/2025/03/02/rust%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RUST%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/02/rust%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RUST%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-线性查找"><a href="#1-线性查找" class="headerlink" title="1 线性查找"></a>1 线性查找</h2><p>不考虑数据分布，数据的相对位置就是数据项的索引值，一种很自然的查找技术就是线性查找。</p><p>顺序查找的复杂度O(n)</p><p>数据有序时，平均查找速度能提高一倍</p><h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2 二分查找"></a>2 二分查找</h2><p>复杂度 O(log2(n))</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">fn</span> binary_search(nums: &amp;[i32], target: i32) -&gt; bool &#123;    <span class="hljs-attribute">let</span> mut low = <span class="hljs-number">0</span>;    <span class="hljs-attribute">let</span> mut high = nums.len() - <span class="hljs-number">1</span>;    <span class="hljs-attribute">let</span> mut found = <span class="hljs-literal">false</span>;    <span class="hljs-attribute">while</span> low &lt;= high &amp;&amp; !found &#123;        <span class="hljs-attribute">let</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-attribute">if</span> nums[mid] == target &#123;            <span class="hljs-attribute">found</span> = <span class="hljs-literal">true</span>;        &#125; <span class="hljs-attribute">else</span> if target &lt; nums[mid] &#123;            <span class="hljs-attribute">high</span> = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-section">else</span> &#123;            <span class="hljs-attribute">low</span> = mid + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-attribute">found</span>&#125;</code></pre></div><p>递归二分查找</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">binary_search2</span>(nums: &amp;[<span class="hljs-type">i32</span>], target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-comment">//基本情况目标项不存在</span>    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> == nums.<span class="hljs-title function_ invoke__">len</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">let</span> <span class="hljs-variable">mid</span> = nums.<span class="hljs-title function_ invoke__">len</span>() &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-comment">// 目标项存在</span>    <span class="hljs-keyword">if</span> target == nums[mid] &#123;        <span class="hljs-literal">true</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> target &lt; nums[mid] &#123;        <span class="hljs-title function_ invoke__">binary_search2</span>(&amp;nums[..mid], target)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-title function_ invoke__">binary_search2</span>(&amp;nums[mid + <span class="hljs-number">1</span>..], target)    &#125;&#125;</code></pre></div><h2 id="3-内插查找"><a href="#3-内插查找" class="headerlink" title="3 内插查找"></a>3 内插查找</h2><p>是二分查找的一种变体，适合在有序数据中查找。如果数据是均分的，那么内插查找可以快速逼近待搜索区域，提高查找效率。</p><p>通过线性内插法计算，将 索引当x轴元素当y轴。</p><p>数据均分状态下复杂度 O(log logn)最坏情况为 O(n)</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">interpolation_search</span>(nums: &amp;[<span class="hljs-type">i32</span>], target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> nums.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">low</span> = <span class="hljs-number">0usize</span>;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">high</span> = nums.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>;    <span class="hljs-keyword">loop</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">low_val</span> = nums[low];        <span class="hljs-keyword">let</span> <span class="hljs-variable">high_val</span> = nums[high];        <span class="hljs-keyword">if</span> high &lt;= low || target &lt; low_val || target &gt; high_val &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">//计算差值位置</span>        <span class="hljs-keyword">let</span> <span class="hljs-variable">offset</span> = (target - low_val) * (high - low) <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> / (high_val - low_val);        <span class="hljs-keyword">let</span> <span class="hljs-variable">interpolant</span> = low + offset <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;        <span class="hljs-comment">// 更新上/下界 high 和 low</span>        <span class="hljs-keyword">if</span> nums[interpolant] &gt; target &#123;            high = interpolant - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[interpolant] &lt; target &#123;            low = interpolant + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    target == nums[high]&#125;</code></pre></div><h2 id="4-指数查找"><a href="#4-指数查找" class="headerlink" title="4 指数查找"></a>4 指数查找</h2><p>可以快速找到上界，加快查找速度，不断比较2的倍数次幂的关系，确定搜索区域，进行二分。</p><p>复杂度为 O(log i)</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">exponential_search</span> (nums: &amp;[<span class="hljs-type">i32</span>], target: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">size</span> = nums.<span class="hljs-title function_ invoke__">len</span>();    <span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;    <span class="hljs-comment">// 逐步找到上界</span>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">high</span> = <span class="hljs-number">1usize</span>;    <span class="hljs-keyword">while</span> high &lt; size &amp;&amp; nums[high] &lt; target &#123;        high &lt;&lt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">//上界的一半一定可以定为下界</span>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">low</span> = high &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-title function_ invoke__">binary_search</span>(nums, target)&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>rust数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RUST数据结构-非线性数据结构</title>
    <link href="/2025/03/01/rust%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RUST%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2025/03/01/rust%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/RUST%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="非线性数据结构"><a href="#非线性数据结构" class="headerlink" title="非线性数据结构"></a>非线性数据结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>抽象数据结构：树 </p><p>文件路径，数据库等。</p><p>简单实现基于向量的树，但是针对向量的操作消耗太大</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&lt;T&gt; &#123;    data: T,    children: <span class="hljs-type">Vec</span>&lt;TreeNode&lt;T&gt;&gt;,&#125;<span class="hljs-comment">// 树：：节点指针</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Link</span>&lt;T&gt; = <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;T&gt;&gt;;<span class="hljs-keyword">type</span> <span class="hljs-title class_">Tree</span>&lt;T&gt; = Link&lt;TreeNode&lt;T&gt;&gt;;<span class="hljs-keyword">impl</span> &lt;T&gt; TreeNode&lt;T&gt; &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: T) <span class="hljs-punctuation">-&gt;</span> TreeNode&lt;T&gt; &#123;        TreeNode &#123;            data,            children: <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>(),        &#125;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_data</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;        &amp;<span class="hljs-keyword">self</span>.data    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_child_nth</span>(&amp;<span class="hljs-keyword">self</span>, i: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> &amp;TreeNode&lt;T&gt; &#123;        &amp;<span class="hljs-keyword">self</span>.children[i]    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">push_child</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, child: TreeNode&lt;T&gt;) &#123;        <span class="hljs-keyword">self</span>.children.<span class="hljs-title function_ invoke__">push</span>(child);    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove_child</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, i: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> TreeNode&lt;T&gt; &#123;        <span class="hljs-keyword">self</span>.children.<span class="hljs-title function_ invoke__">remove</span>(i)    &#125;&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">root</span> = TreeNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">child1</span> =  TreeNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">2</span>);    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">child2</span> = TreeNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);    child1.<span class="hljs-title function_ invoke__">push_child</span>(TreeNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">4</span>));    child1.<span class="hljs-title function_ invoke__">push_child</span>(TreeNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>));    child2.<span class="hljs-title function_ invoke__">push_child</span>(TreeNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">6</span>));    child2.<span class="hljs-title function_ invoke__">push_child</span>(TreeNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">7</span>));    root.<span class="hljs-title function_ invoke__">push_child</span>(child1);    root.<span class="hljs-title function_ invoke__">push_child</span>(child2);    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, root);&#125;</code></pre></div><p>二叉树</p><p>每个节点最多有两个子节点</p><p>实际上多叉树用长子兄弟表示法转换到二叉树</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryTreeNode</span>&lt;T&gt; &#123;    data: T,    left: Link&lt;BinaryTreeNode&lt;T&gt;&gt;,    right: Link&lt;BinaryTreeNode&lt;T&gt;&gt;,&#125;<span class="hljs-comment">// 树：：节点指针</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Link</span>&lt;T&gt; = <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;T&gt;&gt;;<span class="hljs-keyword">type</span> <span class="hljs-title class_">BinaryTree</span>&lt;T&gt; = Link&lt;BinaryTreeNode&lt;T&gt;&gt;;<span class="hljs-keyword">impl</span> &lt;T&gt; BinaryTreeNode&lt;T&gt; &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: T) <span class="hljs-punctuation">-&gt;</span> BinaryTreeNode&lt;T&gt; &#123;        BinaryTreeNode &#123;            data,            left: <span class="hljs-literal">None</span>,            right: <span class="hljs-literal">None</span>,        &#125;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_data</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;        &amp;<span class="hljs-keyword">self</span>.data    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_data</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, data: T) &#123;        <span class="hljs-keyword">self</span>.data = data;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_left</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;BinaryTree&lt;T&gt; &#123;        &amp;<span class="hljs-keyword">self</span>.left    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_right</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;BinaryTree&lt;T&gt; &#123;        &amp;<span class="hljs-keyword">self</span>.right    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_lift</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, child: BinaryTree&lt;T&gt;) &#123;        <span class="hljs-keyword">self</span>.left = child;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_right</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, child: BinaryTree&lt;T&gt;) &#123;        <span class="hljs-keyword">self</span>.right = child;    &#125;&#125;</code></pre></div><p>计算二叉树的深度、节点数、叶子节点数</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; BinaryTreeNode&lt;T&gt; &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">size</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">size</span> = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(left) = &amp;<span class="hljs-keyword">self</span>.left &#123;            size += left.<span class="hljs-title function_ invoke__">size</span>();        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(right) = &amp;<span class="hljs-keyword">self</span>.right &#123;            size += right.<span class="hljs-title function_ invoke__">size</span>();        &#125;        size    &#125;    <span class="hljs-comment">// 二叉树深度</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">depth</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">left_depth</span> = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(left) = &amp;<span class="hljs-keyword">self</span>.left &#123;            left.<span class="hljs-title function_ invoke__">depth</span>()        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-number">0</span>        &#125;;        <span class="hljs-keyword">let</span> <span class="hljs-variable">right_depth</span> = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(right) = &amp;<span class="hljs-keyword">self</span>.right &#123;            right.<span class="hljs-title function_ invoke__">depth</span>()        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-number">0</span>        &#125;;        <span class="hljs-number">1</span> + left_depth.<span class="hljs-title function_ invoke__">max</span>(right_depth)    &#125;    <span class="hljs-comment">// 计算叶子节点</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">leaf_size</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;        <span class="hljs-comment">//左右都为空那么当前节点就是叶子节点</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.left.<span class="hljs-title function_ invoke__">is_some</span>() &amp;&amp; <span class="hljs-keyword">self</span>.right.<span class="hljs-title function_ invoke__">is_some</span>() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">let</span> <span class="hljs-variable">left_leaf</span> = <span class="hljs-keyword">match</span> &amp;<span class="hljs-keyword">self</span>.left &#123;            <span class="hljs-literal">None</span> =&gt; <span class="hljs-number">0</span>,            <span class="hljs-title function_ invoke__">Some</span>(left) =&gt; left.<span class="hljs-title function_ invoke__">leaf_size</span>(),        &#125;;        <span class="hljs-keyword">let</span> <span class="hljs-variable">right_leaf</span> = <span class="hljs-keyword">match</span> &amp;<span class="hljs-keyword">self</span>.right &#123;            <span class="hljs-literal">None</span> =&gt; <span class="hljs-number">0</span>,            <span class="hljs-title function_ invoke__">Some</span>(right) =&gt; right.<span class="hljs-title function_ invoke__">leaf_size</span>(),        &#125;;        left_leaf + right_leaf    &#125;    <span class="hljs-comment">// 计算非叶子节点数</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">name_leaf_size</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">size</span>() - <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">leaf_size</span>()    &#125;&#125;</code></pre></div><p>二叉树的遍历</p><div class="code-wrapper"><pre><code class="hljs lasso">impl&lt;T: std<span class="hljs-type">::fmt</span><span class="hljs-type">::Display</span>&gt; BinaryTreeNode&lt;T&gt; &#123;    <span class="hljs-comment">//后序遍历</span>    fn pos_order(&amp;<span class="hljs-built_in">self</span>)    <span class="hljs-keyword">where</span>        T: std<span class="hljs-type">::fmt</span><span class="hljs-type">::Display</span>    &#123;        <span class="hljs-built_in">self</span>.left.as_ref().<span class="hljs-built_in">map</span>(|n| n.pos_order());        <span class="hljs-built_in">self</span>.right.as_ref().<span class="hljs-built_in">map</span>(|n| n.pos_order());        println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-built_in">self</span>.<span class="hljs-built_in">data</span>);    &#125;    <span class="hljs-comment">//前序遍历</span>    fn pre_order(&amp;<span class="hljs-built_in">self</span>)    <span class="hljs-keyword">where</span>        T: std<span class="hljs-type">::fmt</span><span class="hljs-type">::Display</span>    &#123;        println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-built_in">self</span>.<span class="hljs-built_in">data</span>);        <span class="hljs-built_in">self</span>.left.as_ref().<span class="hljs-built_in">map</span>(|n| n.pre_order());        <span class="hljs-built_in">self</span>.right.as_ref().<span class="hljs-built_in">map</span>(|n| n.pre_order());    &#125;    <span class="hljs-comment">//中序遍历</span>    fn in_order(&amp;<span class="hljs-built_in">self</span>)    <span class="hljs-keyword">where</span>        T: std<span class="hljs-type">::fmt</span><span class="hljs-type">::Display</span>    &#123;        <span class="hljs-built_in">self</span>.left.as_ref().<span class="hljs-built_in">map</span>(|n| n.in_order());        println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-built_in">self</span>.<span class="hljs-built_in">data</span>);        <span class="hljs-built_in">self</span>.right.as_ref().<span class="hljs-built_in">map</span>(|n| n.in_order());    &#125;&#125;</code></pre></div><p>二叉搜索树</p><ul><li>在二叉树的计算上要求节点值有序：左节点的值 &lt;&#x3D; 当前节点 &lt;&#x3D; 右子树任意节点</li><li>在维持平衡的情况下，具有O（logn）的随机查找、插入和删除性能。</li><li>应用：实现 Ordered Map &#x2F;Set 数据结构</li></ul><p>二叉搜索树的查找</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">//查找</span><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Ord</span>&gt; BinarySearchTreeNode&lt;T&gt; &#123;    <span class="hljs-comment">//查询data是否在树中</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>, data: &amp;T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;        <span class="hljs-keyword">use</span> std::cmp::Ordering;        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">cmp</span>(data) &#123;            Ordering::Less =&gt; <span class="hljs-keyword">match</span> &amp;<span class="hljs-keyword">self</span>.right &#123;                <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">false</span>,                <span class="hljs-title function_ invoke__">Some</span>(right) =&gt; right.<span class="hljs-title function_ invoke__">contains</span>(data),            &#125;,            Ordering::Equal =&gt; <span class="hljs-literal">true</span>,            Ordering::Greater =&gt; <span class="hljs-keyword">match</span> &amp;<span class="hljs-keyword">self</span>.left &#123;                <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">false</span>,                <span class="hljs-title function_ invoke__">Some</span>(left) =&gt; left.<span class="hljs-title function_ invoke__">contains</span>(data),            &#125;,        &#125;    &#125;&#125;</code></pre></div><p>二叉搜索树的插入</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">//插入</span><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Ord</span>&gt; BinarySearchTreeNode&lt;T&gt; &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, data: T) &#123;        <span class="hljs-keyword">use</span> std::cmp::Ordering;                <span class="hljs-keyword">match</span> &amp;<span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">cmp</span>(&amp;data) &#123;            Ordering::Equal =&gt; &#123;&#125;            Ordering::Greater =&gt; <span class="hljs-keyword">match</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.left &#123;                <span class="hljs-comment">// 当前节点 &gt; 目标 key，插入到左子树</span>                <span class="hljs-title function_ invoke__">Some</span>(left) =&gt; left.<span class="hljs-title function_ invoke__">insert</span>(data),                <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">set_lift</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(BinarySearchTreeNode::<span class="hljs-title function_ invoke__">new</span>(data))))            &#125;,            Ordering::Less =&gt; <span class="hljs-keyword">match</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.right &#123;                <span class="hljs-comment">// 当前节点 &lt; 目标 key，插入到右子树</span>                <span class="hljs-title function_ invoke__">Some</span>(right) =&gt; right.<span class="hljs-title function_ invoke__">insert</span>(data),                <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">set_right</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(BinarySearchTreeNode::<span class="hljs-title function_ invoke__">new</span>(data)))),            &#125;        &#125;    &#125;&#125;</code></pre></div><p>二叉搜索树的删除</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;, data: &amp;T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;BinarySearchTreeNode&lt;T&gt;&gt;&gt; &#123;    <span class="hljs-keyword">use</span> std::cmp::Ordering;    <span class="hljs-keyword">match</span> &amp;<span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">cmp</span>(data) &#123;        Ordering::Equal =&gt; &#123;            <span class="hljs-comment">//当前节点就是要删除的节点</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.right.<span class="hljs-title function_ invoke__">is_none</span>() &#123;                <span class="hljs-comment">// 只有左子节点，将左子节点替换当前节点</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.left.<span class="hljs-title function_ invoke__">take</span>();            &#125;            <span class="hljs-comment">// 右子节点存在，找到右子节点中最小节点替换当前节点</span>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">leftmost</span> = <span class="hljs-keyword">self</span>.right.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>();            <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> next) = leftmost.left &#123;                leftmost = next;            &#125;            std::mem::<span class="hljs-title function_ invoke__">swap</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.left, &amp;<span class="hljs-keyword">mut</span> leftmost.left);            <span class="hljs-comment">// 递归删除右子树中最小节点</span>            <span class="hljs-keyword">self</span>.right = <span class="hljs-keyword">self</span>.right.<span class="hljs-title function_ invoke__">take</span>().<span class="hljs-title function_ invoke__">and_then</span>(|right| right.<span class="hljs-title function_ invoke__">remove</span>(&amp;data));            <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>)        &#125;        Ordering::Greater =&gt; &#123;            <span class="hljs-comment">//当前节点 &gt; 目标 key， 在左子树查找</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(left) = <span class="hljs-keyword">self</span>.left &#123;                <span class="hljs-keyword">self</span>.left = left.<span class="hljs-title function_ invoke__">remove</span>(data);            &#125;            <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>)        &#125;        Ordering::Less =&gt; &#123;            <span class="hljs-comment">// 当前节点 &lt; 目标key，在右子树中查找</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(right) = <span class="hljs-keyword">self</span>.right &#123;                <span class="hljs-keyword">self</span>.right = right.<span class="hljs-title function_ invoke__">remove</span>(data);            &#125;            <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>)        &#125;    &#125;&#125;</code></pre></div><p>二叉搜索树的再平衡</p><p>删除元素会导致失衡导致性能劣化 需要平衡</p><p>AVL树，只要维护任意两颗子树的最大高度差为1</p><p>旋转操作</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">TODO</span></code></pre></div><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>一种特殊的树形数据结构<br>当前节点 &lt;&#x3D; 当前节点的所有孩子节点 &#x3D;&#x3D;&gt; 最小堆<br>当前节点 &gt;&#x3D; 当前节点所有的孩子节点 &#x3D;&#x3D;&gt; 最大堆</p><p>性质： O(1) 获取数组的最值</p><p>应用：实现优先级队列、排序算法（堆排序）、获取流式数据的最值</p><p>堆排序若一个节点处于下标p处，它的左节点处于2p处，右子节点处于2p + 1处。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 二叉堆</span>#[derive(<span class="hljs-type">Debug</span>, <span class="hljs-type">Clone</span>)]<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryHeap</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">Ord</span>&gt; &#123;    data: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">T</span>&gt;,<span class="hljs-comment">// 压缩储存</span>&#125;<span class="hljs-comment">// 计算父节点的下标</span>macro_rules<span class="hljs-operator">!</span> parent &#123;    (<span class="hljs-variable">$child</span>:ident) <span class="hljs-operator">=&gt;</span> &#123;<span class="hljs-variable">$child</span> <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1</span>&#125;;&#125;<span class="hljs-comment">// 计算左子节点的下标</span>macro_rules<span class="hljs-operator">!</span> left_child &#123;    (<span class="hljs-variable">$parent</span>:ident) <span class="hljs-operator">=&gt;</span> &#123;<span class="hljs-variable">$parent</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-number">1</span>&#125;;&#125;<span class="hljs-comment">//计算右子节点的下标</span>macro_rules<span class="hljs-operator">!</span> right_child &#123;    (<span class="hljs-variable">$parent</span>:ident) <span class="hljs-operator">=&gt;</span> &#123;(<span class="hljs-variable">$parent</span> <span class="hljs-operator">&lt;&lt;</span> <span class="hljs-number">1</span>) <span class="hljs-operator">+</span> <span class="hljs-number">1</span>&#125;;&#125;</code></pre></div><p>插入元素</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Ord</span>&gt; BinaryHeap&lt;T&gt; &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;        BinaryHeap &#123;            size: <span class="hljs-number">0</span>,            data: <span class="hljs-built_in">vec!</span>[]        &#125;    &#125;    <span class="hljs-comment">// 获取堆顶元素</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">top</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;T&gt; &#123;        <span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>)    &#125;    <span class="hljs-comment">// 插入元素</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, val: T) &#123;        <span class="hljs-comment">// 插入到末端</span>        <span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">push</span>(val);        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">child</span> = <span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">parent</span> = parent!(child);        <span class="hljs-comment">// 自上而下调整堆</span>        <span class="hljs-keyword">while</span> child &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">self</span>.data[parent] == <span class="hljs-keyword">self</span>.data[child] &#123;            <span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">swap</span>(parent, child);            child = parent;            parent = parent!(child);        &#125;    &#125;&#125;</code></pre></div><p>堆删除<br>&#x2F;&#x2F;TODO</p><div class="code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">fn</span> pop(&amp;mut self) -&gt; <span class="hljs-type">Option</span>&lt;<span class="hljs-type">T</span>&gt; &#123;        <span class="hljs-keyword">if</span> self.<span class="hljs-class"><span class="hljs-keyword">data</span>.is_empty() &#123;</span><span class="hljs-class">            <span class="hljs-title">return</span> <span class="hljs-type">None</span>;</span><span class="hljs-class">        &#125;</span>        <span class="hljs-keyword">let</span> n = self.<span class="hljs-class"><span class="hljs-keyword">data</span>.len();</span>        self.<span class="hljs-class"><span class="hljs-keyword">data</span>.swap(0, <span class="hljs-title">n</span> - 1);</span>        <span class="hljs-keyword">let</span> mut parent = <span class="hljs-number">0</span>;        loop &#123;            <span class="hljs-keyword">let</span> left = left_child!(parent);            <span class="hljs-keyword">let</span> right = right_child!(parent);            <span class="hljs-keyword">let</span> mut max = parent;            <span class="hljs-keyword">if</span> left &lt; n - <span class="hljs-number">1</span> &amp;&amp; self.<span class="hljs-class"><span class="hljs-keyword">data</span>[left] &lt; self.<span class="hljs-keyword">data</span>[max] &#123;</span><span class="hljs-class">                <span class="hljs-title">max</span> = <span class="hljs-title">left</span>;</span><span class="hljs-class">            &#125;</span>            <span class="hljs-keyword">if</span> right &lt; n - <span class="hljs-number">1</span> &amp;&amp; self.<span class="hljs-class"><span class="hljs-keyword">data</span>[right] &lt; self.<span class="hljs-keyword">data</span>[max] &#123;</span><span class="hljs-class">                <span class="hljs-title">max</span> = <span class="hljs-title">right</span>;</span><span class="hljs-class">            &#125;</span>            <span class="hljs-keyword">if</span> max == parent &#123;                break;            &#125;            self.<span class="hljs-class"><span class="hljs-keyword">data</span>.swap(<span class="hljs-title">parent</span>, <span class="hljs-title">max</span>);</span>            parent = max;        &#125;                self.<span class="hljs-class"><span class="hljs-keyword">data</span>.pop()</span>    &#125;</code></pre></div><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>冲突解决：<br>开放地址法<br>线性试探法<br>二次试探法</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>节点、边、路径、环、有向图、无向图、权重、连同性、连通图、强连通图（双向图）</p><p>图的表示</p><ul><li>邻接矩阵</li><li>领接表</li></ul><p>邻接矩阵：二维表示顶点和顶点之间的关系，直观，易于理解，适合存储稠密图（边很多），空间复杂度 O（n^2）浪费空间、适合场景，顶点固定，频繁修改边<br>领接表：对于每个顶点只记录存在的边、空间复杂度O(n+e)、适合场景：顶点不固定、频繁遍历图、稀疏图</p>]]></content>
    
    
    
    <tags>
      
      <tag>rust数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RUST圣经-高阶学习-async_await异步编程-下</title>
    <link href="/2025/03/01/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-async-await%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%E4%B8%8B/"/>
    <url>/2025/03/01/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-async-await%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="4-async-await-和-Stream-流处理"><a href="#4-async-await-和-Stream-流处理" class="headerlink" title="4 async&#x2F;await 和 Stream 流处理"></a>4 async&#x2F;await 和 Stream 流处理</h2><p>async&#x2F;.await 是 Rust 语法的一部分，它在遇到阻塞操作时( 例如 IO )会让出当前线程的所有权而不是阻塞当前线程，这样就允许当前线程继续去执行其它代码，最终实现并发。</p><p>有两种方式可以使用 async： async fn 用于声明函数，async { … } 用于声明语句块，它们会返回一个实现 Future 特征的值:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// `foo()`返回一个`Future&lt;Output = u8&gt;`,</span><span class="hljs-comment">// 当调用`foo().await`时，该`Future`将被运行，当调用结束后我们将获取到一个`u8`值</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; <span class="hljs-number">5</span> &#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">u8</span>&gt; &#123;    <span class="hljs-comment">// 下面的`async`语句块返回`Future&lt;Output = u8&gt;`</span>    <span class="hljs-keyword">async</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">u8</span> = <span class="hljs-title function_ invoke__">foo</span>().<span class="hljs-keyword">await</span>;        x + <span class="hljs-number">5</span>    &#125;&#125;</code></pre></div><p>async 是懒惰的，直到被执行器 poll 或者 .await 后才会开始运行，后者是最常用的运行 Future 的方法。 当 .await 被调用时，它会尝试运行 Future 直到完成，但是若该 Future 进入阻塞，那就会让出当前线程的控制权。当 Future 后面准备再一次被运行时(例如从 socket 中读取到了数据)，执行器会得到通知，并再次运行该 Future ，如此循环，直到完成。</p><h2 id="4-1-async-的生命周期"><a href="#4-1-async-的生命周期" class="headerlink" title="4.1 async 的生命周期"></a>4.1 async 的生命周期</h2><p>async fn 函数如果拥有引用类型的参数，那它返回的 Future 的生命周期就会被这些参数的生命周期所限制:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(x: &amp;<span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; *x &#125;<span class="hljs-comment">// 上面的函数跟下面的函数是等价的:</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo_expanded</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">u8</span>&gt; + <span class="hljs-symbol">&#x27;a</span> &#123;    <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123; *x &#125;&#125;</code></pre></div><p>意味着 async fn 函数返回的 Future 必须满足以下条件: 当 x 依然有效时， 该 Future 就必须继续等待( .await ), 也就是说 x 必须比 Future 活得更久。</p><p>在一般情况下，在函数调用后就立即 .await 不会存在任何问题，例如foo(&amp;x).await。但是，若 Future 被先存起来或发送到另一个任务或者线程，就可能存在问题了:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::future::Future;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">bad</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">u8</span>&gt; &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;    <span class="hljs-title function_ invoke__">borrow_x</span>(&amp;x) <span class="hljs-comment">// ERROR: `x` does not live long enough</span>&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">borrow_x</span>(x: &amp;<span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; *x &#125;</code></pre></div><p>以上代码会报错，因为 x 的生命周期只到 bad 函数的结尾。 但是 Future 显然会活得更久：</p><p>其中一个常用的解决方法就是将具有引用参数的 async fn 函数转变成一个具有 ‘static 生命周期的 Future 。 以上解决方法可以通过将参数和对 async fn 的调用放在同一个 async 语句块来实现:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::future::Future;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">borrow_x</span>(x: &amp;<span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; *x &#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">good</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">u8</span>&gt; &#123;    <span class="hljs-keyword">async</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;        <span class="hljs-title function_ invoke__">borrow_x</span>(&amp;x).<span class="hljs-keyword">await</span>    &#125;&#125;</code></pre></div><p>如上所示，通过将参数移动到 async 语句块内， 我们将它的生命周期扩展到 ‘static， 并跟返回的 Future 保持了一致。</p><h2 id="4-2-async-move"><a href="#4-2-async-move" class="headerlink" title="4.2 async move"></a>4.2 async move</h2><p>async 允许我们使用 move 关键字来将环境中变量的所有权转移到语句块内，就像闭包那样，好处是你不再发愁该如何解决借用生命周期的问题，坏处就是无法跟其它代码实现对变量的共享:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 多个不同的 `async` 语句块可以访问同一个本地变量，只要它们在该变量的作用域内执行</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">blocks</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_string</span> = <span class="hljs-string">&quot;foo&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">future_one</span> = <span class="hljs-keyword">async</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;my_string&#125;&quot;</span>);    &#125;;    <span class="hljs-keyword">let</span> <span class="hljs-variable">future_two</span> = <span class="hljs-keyword">async</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;my_string&#125;&quot;</span>);    &#125;;    <span class="hljs-comment">// 运行两个 Future 直到完成</span>    <span class="hljs-keyword">let</span> ((), ()) = futures::join!(future_one, future_two);&#125;<span class="hljs-comment">// 由于 `async move` 会捕获环境中的变量，因此只有一个 `async move` 语句块可以访问该变量，</span><span class="hljs-comment">// 但是它也有非常明显的好处： 变量可以转移到返回的 Future 中，不再受借用生命周期的限制</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">move_block</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = ()&gt; &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_string</span> = <span class="hljs-string">&quot;foo&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();    <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;        <span class="hljs-comment">// ...</span>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;my_string&#125;&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="4-3-当-await-遇见多线程执行器"><a href="#4-3-当-await-遇见多线程执行器" class="headerlink" title="4.3 当.await 遇见多线程执行器"></a>4.3 当.await 遇见多线程执行器</h2><p>当使用多线程 Future 执行器( executor )时， Future 可能会在线程间被移动，因此 async 语句块中的变量必须要能在线程间传递。 至于 Future 会在线程间移动的原因是：它内部的任何.await都可能导致它被切换到一个新线程上去执行。</p><p>需要在多线程环境使用，意味着 Rc、 RefCell 、没有实现 Send 的所有权类型、没有实现 Sync 的引用类型，它们都是不安全的，因此无法被使用</p><p>类似的原因，在 .await 时使用普通的锁也不安全，例如 Mutex 。原因是，它可能会导致线程池被锁：当一个任务获取锁 A 后，若它将线程的控制权还给执行器，然后执行器又调度运行另一个任务，该任务也去尝试获取了锁 A ，结果当前线程会直接卡死，最终陷入死锁中。</p><p>因此，为了避免这种情况的发生，我们需要使用 futures 包下的锁 futures::lock 来替代 Mutex 完成任务。</p><h2 id="4-4-Stream-流处理"><a href="#4-4-Stream-流处理" class="headerlink" title="4.4 Stream 流处理"></a>4.4 Stream 流处理</h2><p>Stream 特征类似于 Future 特征，但是前者在完成前可以生成多个值，这种行为跟标准库中的 Iterator 特征倒是颇为相似。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Stream</span> &#123;    <span class="hljs-comment">// Stream生成的值的类型</span>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;    <span class="hljs-comment">// 尝试去解析Stream中的下一个值,</span>    <span class="hljs-comment">// 若无数据，返回`Poll::Pending`, 若有数据，返回 `Poll::Ready(Some(x))`, `Stream`完成则返回 `Poll::Ready(None)`</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll_next</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;)        <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;&gt;;&#125;</code></pre></div><p>关于 Stream 的一个常见例子是消息通道（ futures 包中的）的消费者 Receiver。每次有消息从 Send 端发送后，它都可以接收到一个 Some(val) 值， 一旦 Send 端关闭( drop )，且消息通道中没有消息后，它会接收到一个 None 值。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send_recv</span>() &#123;    <span class="hljs-keyword">const</span> BUFFER_SIZE: <span class="hljs-type">usize</span> = <span class="hljs-number">10</span>;    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> tx, <span class="hljs-keyword">mut</span> rx) = mpsc::channel::&lt;<span class="hljs-type">i32</span>&gt;(BUFFER_SIZE);    tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();    tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">2</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();    <span class="hljs-title function_ invoke__">drop</span>(tx);    <span class="hljs-comment">// `StreamExt::next` 类似于 `Iterator::next`, 但是前者返回的不是值，而是一个 `Future&lt;Output = Option&lt;T&gt;&gt;`，</span>    <span class="hljs-comment">// 因此还需要使用`.await`来获取具体的值</span>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>), rx.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>);    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">2</span>), rx.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>);    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>, rx.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>);&#125;</code></pre></div><h2 id="4-4-1-迭代和并发"><a href="#4-4-1-迭代和并发" class="headerlink" title="4.4.1 迭代和并发"></a>4.4.1 迭代和并发</h2><p>跟迭代器类似，我们也可以迭代一个 Stream。 例如使用 map，filter，fold 方法，以及它们的遇到错误提前返回的版本： try_map，try_filter，try_fold。</p><p>但是跟迭代器又有所不同，for 循环无法在这里使用，但是命令式风格的循环while let是可以用的，同时还可以使用next 和 try_next 方法:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sum_with_next</span>(<span class="hljs-keyword">mut</span> stream: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">dyn</span> Stream&lt;Item = <span class="hljs-type">i32</span>&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;    <span class="hljs-keyword">use</span> futures::stream::StreamExt; <span class="hljs-comment">// 引入 next</span>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = stream.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span> &#123;        sum += item;    &#125;    sum&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sum_with_try_next</span>(    <span class="hljs-keyword">mut</span> stream: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">dyn</span> Stream&lt;Item = <span class="hljs-type">Result</span>&lt;<span class="hljs-type">i32</span>, io::Error&gt;&gt;&gt;,) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">i32</span>, io::Error&gt; &#123;    <span class="hljs-keyword">use</span> futures::stream::TryStreamExt; <span class="hljs-comment">// 引入 try_next</span>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = stream.<span class="hljs-title function_ invoke__">try_next</span>().<span class="hljs-keyword">await</span>? &#123;        sum += item;    &#125;    <span class="hljs-title function_ invoke__">Ok</span>(sum)&#125;</code></pre></div><p>上面代码是一次处理一个值的模式，但是需要注意的是：如果你选择一次处理一个值的模式，可能会造成无法并发，这就失去了异步编程的意义。 因此，如果可以的话我们还是要选择从一个 Stream 并发处理多个值的方式，通过 for_each_concurrent 或 try_for_each_concurrent 方法来实现:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">jump_around</span>(    <span class="hljs-keyword">mut</span> stream: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">dyn</span> Stream&lt;Item = <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u8</span>, io::Error&gt;&gt;&gt;,) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), io::Error&gt; &#123;    <span class="hljs-keyword">use</span> futures::stream::TryStreamExt; <span class="hljs-comment">// 引入 `try_for_each_concurrent`</span>    <span class="hljs-keyword">const</span> MAX_CONCURRENT_JUMPERS: <span class="hljs-type">usize</span> = <span class="hljs-number">100</span>;    stream.<span class="hljs-title function_ invoke__">try_for_each_concurrent</span>(MAX_CONCURRENT_JUMPERS, |num| <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;        <span class="hljs-title function_ invoke__">jump_n_times</span>(num).<span class="hljs-keyword">await</span>?;        <span class="hljs-title function_ invoke__">report_n_jumps</span>(num).<span class="hljs-keyword">await</span>?;        <span class="hljs-title function_ invoke__">Ok</span>(())    &#125;).<span class="hljs-keyword">await</span>?;    <span class="hljs-title function_ invoke__">Ok</span>(())&#125;</code></pre></div><h2 id="5-使用-join-和-select-同时运行多个-Future"><a href="#5-使用-join-和-select-同时运行多个-Future" class="headerlink" title="5 使用 join! 和 select! 同时运行多个 Future"></a>5 使用 join! 和 select! 同时运行多个 Future</h2><p>招数单一，杀伤力惊人，说的就是 .await ，但是光用它，还真做不到一招鲜吃遍天。比如我们该如何同时运行多个任务，而不是使用 .await 慢悠悠地排队完成。</p><h2 id="5-1-join"><a href="#5-1-join" class="headerlink" title="5.1 join!"></a>5.1 join!</h2><p>futures 包中提供了很多实用的工具，其中一个就是 join! 宏， 它允许我们同时等待多个不同 Future 的完成，且可以并发地运行这些 Future。</p><p>先来看一个不是很给力的、使用.await的版本:</p><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-keyword">async</span> fn enjoy_book_and_music<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> (Book, Music) &#123;    <span class="hljs-keyword">let</span> book = enjoy_book().<span class="hljs-keyword">await</span>;    <span class="hljs-keyword">let</span> music = enjoy_music().<span class="hljs-keyword">await</span>;    (book, music)&#125;</code></pre></div><p>这段代码可以顺利运行，但是有一个很大的问题，就是必须先看完书后，才能听音乐。</p><p>要支持同时看书和听歌，有些人可能会凭空生成下面代码：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// WRONG -- 别这么做</span><span class="hljs-function"><span class="hljs-keyword">async</span> fn <span class="hljs-title">enjoy_book_and_music</span>() -&gt; (<span class="hljs-params">Book, Music</span>)</span> &#123;    <span class="hljs-keyword">let</span> book_future = enjoy_book();    <span class="hljs-keyword">let</span> music_future = enjoy_music();    (book_future.<span class="hljs-keyword">await</span>, music_future.<span class="hljs-keyword">await</span>)&#125;</code></pre></div><p>在某些语言中也许可以，但是 Rust 不行。因为在某些语言中，Future一旦创建就开始运行，等到返回的时候，基本就可以同时结束并返回了。 但是 Rust 中的 Future 是惰性的，直到调用 .await 时，才会开始运行。而那两个 await 由于在代码中有先后顺序，因此它们是顺序运行的。</p><p>为了正确的并发运行两个 Future ， 我们来试试 futures::join! 宏:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::join;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">enjoy_book_and_music</span>() <span class="hljs-punctuation">-&gt;</span> (Book, Music) &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">book_fut</span> = <span class="hljs-title function_ invoke__">enjoy_book</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">music_fut</span> = <span class="hljs-title function_ invoke__">enjoy_music</span>();    join!(book_fut, music_fut)&#125;</code></pre></div><p>目标顺利达成。同时 join! 会返回一个元组，里面的值是对应的 Future 执行结束后输出的值。</p><h2 id="5-2-try-join"><a href="#5-2-try-join" class="headerlink" title="5.2 try_join!"></a>5.2 try_join!</h2><p>join! 必须等待它管理的所有 Future 完成后才能完成，如果你希望在某一个 Future 报错后就立即停止所有 Future 的执行，可以使用 try_join!，特别是当 Future 返回 Result 时:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::try_join;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_book</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Book, <span class="hljs-type">String</span>&gt; &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-title function_ invoke__">Ok</span>(Book) &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_music</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Music, <span class="hljs-type">String</span>&gt; &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-title function_ invoke__">Ok</span>(Music) &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_book_and_music</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(Book, Music), <span class="hljs-type">String</span>&gt; &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">book_fut</span> = <span class="hljs-title function_ invoke__">get_book</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">music_fut</span> = <span class="hljs-title function_ invoke__">get_music</span>();    try_join!(book_fut, music_fut)&#125;</code></pre></div><p>传给 try_join! 的所有 Future 都必须拥有相同的错误类型。如果错误类型不同，可以考虑使用来自 futures::future::TryFutureExt 模块的 map_err 和 err_info 方法将错误进行转换:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::&#123;    future::TryFutureExt,    try_join,&#125;;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_book</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Book, ()&gt; &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-title function_ invoke__">Ok</span>(Book) &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_music</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Music, <span class="hljs-type">String</span>&gt; &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-title function_ invoke__">Ok</span>(Music) &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_book_and_music</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(Book, Music), <span class="hljs-type">String</span>&gt; &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">book_fut</span> = <span class="hljs-title function_ invoke__">get_book</span>().<span class="hljs-title function_ invoke__">map_err</span>(|()| <span class="hljs-string">&quot;Unable to get book&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());    <span class="hljs-keyword">let</span> <span class="hljs-variable">music_fut</span> = <span class="hljs-title function_ invoke__">get_music</span>();    try_join!(book_fut, music_fut)&#125;</code></pre></div><p>join! 很好很强大，但是人无完人，J 无完 J, 它有一个很大的问题。</p><h2 id="5-3-select"><a href="#5-3-select" class="headerlink" title="5.3 select!"></a>5.3 select!</h2><p>join! 只有等所有 Future 结束后，才能集中处理结果，如果你想同时等待多个 Future ，且任何一个 Future 结束后，都可以立即被处理，可以考虑使用 futures::select!:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::&#123;    future::FutureExt, <span class="hljs-comment">// for `.fuse()`</span>    pin_mut,    select,&#125;;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">task_one</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">task_two</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">race_tasks</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">t1</span> = <span class="hljs-title function_ invoke__">task_one</span>().<span class="hljs-title function_ invoke__">fuse</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">t2</span> = <span class="hljs-title function_ invoke__">task_two</span>().<span class="hljs-title function_ invoke__">fuse</span>();    pin_mut!(t1, t2);    <span class="hljs-built_in">select!</span> &#123;        () = t1 =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;任务1率先完成&quot;</span>),        () = t2 =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;任务2率先完成&quot;</span>),    &#125;&#125;</code></pre></div><p>上面的代码会同时并发地运行 t1 和 t2， 无论两者哪个先完成，都会调用对应的 println! 打印相应的输出，然后函数结束且不会等待另一个任务的完成。</p><p>但是，在实际项目中，我们往往需要等待多个任务都完成后，再结束，像上面这种其中一个任务结束就立刻结束的场景着实不多。</p><h2 id="5-3-1-default-和-complete"><a href="#5-3-1-default-和-complete" class="headerlink" title="5.3.1 default 和 complete"></a>5.3.1 default 和 complete</h2><p>select!还支持 default 和 complete 分支:</p><ul><li>complete 分支当所有的 Future 和 Stream 完成后才会被执行，它往往配合 loop 使用，loop 用于循环完成所有的 Future</li><li>default 分支，若没有任何 Future 或 Stream 处于 Ready 状态， 则该分支会被立即执行</li></ul><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::future;<span class="hljs-keyword">use</span> futures::select;<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a_fut</span> = future::<span class="hljs-title function_ invoke__">ready</span>(<span class="hljs-number">4</span>);    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b_fut</span> = future::<span class="hljs-title function_ invoke__">ready</span>(<span class="hljs-number">6</span>);    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">total</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">loop</span> &#123;        <span class="hljs-built_in">select!</span> &#123;            a = a_fut =&gt; total += a,            b = b_fut =&gt; total += b,            complete =&gt; <span class="hljs-keyword">break</span>,            default =&gt; <span class="hljs-built_in">panic!</span>(), <span class="hljs-comment">// 该分支永远不会运行，因为 `Future` 会先运行，然后是 `complete`</span>        &#125;;    &#125;    <span class="hljs-built_in">assert_eq!</span>(total, <span class="hljs-number">10</span>);&#125;</code></pre></div><p>default 分支由于最后一个运行，而在它之前 complete 分支已经通过 break 跳出了循环，因此 default 永远不会被执行。</p><p>如果你希望 default 也有机会露下脸，可以将 complete 的 break 修改为其它的，例如 println!(“completed!”)，然后再观察下运行结果。</p><p>select 的第一个例子中，里面有一段代码长这样：</p><div class="code-wrapper"><pre><code class="hljs mipsasm">let <span class="hljs-built_in">t1</span> = task_one().fuse();let <span class="hljs-built_in">t2</span> = task_two().fuse();pin_mut!(<span class="hljs-built_in">t1</span>, <span class="hljs-built_in">t2</span>);</code></pre></div><h2 id="5-3-2-跟-Unpin-和-FusedFuture-进行交互"><a href="#5-3-2-跟-Unpin-和-FusedFuture-进行交互" class="headerlink" title="5.3.2 跟 Unpin 和 FusedFuture 进行交互"></a>5.3.2 跟 Unpin 和 FusedFuture 进行交互</h2><p>首先，.fuse() 方法可以让 Future 实现 FusedFuture 特征， 而 pin_mut! 宏会为 Future 实现 Unpin 特征，这两个特征恰恰是使用 select 所必须的:</p><ul><li>Unpin，由于 select 不会通过拿走所有权的方式使用 Future，而是通过可变引用的方式去使用，这样当 select 结束后，该 Future 若没有被完成，它的所有权还可以继续被其它代码使用。</li><li>FusedFuture 的原因跟上面类似，当 Future 一旦完成后，那 select 就不能再对其进行轮询使用。Fuse 意味着熔断，相当于 Future 一旦完成，再次调用 poll 会直接返回 Poll::Pending。</li></ul><p>只有实现了 FusedFuture，select 才能配合 loop 一起使用。假如没有实现，就算一个 Future 已经完成了，它依然会被 select 不停的轮询执行。</p><p>Stream 稍有不同，它们使用的特征是 FusedStream。 通过 .fuse()(也可以手动实现)实现了该特征的 Stream，对其调用 .next() 或 .try_next() 方法可以获取实现了 FusedFuture 特征的Future:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::&#123;    stream::&#123;Stream, StreamExt, FusedStream&#125;,    select,&#125;;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_two_streams</span>(    <span class="hljs-keyword">mut</span> s1: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Stream</span>&lt;Item = <span class="hljs-type">u8</span>&gt; + FusedStream + Unpin,    <span class="hljs-keyword">mut</span> s2: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Stream</span>&lt;Item = <span class="hljs-type">u8</span>&gt; + FusedStream + Unpin,) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">total</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">loop</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">item</span> = <span class="hljs-built_in">select!</span> &#123;            x = s1.<span class="hljs-title function_ invoke__">next</span>() =&gt; x,            x = s2.<span class="hljs-title function_ invoke__">next</span>() =&gt; x,            complete =&gt; <span class="hljs-keyword">break</span>,        &#125;;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(next_num) = item &#123;            total += next_num;        &#125;    &#125;    total&#125;</code></pre></div><h2 id="5-4-在-select-循环中并发"><a href="#5-4-在-select-循环中并发" class="headerlink" title="5.4 在 select 循环中并发"></a>5.4 在 select 循环中并发</h2><p>一个很实用但又鲜为人知的函数是 Fuse::terminated() ，可以使用它构建一个空的 Future ，空自然没啥用，但是如果它能在后面再被填充呢？</p><p>考虑以下场景：当你要在 select 循环中运行一个任务，但是该任务却是在 select 循环内部创建时，上面的函数就非常好用了。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::&#123;    future::&#123;Fuse, FusedFuture, FutureExt&#125;,    stream::&#123;FusedStream, Stream, StreamExt&#125;,    pin_mut,    select,&#125;;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_new_num</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-number">5</span> &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_on_new_num</span>(_: <span class="hljs-type">u8</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_loop</span>(    <span class="hljs-keyword">mut</span> interval_timer: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Stream</span>&lt;Item = ()&gt; + FusedStream + Unpin,    starting_num: <span class="hljs-type">u8</span>,) &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">run_on_new_num_fut</span> = <span class="hljs-title function_ invoke__">run_on_new_num</span>(starting_num).<span class="hljs-title function_ invoke__">fuse</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">get_new_num_fut</span> = Fuse::<span class="hljs-title function_ invoke__">terminated</span>();    pin_mut!(run_on_new_num_fut, get_new_num_fut);    <span class="hljs-keyword">loop</span> &#123;        <span class="hljs-built_in">select!</span> &#123;            () = interval_timer.<span class="hljs-title function_ invoke__">select_next_some</span>() =&gt; &#123;                <span class="hljs-comment">// 定时器已结束，若`get_new_num_fut`没有在运行，就创建一个新的</span>                <span class="hljs-keyword">if</span> get_new_num_fut.<span class="hljs-title function_ invoke__">is_terminated</span>() &#123;                    get_new_num_fut.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-title function_ invoke__">get_new_num</span>().<span class="hljs-title function_ invoke__">fuse</span>());                &#125;            &#125;,            new_num = get_new_num_fut =&gt; &#123;                <span class="hljs-comment">// 收到新的数字 -- 创建一个新的`run_on_new_num_fut`并丢弃掉旧的</span>                run_on_new_num_fut.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-title function_ invoke__">run_on_new_num</span>(new_num).<span class="hljs-title function_ invoke__">fuse</span>());            &#125;,            <span class="hljs-comment">// 运行 `run_on_new_num_fut`</span>            () = run_on_new_num_fut =&gt; &#123;&#125;,            <span class="hljs-comment">// 若所有任务都完成，直接 `panic`， 原因是 `interval_timer` 应该连续不断的产生值，而不是结束</span>            <span class="hljs-comment">//后，执行到 `complete` 分支</span>            complete =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;`interval_timer` completed unexpectedly&quot;</span>),        &#125;    &#125;&#125;</code></pre></div><p>当某个 Future 有多个拷贝都需要同时运行时，可以使用 FuturesUnordered 类型。下面的例子跟上个例子大体相似，但是它会将 run_on_new_num_fut 的每一个拷贝都运行到完成，而不是像之前那样一旦创建新的就终止旧的。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::&#123;    future::&#123;Fuse, FusedFuture, FutureExt&#125;,    stream::&#123;FusedStream, FuturesUnordered, Stream, StreamExt&#125;,    pin_mut,    select,&#125;;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_new_num</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-number">5</span> &#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_on_new_num</span>(_: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123; <span class="hljs-comment">/* ... */</span> <span class="hljs-number">5</span> &#125;<span class="hljs-comment">// 使用从 `get_new_num` 获取的最新数字 来运行 `run_on_new_num`</span><span class="hljs-comment">//</span><span class="hljs-comment">// 每当计时器结束后，`get_new_num` 就会运行一次，它会立即取消当前正在运行的`run_on_new_num` ,</span><span class="hljs-comment">// 并且使用新返回的值来替换</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_loop</span>(    <span class="hljs-keyword">mut</span> interval_timer: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Stream</span>&lt;Item = ()&gt; + FusedStream + Unpin,    starting_num: <span class="hljs-type">u8</span>,) &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">run_on_new_num_futs</span> = FuturesUnordered::<span class="hljs-title function_ invoke__">new</span>();    run_on_new_num_futs.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">run_on_new_num</span>(starting_num));    <span class="hljs-keyword">let</span> <span class="hljs-variable">get_new_num_fut</span> = Fuse::<span class="hljs-title function_ invoke__">terminated</span>();    pin_mut!(get_new_num_fut);    <span class="hljs-keyword">loop</span> &#123;        <span class="hljs-built_in">select!</span> &#123;            () = interval_timer.<span class="hljs-title function_ invoke__">select_next_some</span>() =&gt; &#123;                 <span class="hljs-comment">// 定时器已结束，若 `get_new_num_fut` 没有在运行，就创建一个新的</span>                <span class="hljs-keyword">if</span> get_new_num_fut.<span class="hljs-title function_ invoke__">is_terminated</span>() &#123;                    get_new_num_fut.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-title function_ invoke__">get_new_num</span>().<span class="hljs-title function_ invoke__">fuse</span>());                &#125;            &#125;,            new_num = get_new_num_fut =&gt; &#123;                 <span class="hljs-comment">// 收到新的数字 -- 创建一个新的 `run_on_new_num_fut` (并没有像之前的例子那样丢弃掉旧值)</span>                run_on_new_num_futs.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">run_on_new_num</span>(new_num));            &#125;,            <span class="hljs-comment">// 运行 `run_on_new_num_futs`, 并检查是否有已经完成的</span>            res = run_on_new_num_futs.<span class="hljs-title function_ invoke__">select_next_some</span>() =&gt; &#123;                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;run_on_new_num_fut returned &#123;:?&#125;&quot;</span>, res);            &#125;,            <span class="hljs-comment">// 若所有任务都完成，直接 `panic`， 原因是 `interval_timer` 应该连续不断的产生值，而不是结束</span>            <span class="hljs-comment">//后，执行到 `complete` 分支</span>            complete =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;`interval_timer` completed unexpectedly&quot;</span>),        &#125;    &#125;&#125;</code></pre></div><h2 id="6-一些疑难问题的解决办法"><a href="#6-一些疑难问题的解决办法" class="headerlink" title="6 一些疑难问题的解决办法"></a>6 一些疑难问题的解决办法</h2><p>async 在 Rust 依然比较新，疑难杂症少不了，而它们往往还处于活跃开发状态，短时间内无法被解决，</p><h2 id="6-1-在-async-语句块中使用"><a href="#6-1-在-async-语句块中使用" class="headerlink" title="6.1 在 async 语句块中使用 ?"></a>6.1 在 async 语句块中使用 ?</h2><p>async 语句块和 async fn 最大的区别就是前者无法显式的声明返回值，在大多数时候这都不是问题，但是当配合 ? 一起使用时，问题就有所不同:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u8</span>, <span class="hljs-type">String</span>&gt; &#123;    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">u8</span>, <span class="hljs-type">String</span>&gt; &#123;    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">fut</span> = <span class="hljs-keyword">async</span> &#123;        <span class="hljs-title function_ invoke__">foo</span>().<span class="hljs-keyword">await</span>?;        <span class="hljs-title function_ invoke__">bar</span>().<span class="hljs-keyword">await</span>?;        <span class="hljs-title function_ invoke__">Ok</span>(())    &#125;;&#125;</code></pre></div><p>以上代码编译后会报错: 原因在于编译器无法推断出 Result&lt;T, E&gt; 中的 E 的类型， 而且编译器的提示 consider giving <code>fut</code> a type 你也别傻乎乎的相信，然后尝试半天，最后无奈放弃：目前还没有办法为 async 语句块指定返回类型。</p><p>既然编译器无法推断出类型，那咱就给它更多提示，可以使用 ::&lt; … &gt; 的方式来增加类型注释：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">fut</span> = <span class="hljs-keyword">async</span> &#123;    <span class="hljs-title function_ invoke__">foo</span>().<span class="hljs-keyword">await</span>?;    <span class="hljs-title function_ invoke__">bar</span>().<span class="hljs-keyword">await</span>?;    Ok::&lt;(), <span class="hljs-type">String</span>&gt;(()) <span class="hljs-comment">// 在这一行进行显式的类型注释</span>&#125;;</code></pre></div><p>给予类型注释后此时编译器就知道 Result&lt;T, E&gt; 中的 E 的类型是 String，进而成功通过编译。</p><h2 id="6-2-async-函数和-Send-特征"><a href="#6-2-async-函数和-Send-特征" class="headerlink" title="6.2 async 函数和 Send 特征"></a>6.2 async 函数和 Send 特征</h2><p>在多线程章节我们深入讲过 Send 特征对于多线程间数据传递的重要性，对于 async fn 也是如此，它返回的 Future 能否在线程间传递的关键在于 .await 运行过程中，作用域中的变量类型是否是 Send。</p><p>学到这里，相信大家已经很清楚 Rc 无法在多线程环境使用，原因就在于它并未实现 Send 特征，那咱就用它来做例子:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<span class="hljs-meta">#[derive(Default)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NotSend</span>(Rc&lt;()&gt;);</code></pre></div><p>事实上，未实现 Send 特征的变量可以出现在 async fn 语句块中:</p><div class="code-wrapper"><pre><code class="hljs scss">async fn <span class="hljs-built_in">bar</span>() &#123;&#125;async fn <span class="hljs-built_in">foo</span>() &#123;    NotSend::<span class="hljs-built_in">default</span>();    <span class="hljs-built_in">bar</span>()<span class="hljs-selector-class">.await</span>;&#125;fn <span class="hljs-built_in">require_send</span>(_: impl Send) &#123;&#125;fn <span class="hljs-selector-tag">main</span>() &#123;    <span class="hljs-built_in">require_send</span>(foo());&#125;</code></pre></div><p>即使上面的 foo 返回的 Future 是 Send， 但是在它内部短暂的使用 NotSend 依然是安全的，原因在于它的作用域并没有影响到 .await，下面来试试声明一个变量，然后让 .await 的调用处于变量的作用域中试试:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = NotSend::<span class="hljs-title function_ invoke__">default</span>();    <span class="hljs-title function_ invoke__">bar</span>().<span class="hljs-keyword">await</span>;&#125;</code></pre></div><p>不出所料，错误如期而至:</p><p>.await在运行时处于 x 的作用域内。.await 有可能被执行器调度到另一个线程上运行，而 Rc 并没有实现 Send，因此编译器无情拒绝了咱们。</p><p>其中一个可能的解决方法是在 .await 之前就使用 std::mem::drop 释放掉 Rc，但是很可惜，截止今天，该方法依然不能解决这种问题。</p><p>语句块 { … } 在 Rust 中其实具有非常重要的作用(特别是相比其它大多数语言来说时)：可以将变量声明在语句块内，当语句块结束时，变量会自动被 Drop，这个规则可以帮助我们解决很多借用冲突问题，特别是在 NLL 出来之前。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() &#123;    &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = NotSend::<span class="hljs-title function_ invoke__">default</span>();    &#125;    <span class="hljs-title function_ invoke__">bar</span>().<span class="hljs-keyword">await</span>;&#125;</code></pre></div><p>是不是很简单？最终我们还是通过 Drop 的方式解决了这个问题，当然，还是期待未来 std::mem::drop 也能派上用场。</p><h2 id="6-3-递归使用-async-fn"><a href="#6-3-递归使用-async-fn" class="headerlink" title="6.3 递归使用 async fn"></a>6.3 递归使用 async fn</h2><p>内部实现中，async fn 被编译成一个状态机，这会导致递归使用 async fn 变得较为复杂， 因为编译后的状态机还需要包含自身。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// foo函数:</span>async fn <span class="hljs-built_in">foo</span>() &#123;    <span class="hljs-built_in">step_one</span>()<span class="hljs-selector-class">.await</span>;    <span class="hljs-built_in">step_two</span>()<span class="hljs-selector-class">.await</span>;&#125;<span class="hljs-comment">// 会被编译成类似下面的类型：</span>enum Foo &#123;    <span class="hljs-built_in">First</span>(StepOne),    <span class="hljs-built_in">Second</span>(StepTwo),&#125;<span class="hljs-comment">// 因此 recursive 函数</span>async fn <span class="hljs-built_in">recursive</span>() &#123;    <span class="hljs-built_in">recursive</span>()<span class="hljs-selector-class">.await</span>;    <span class="hljs-built_in">recursive</span>()<span class="hljs-selector-class">.await</span>;&#125;<span class="hljs-comment">// 会生成类似以下的类型</span>enum Recursive &#123;    <span class="hljs-built_in">First</span>(Recursive),    <span class="hljs-built_in">Second</span>(Recursive),&#125;</code></pre></div><p>这是典型的动态大小类型，它的大小会无限增长，因此编译器会直接报错:</p><p>只要将其使用 Box 放到堆上而不是栈上，就可以解决。</p><p>就算是使用 Box，这里也大有讲究。如果我们试图使用 Box::pin 这种方式去包裹是不行的，因为编译器自身的限制限制了我们。为了解决这种问题，我们只能将 recursive 转变成一个正常的函数，该函数返回一个使用 Box 包裹的 async 语句块：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::future::&#123;BoxFuture, FutureExt&#125;;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">recursive</span>() <span class="hljs-punctuation">-&gt;</span> BoxFuture&lt;<span class="hljs-symbol">&#x27;static</span>, ()&gt; &#123;    <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;        <span class="hljs-title function_ invoke__">recursive</span>().<span class="hljs-keyword">await</span>;        <span class="hljs-title function_ invoke__">recursive</span>().<span class="hljs-keyword">await</span>;    &#125;.<span class="hljs-title function_ invoke__">boxed</span>()&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>rust圣经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RUST圣经-高阶学习-async_await异步编程-上</title>
    <link href="/2025/02/27/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-async_await%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%E4%B8%8A/"/>
    <url>/2025/02/27/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-async_await%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Async-编程简介"><a href="#1-Async-编程简介" class="headerlink" title="1 Async 编程简介"></a>1 Async 编程简介</h2><p>异步编程是一个并发编程模型，目前主流语言基本都支持了，当然，支持的方式有所不同。异步编程允许我们同时并发运行大量的任务，却仅仅需要几个甚至一个 OS 线程或 CPU 核心，现代化的异步编程在使用体验上跟同步编程也几无区别，例如 Go 语言的 go 关键字，也包括我们后面将介绍的 async&#x2F;await 语法，该语法是 JavaScript 和 Rust 的核心特性之一。</p><h2 id="1-1-async-简介"><a href="#1-1-async-简介" class="headerlink" title="1.1 async 简介"></a>1.1 async 简介</h2><p>async 是 Rust 选择的异步编程模型，下面我们来介绍下它的优缺点，以及何时适合使用。</p><h3 id="1-1-1-async-vs-其它并发模型"><a href="#1-1-1-async-vs-其它并发模型" class="headerlink" title="1.1.1 async vs 其它并发模型"></a>1.1.1 async vs 其它并发模型</h3><p>由于并发编程在现代社会非常重要，因此每个主流语言都对自己的并发模型进行过权衡取舍和精心设计，Rust 语言也不例外。下面的列表可以帮助大家理解不同并发模型的取舍:</p><ul><li>OS 线程， 它最简单，也无需改变任何编程模型(业务&#x2F;代码逻辑)，因此非常适合作为语言的原生并发模型，我们在多线程章节也提到过，Rust 就选择了原生支持线程级的并发编程。但是，这种模型也有缺点，例如线程间的同步将变得更加困难，线程间的上下文切换损耗较大。使用线程池在一定程度上可以提升性能，但是对于 IO 密集的场景来说，线程池还是不够。</li><li>事件驱动(Event driven)， 这个名词你可能比较陌生，如果说事件驱动常常跟回调( Callback )一起使用，相信大家就恍然大悟了。这种模型性能相当的好，但最大的问题就是存在回调地狱的风险：非线性的控制流和结果处理导致了数据流向和错误传播变得难以掌控，还会导致代码可维护性和可读性的大幅降低，大名鼎鼎的 JavaScript 曾经就存在回调地狱。</li><li>协程(Coroutines) 可能是目前最火的并发模型，Go 语言的协程设计就非常优秀，这也是 Go 语言能够迅速火遍全球的杀手锏之一。协程跟线程类似，无需改变编程模型，同时，它也跟 async 类似，可以支持大量的任务并发运行。但协程抽象层次过高，导致用户无法接触到底层的细节，这对于系统编程语言和自定义异步运行时是难以接受的</li><li>actor 模型是 erlang 的杀手锏之一，它将所有并发计算分割成一个一个单元，这些单元被称为 actor ，单元之间通过消息传递的方式进行通信和数据传递，跟分布式系统的设计理念非常相像。由于 actor 模型跟现实很贴近，因此它相对来说更容易实现，但是一旦遇到流控制、失败重试等场景时，就会变得不太好用</li><li>async&#x2F;await， 该模型性能高，还能支持底层编程，同时又像线程和协程那样无需过多的改变编程模型，但有得必有失，async 模型的问题就是内部实现机制过于复杂，对于用户来说，理解和使用起来也没有线程和协程简单，好在前者的复杂性开发者们已经帮我们封装好，而理解和使用起来不够简单，正是本章试图解决的问题。</li></ul><p>总之，Rust 经过权衡取舍后，最终选择了同时提供多线程编程和 async 编程:</p><ul><li><p>前者通过标准库实现，当你无需那么高的并发时，例如需要并行计算时，可以选择它，优点是线程内的代码执行效率更高、实现更直观更简单</p></li><li><p>后者通过语言特性 + 标准库 + 三方库的方式实现，在你需要高并发、异步 I&#x2F;O 时，选择它就对了</p></li><li><p>有大量 IO 任务需要并发运行时，选 async 模型</p></li><li><p>有部分 IO 任务需要并发运行时，选多线程，如果想要降低线程创建和销毁的开销，可以使用线程池</p></li><li><p>有大量 CPU 密集任务需要并行运行时，例如并行计算，选多线程模型，且让线程数等于或者稍大于 CPU 核心数</p></li><li><p>无所谓时，统一选多线程</p></li></ul><h3 id="1-1-2-一个例子"><a href="#1-1-2-一个例子" class="headerlink" title="1.1.2 一个例子"></a>1.1.2 一个例子</h3><p>如果想并发的下载文件，你可以使用多线程如下实现:</p><div class="code-wrapper"><pre><code class="hljs lasso">fn get_two_sites() &#123;    <span class="hljs-comment">// 创建两个新线程执行任务</span>    <span class="hljs-keyword">let</span> thread_one = <span class="hljs-keyword">thread</span><span class="hljs-type">::spawn</span>(|| download(<span class="hljs-string">&quot;https://course.rs&quot;</span>));    <span class="hljs-keyword">let</span> thread_two = <span class="hljs-keyword">thread</span><span class="hljs-type">::spawn</span>(|| download(<span class="hljs-string">&quot;https://fancy.rs&quot;</span>));    <span class="hljs-comment">// 等待两个线程的完成</span>    thread_one.<span class="hljs-keyword">join</span>().expect(<span class="hljs-string">&quot;thread one panicked&quot;</span>);    thread_two.<span class="hljs-keyword">join</span>().expect(<span class="hljs-string">&quot;thread two panicked&quot;</span>);&#125;</code></pre></div><p>如果是在一个小项目中简单的去下载文件，这么写没有任何问题，但是一旦下载文件的并发请求多起来，那一个下载任务占用一个线程的模式就太重了，会很容易成为程序的瓶颈。好在，我们可以使用async的方式来解决：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> fn <span class="hljs-title">get_two_sites_async</span>()</span> &#123;    <span class="hljs-comment">// 创建两个不同的`future`，你可以把`future`理解为未来某个时刻会被执行的计划任务</span>    <span class="hljs-comment">// 当两个`future`被同时执行后，它们将并发的去下载目标页面</span>    <span class="hljs-keyword">let</span> future_one = download_async(<span class="hljs-string">&quot;https://www.foo.com&quot;</span>);    <span class="hljs-keyword">let</span> future_two = download_async(<span class="hljs-string">&quot;https://www.bar.com&quot;</span>);    <span class="hljs-comment">// 同时运行两个`future`，直至完成</span>    <span class="hljs-keyword">join</span>!(future_one, future_two);&#125;</code></pre></div><p>此时，不再有线程创建和切换的昂贵开销，所有的函数都是通过静态的方式进行分发，同时也没有任何内存分配发生。这段代码的性能简直无懈可击！</p><p>事实上，async 和多线程并不是二选一，在同一应用中，可以根据情况两者一起使用，当然，我们还可以使用其它的并发模型，例如上面提到事件驱动模型，前提是有三方库提供了相应的实现。</p><h2 id="1-2-async-await-简单入门"><a href="#1-2-async-await-简单入门" class="headerlink" title="1.2 async&#x2F;.await 简单入门"></a>1.2 async&#x2F;.await 简单入门</h2><p>async&#x2F;.await 是 Rust 内置的语言特性，可以让我们用同步的方式去编写异步的代码。</p><p>async 标记的语法块会被转换成实现了Future特征的状态机。 与同步调用阻塞当前线程不同，当Future执行并遇到阻塞时，它会让出当前线程的控制权，这样其它的Future就可以在该线程中运行，这种方式完全不会导致当前线程的阻塞。</p><p>开始之前，需要先引入 futures 包。</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[dependencies]</span><span class="hljs-attr">futures</span> = <span class="hljs-string">&quot;0.3&quot;</span></code></pre></div><p>使用 async</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> fn <span class="hljs-title">do_something</span>()</span> &#123;    println!(<span class="hljs-string">&quot;go go go !&quot;</span>);&#125;</code></pre></div><p>异步函数的返回值是一个 Future，若直接调用该函数，不会输出任何结果，因为 Future 还未被执行：</p><div class="code-wrapper"><pre><code class="hljs scss">fn <span class="hljs-selector-tag">main</span>() &#123;      <span class="hljs-built_in">do_something</span>();&#125;</code></pre></div><p>运行后，go go go并没有打印</p><p>使用 block_on 就能打印出来</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// `block_on`会阻塞当前线程直到指定的`Future`执行完成，这种阻塞当前线程以等待任务完成的方式较为简单、粗暴，</span><span class="hljs-comment">// 好在其它运行时的执行器(executor)会提供更加复杂的行为，例如将多个`future`调度到同一个线程上执行。</span><span class="hljs-keyword">use</span> futures::executor::block_on;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_world</span>() &#123;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello, world!&quot;</span>);&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">future</span> = <span class="hljs-title function_ invoke__">hello_world</span>(); <span class="hljs-comment">// 返回一个Future, 因此不会打印任何输出</span>    <span class="hljs-title function_ invoke__">block_on</span>(future); <span class="hljs-comment">// 执行`Future`并等待其运行完成，此时&quot;hello, world!&quot;会被打印输出</span>&#125;</code></pre></div><p>使用.await</p><p>上述代码的main函数中，我们使用block_on这个执行器等待Future的完成。</p><p>但是如果你要在一个async fn函数中去调用另一个async fn并等待其完成后再执行后续的代码</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::executor::block_on;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_world</span>() &#123;    <span class="hljs-title function_ invoke__">hello_cat</span>().<span class="hljs-keyword">await</span>;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello, world!&quot;</span>);&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_cat</span>() &#123;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello, kitty!&quot;</span>);&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">future</span> = <span class="hljs-title function_ invoke__">hello_world</span>();    <span class="hljs-title function_ invoke__">block_on</span>(future);&#125;</code></pre></div><p>上面代码中使用同步的代码顺序实现了异步的执行效果，非常简单、高效，而且很好理解，未来也绝对不会有回调地狱的发生。</p><p>在async fn函数中使用.await可以等待另一个异步调用的完成。但是与block_on不同，.await并不会阻塞当前的线程，而是异步的等待Future A的完成，在等待的过程中，该线程还可以继续执行其它的Future B，最终实现了并发处理的效果。</p><p>一个例子</p><p>用.await，我们可能会有如下实现：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::executor::block_on;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Song</span> &#123;    author: <span class="hljs-type">String</span>,    name: <span class="hljs-type">String</span>,&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">learn_song</span>() <span class="hljs-punctuation">-&gt;</span> Song &#123;    Song &#123;        author: <span class="hljs-string">&quot;周杰伦&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;《菊花台》&quot;</span>),    &#125;&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sing_song</span>(song: Song) &#123;    <span class="hljs-built_in">println!</span>(        <span class="hljs-string">&quot;给大家献上一首&#123;&#125;的&#123;&#125; ~ &#123;&#125;&quot;</span>,        song.author, song.name, <span class="hljs-string">&quot;菊花残，满地伤~ ~&quot;</span>    );&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dance</span>() &#123;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;唱到情深处，身体不由自主的动了起来~ ~&quot;</span>);&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">song</span> = <span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-title function_ invoke__">learn_song</span>());    <span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-title function_ invoke__">sing_song</span>(song));    <span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-title function_ invoke__">dance</span>());&#125;</code></pre></div><p>通过修改后可以提高性能</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::executor::block_on;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Song</span> &#123;    author: <span class="hljs-type">String</span>,    name: <span class="hljs-type">String</span>,&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">learn_song</span>() <span class="hljs-punctuation">-&gt;</span> Song &#123;    Song &#123;        author: <span class="hljs-string">&quot;周杰伦&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),        name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;《菊花台》&quot;</span>),    &#125;&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sing_song</span>(song: Song) &#123;    <span class="hljs-built_in">println!</span>(        <span class="hljs-string">&quot;给大家献上一首&#123;&#125;的&#123;&#125; ~ &#123;&#125;&quot;</span>,        song.author, song.name, <span class="hljs-string">&quot;菊花残，满地伤~ ~&quot;</span>    );&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dance</span>() &#123;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;唱到情深处，身体不由自主的动了起来~ ~&quot;</span>);&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">learn_and_sing</span>() &#123;    <span class="hljs-comment">// 这里使用`.await`来等待学歌的完成，但是并不会阻塞当前线程，该线程在学歌的任务`.await`后，完全可以去执行跳舞的任务</span>    <span class="hljs-keyword">let</span> <span class="hljs-variable">song</span> = <span class="hljs-title function_ invoke__">learn_song</span>().<span class="hljs-keyword">await</span>;    <span class="hljs-comment">// 唱歌必须要在学歌之后</span>    <span class="hljs-title function_ invoke__">sing_song</span>(song).<span class="hljs-keyword">await</span>;&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">async_main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">f1</span> = <span class="hljs-title function_ invoke__">learn_and_sing</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">f2</span> = <span class="hljs-title function_ invoke__">dance</span>();    <span class="hljs-comment">// `join!`可以并发的处理和等待多个`Future`，若`learn_and_sing Future`被阻塞，那`dance Future`可以拿过线程的所有权继续执行。若`dance`也变成阻塞状态，那`learn_and_sing`又可以再次拿回线程所有权，继续执行。</span>    <span class="hljs-comment">// 若两个都被阻塞，那么`async main`会变成阻塞状态，然后让出线程所有权，并将其交给`main`函数中的`block_on`执行器</span>    futures::join!(f1, f2);&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-title function_ invoke__">async_main</span>());&#125;</code></pre></div><p>学歌和唱歌具有明显的先后顺序，但是这两者都可以跟跳舞一同存在，也就是你可以在跳舞的时候学歌，也可以在跳舞的时候唱歌。如果上面代码不使用.await，而是使用block_on(learn_song())， 那在学歌时，当前线程就会阻塞，不再可以做其它任何事，包括跳舞。</p><p>.await对于实现异步编程至关重要，它允许我们在同一个线程内并发的运行多个任务，而不是一个一个先后完成。</p><h2 id="2-底层探秘-Future-执行器与任务调度"><a href="#2-底层探秘-Future-执行器与任务调度" class="headerlink" title="2 底层探秘: Future 执行器与任务调度"></a>2 底层探秘: Future 执行器与任务调度</h2><p>如果你希望能深入理解 Rust 的 async&#x2F;.await 代码是如何工作、理解运行时和性能，甚至未来想要构建自己的 async 运行时或相关工具，那么本章节终究不会辜负于你。</p><h2 id="2-1-Future-特征"><a href="#2-1-Future-特征" class="headerlink" title="2.1 Future 特征"></a>2.1 Future 特征</h2><p>Future 特征是 Rust 异步编程的核心，毕竟异步函数是异步编程的核心，而 Future 恰恰是异步函数的返回值和被执行的关键。</p><p>给出 Future 的定义：它是一个能产出值的异步计算(虽然该值可能为空，例如 () )。光看这个定义，可能会觉得很空洞，我们来看看一个简化版的 Future 特征:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">SimpleFuture</span> &#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, wake: <span class="hljs-title function_ invoke__">fn</span>()) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt;;&#125;<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Poll</span>&lt;T&gt; &#123;    <span class="hljs-title function_ invoke__">Ready</span>(T),    Pending,&#125;</code></pre></div><p>Future 需要被执行器poll(轮询)后才能运行,通过调用该方法，可以推进 Future 的进一步执行，直到被切走为止( 这里不好理解，但是你只需要知道 Future 并不能保证在一次 poll 中就被执行完，后面会详解介绍)。</p><p>在当前 poll 中， Future 可以被完成，则会返回 Poll::Ready(result) ，反之则返回 Poll::Pending， 并且安排一个 wake 函数：当未来 Future 准备好进一步执行时， 该函数会被调用，然后管理该 Future 的执行器(例如上一章节中的block_on函数)会再次调用 poll 方法，此时 Future 就可以继续执行了。</p><p>没有 wake 方法，那执行器无法知道某个 Future 是否可以继续被执行，除非执行器定期的轮询每一个 Future，确认它是否能被执行，但这种作法效率较低。而有了 wake，Future 就可以主动通知执行器，然后执行器就可以精确的执行该 Future。 这种“事件通知 -&gt; 执行”的方式要远比定期对所有 Future 进行一次全遍历来的高效。</p><p>用一个例子来说明下。考虑一个需要从 socket 读取数据的场景：如果有数据，可以直接读取数据并返回 Poll::Ready(data)， 但如果没有数据，Future 会被阻塞且不会再继续执行，此时它会注册一个 wake 函数，当 socket 数据准备好时，该函数将被调用以通知执行器：我们的 Future 已经准备好了，可以继续执行。</p><p>下面的 SocketRead 结构体就是一个 Future:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SocketRead</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;    socket: &amp;<span class="hljs-symbol">&#x27;a</span> Socket,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">SimpleFuture</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">SocketRead</span>&lt;<span class="hljs-symbol">&#x27;_</span>&gt; &#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, wake: <span class="hljs-title function_ invoke__">fn</span>()) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt; &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.socket.<span class="hljs-title function_ invoke__">has_data_to_read</span>() &#123;            <span class="hljs-comment">// socket有数据，写入buffer中并返回</span>            Poll::<span class="hljs-title function_ invoke__">Ready</span>(<span class="hljs-keyword">self</span>.socket.<span class="hljs-title function_ invoke__">read_buf</span>())        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// socket中还没数据</span>            <span class="hljs-comment">//</span>            <span class="hljs-comment">// 注册一个`wake`函数，当数据可用时，该函数会被调用，</span>            <span class="hljs-comment">// 然后当前Future的执行器会再次调用`poll`方法，此时就可以读取到数据</span>            <span class="hljs-keyword">self</span>.socket.<span class="hljs-title function_ invoke__">set_readable_callback</span>(wake);            Poll::Pending        &#125;    &#125;&#125;</code></pre></div><p>这种 Future 模型允许将多个异步操作组合在一起，同时还无需任何内存分配。不仅仅如此，如果你需要同时运行多个 Future或链式调用多个 Future ，也可以通过无内存分配的状态机实现，例如：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">SimpleFuture</span> &#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, wake: <span class="hljs-title function_ invoke__">fn</span>()) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt;;&#125;<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Poll</span>&lt;T&gt; &#123;    <span class="hljs-title function_ invoke__">Ready</span>(T),    Pending,&#125;<span class="hljs-comment">/// 一个SimpleFuture，它会并发地运行两个Future直到它们完成</span><span class="hljs-comment">///</span><span class="hljs-comment">/// 之所以可以并发，是因为两个Future的轮询可以交替进行，一个阻塞，另一个就可以立刻执行，反之亦然</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Join</span>&lt;FutureA, FutureB&gt; &#123;    <span class="hljs-comment">// 结构体的每个字段都包含一个Future，可以运行直到完成.</span>    <span class="hljs-comment">// 等到Future完成后，字段会被设置为 `None`. 这样Future完成后，就不会再被轮询</span>    a: <span class="hljs-type">Option</span>&lt;FutureA&gt;,    b: <span class="hljs-type">Option</span>&lt;FutureB&gt;,&#125;<span class="hljs-keyword">impl</span>&lt;FutureA, FutureB&gt; SimpleFuture <span class="hljs-keyword">for</span> <span class="hljs-title class_">Join</span>&lt;FutureA, FutureB&gt;<span class="hljs-keyword">where</span>    FutureA: SimpleFuture&lt;Output = ()&gt;,    FutureB: SimpleFuture&lt;Output = ()&gt;,&#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = ();    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, wake: <span class="hljs-title function_ invoke__">fn</span>()) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt; &#123;        <span class="hljs-comment">// 尝试去完成一个 Future `a`</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(a) = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.a &#123;            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Poll</span>::<span class="hljs-title function_ invoke__">Ready</span>(()) = a.<span class="hljs-title function_ invoke__">poll</span>(wake) &#123;                <span class="hljs-keyword">self</span>.a.<span class="hljs-title function_ invoke__">take</span>();            &#125;        &#125;        <span class="hljs-comment">// 尝试去完成一个 Future `b`</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(b) = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.b &#123;            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Poll</span>::<span class="hljs-title function_ invoke__">Ready</span>(()) = b.<span class="hljs-title function_ invoke__">poll</span>(wake) &#123;                <span class="hljs-keyword">self</span>.b.<span class="hljs-title function_ invoke__">take</span>();            &#125;        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.a.<span class="hljs-title function_ invoke__">is_none</span>() &amp;&amp; <span class="hljs-keyword">self</span>.b.<span class="hljs-title function_ invoke__">is_none</span>() &#123;            <span class="hljs-comment">// 两个 Future都已完成 - 我们可以成功地返回了</span>            Poll::<span class="hljs-title function_ invoke__">Ready</span>(())        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 至少还有一个 Future 没有完成任务，因此返回 `Poll::Pending`.</span>            <span class="hljs-comment">// 当该 Future 再次准备好时，通过调用`wake()`函数来继续执行</span>            Poll::Pending        &#125;    &#125;&#125;</code></pre></div><p>上面代码展示了如何同时运行多个 Future， 且在此过程中没有任何内存分配，让并发编程更加高效。 类似的，多个Future也可以一个接一个的连续运行：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">/// 一个SimpleFuture, 它使用顺序的方式，一个接一个地运行两个Future</span><span class="hljs-comment">//</span><span class="hljs-comment">// 注意: 由于本例子用于演示，因此功能简单，`AndThenFut` 会假设两个 Future 在创建时就可用了.</span><span class="hljs-comment">// 而真实的`Andthen`允许根据第一个`Future`的输出来创建第二个`Future`，因此复杂的多。</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AndThenFut</span>&lt;FutureA, FutureB&gt; &#123;    first: <span class="hljs-type">Option</span>&lt;FutureA&gt;,    second: FutureB,&#125;<span class="hljs-keyword">impl</span>&lt;FutureA, FutureB&gt; SimpleFuture <span class="hljs-keyword">for</span> <span class="hljs-title class_">AndThenFut</span>&lt;FutureA, FutureB&gt;<span class="hljs-keyword">where</span>    FutureA: SimpleFuture&lt;Output = ()&gt;,    FutureB: SimpleFuture&lt;Output = ()&gt;,&#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = ();    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, wake: <span class="hljs-title function_ invoke__">fn</span>()) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt; &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(first) = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.first &#123;            <span class="hljs-keyword">match</span> first.<span class="hljs-title function_ invoke__">poll</span>(wake) &#123;                <span class="hljs-comment">// 我们已经完成了第一个 Future， 可以将它移除， 然后准备开始运行第二个</span>                Poll::<span class="hljs-title function_ invoke__">Ready</span>(()) =&gt; <span class="hljs-keyword">self</span>.first.<span class="hljs-title function_ invoke__">take</span>(),                <span class="hljs-comment">// 第一个 Future 还不能完成</span>                Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,            &#125;;        &#125;        <span class="hljs-comment">// 运行到这里，说明第一个Future已经完成，尝试去完成第二个</span>        <span class="hljs-keyword">self</span>.second.<span class="hljs-title function_ invoke__">poll</span>(wake)    &#125;&#125;</code></pre></div><p>这些例子展示了在不需要内存对象分配以及深层嵌套回调的情况下，该如何使用 Future 特征去表达异步控制流。 在了解了基础的控制流后，我们再来看看真实的 Future 特征有何不同之处。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Future</span> &#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(        <span class="hljs-comment">// 首先值得注意的地方是，`self`的类型从`&amp;mut self`变成了`Pin&lt;&amp;mut Self&gt;`:</span>        <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;,        <span class="hljs-comment">// 其次将`wake: fn()` 修改为 `cx: &amp;mut Context&lt;&#x27;_&gt;`:</span>        cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;,    ) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt;;&#125;</code></pre></div><p>首先这里多了一个 Pin ，关于它我们会在后面章节详细介绍，现在你只需要知道使用它可以创建一个无法被移动的 Future ，因为无法被移动，所以它将具有固定的内存地址，意味着我们可以存储它的指针(如果内存地址可能会变动，那存储指针地址将毫无意义！)，也意味着可以实现一个自引用数据结构: struct MyFut { a: i32, ptr_to_a: *const i32 }。 而对于 async&#x2F;await 来说，Pin 是不可或缺的关键特性。</p><p>其次，从 wake: fn() 变成了 &amp;mut Context&lt;’_&gt; 。意味着 wake 函数可以携带数据了，为何要携带数据？考虑一个真实世界的场景，一个复杂应用例如 web 服务器可能有数千连接同时在线，那么同时就有数千 Future 在被同时管理着，如果不能携带数据，当一个 Future 调用 wake 后，执行器该如何知道是哪个 Future 调用了 wake ,然后进一步去 poll 对应的 Future ？没有办法！那之前的例子为啥就可以使用没有携带数据的 wake ？ 因为足够简单，不存在歧义性。</p><p>总之，在正式场景要进行 wake ，就必须携带上数据。 而 Context 类型通过提供一个 Waker 类型的值，就可以用来唤醒特定的的任务。</p><h2 id="2-2-使用-Waker-来唤醒任务"><a href="#2-2-使用-Waker-来唤醒任务" class="headerlink" title="2.2 使用 Waker 来唤醒任务"></a>2.2 使用 Waker 来唤醒任务</h2><p>Future 来说，第一次被 poll 时无法完成任务是很正常的。但它需要确保在未来一旦准备好时，可以通知执行器再次对其进行 poll 进而继续往下执行，该通知就是通过 Waker 类型完成的。</p><p>Waker 提供了一个 wake() 方法可以用于告诉执行器：相关的任务可以被唤醒了，此时执行器就可以对相应的 Future 再次进行 poll 操作。</p><h3 id="2-2-1-构建一个定时器"><a href="#2-2-1-构建一个定时器" class="headerlink" title="2.2.1 构建一个定时器"></a>2.2.1 构建一个定时器</h3><p>下面一起来实现一个简单的定时器 Future 。为了让例子尽量简单，当计时器创建时，我们会启动一个线程接着让该线程进入睡眠，等睡眠结束后再通知给 Future 。</p><p>本例子还会在后面继续使用，因此我们重新创建一个工程来演示：使用 cargo new –lib timer_future 来创建一个新工程，在 lib 包的根路径 src&#x2F;lib.rs 中添加以下内容：</p><div class="code-wrapper"><pre><code class="hljs cpp">use std::&#123;    future::Future,    pin::Pin,    sync::&#123;Arc, Mutex&#125;,    task::&#123;Context, Poll, Waker&#125;,    thread,    time::Duration,&#125;;</code></pre></div><p>继续来实现 Future 定时器，之前提到: 新建线程在睡眠结束后会需要将状态同步给定时器 Future ，由于是多线程环境，我们需要使用 Arc&lt;Mutex<T>&gt; 来作为一个共享状态，用于在新线程和 Future 定时器间共享。</p><div class="code-wrapper"><pre><code class="hljs gauss">pub <span class="hljs-keyword">struct</span> <span class="hljs-type">TimerFuture</span> &#123;    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,&#125;<span class="hljs-comment">/// 在Future和等待的线程间共享状态</span><span class="hljs-keyword">struct</span> <span class="hljs-type">SharedState</span> &#123;    <span class="hljs-comment">/// 定时(睡眠)是否结束</span>    completed: <span class="hljs-keyword">bool</span>,    <span class="hljs-comment">/// 当睡眠结束后，线程可以用`waker`通知`TimerFuture`来唤醒任务</span>    waker: Option&lt;Waker&gt;,&#125;</code></pre></div><p>下面给出 Future 的具体实现:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">TimerFuture</span> &#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = ();    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt; &#123;        <span class="hljs-comment">// 通过检查共享状态，来确定定时器是否已经完成</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">shared_state</span> = <span class="hljs-keyword">self</span>.shared_state.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();        <span class="hljs-keyword">if</span> shared_state.completed &#123;            Poll::<span class="hljs-title function_ invoke__">Ready</span>(())        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 设置`waker`，这样新线程在睡眠(计时)结束后可以唤醒当前的任务，接着再次对`Future`进行`poll`操作,</span>            <span class="hljs-comment">//</span>            <span class="hljs-comment">// 下面的`clone`每次被`poll`时都会发生一次，实际上，应该是只`clone`一次更加合理。</span>            <span class="hljs-comment">// 选择每次都`clone`的原因是： `TimerFuture`可以在执行器的不同任务间移动，如果只克隆一次，</span>            <span class="hljs-comment">// 那么获取到的`waker`可能已经被篡改并指向了其它任务，最终导致执行器运行了错误的任务</span>            shared_state.waker = <span class="hljs-title function_ invoke__">Some</span>(cx.<span class="hljs-title function_ invoke__">waker</span>().<span class="hljs-title function_ invoke__">clone</span>());            Poll::Pending        &#125;    &#125;&#125;</code></pre></div><p>代码很简单，只要新线程设置了 shared_state.completed &#x3D; true ，那任务就能顺利结束。如果没有设置，会为当前的任务克隆一份 Waker ，这样新线程就可以使用它来唤醒当前的任务。</p><p>最后，再来创建一个 API 用于构建定时器和启动计时线程:</p><div class="code-wrapper"><pre><code class="hljs lasso">impl TimerFuture &#123;    <span class="hljs-comment">/// 创建一个新的`TimerFuture`，在指定的时间结束后，该`Future`可以完成</span>    pub fn <span class="hljs-literal">new</span>(<span class="hljs-built_in">duration</span>: <span class="hljs-built_in">Duration</span>) -&gt; <span class="hljs-built_in">Self</span> &#123;        <span class="hljs-keyword">let</span> shared_state = Arc<span class="hljs-type">::new</span>(Mutex<span class="hljs-type">::new</span>(SharedState &#123;            completed: <span class="hljs-literal">false</span>,            waker: <span class="hljs-literal">None</span>,        &#125;));        <span class="hljs-comment">// 创建新线程</span>        <span class="hljs-keyword">let</span> thread_shared_state = shared_state.clone();        <span class="hljs-keyword">thread</span><span class="hljs-type">::spawn</span>(move || &#123;            <span class="hljs-comment">// 睡眠指定时间实现计时功能</span>            <span class="hljs-keyword">thread</span><span class="hljs-type">::sleep</span>(<span class="hljs-built_in">duration</span>);            <span class="hljs-keyword">let</span> mut shared_state = thread_shared_state.lock().unwrap();            <span class="hljs-comment">// 通知执行器定时器已经完成，可以继续`poll`对应的`Future`了</span>            shared_state.completed = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> Some(waker) = shared_state.waker.<span class="hljs-keyword">take</span>() &#123;                waker.wake()            &#125;        &#125;);        TimerFuture &#123; shared_state &#125;    &#125;&#125;</code></pre></div><p>至此，一个简单的定时器 Future 就已创建成功，那么该如何使用它呢？相信部分爱动脑筋的读者已经猜到了：我们需要创建一个执行器，才能让程序动起来。</p><h2 id="2-3-执行器-Executor"><a href="#2-3-执行器-Executor" class="headerlink" title="2.3 执行器 Executor"></a>2.3 执行器 Executor</h2><p>Rust 的 Future 是惰性的。其中一个推动它的方式就是在 async 函数中使用 .await 来调用另一个 async 函数，但是这个只能解决 async 内部的问题，那么这些最外层的 async 函数，谁来推动它们运行呢？答案就是我们之前多次提到的执行器 executor 。</p><p>执行器会管理一批 Future (最外层的 async 函数)，然后通过不停地 poll 推动它们直到完成。 最开始，执行器会先 poll 一次 Future ，后面就不会主动去 poll 了，而是等待 Future 通过调用 wake 函数来通知它可以继续，它才会继续去 poll 。这种 wake 通知然后 poll 的方式会不断重复，直到 Future 完成。</p><h3 id="2-3-1-构建执行器"><a href="#2-3-1-构建执行器" class="headerlink" title="2.3.1 构建执行器"></a>2.3.1 构建执行器</h3><p>下面我们将实现一个简单的执行器，它可以同时并发运行多个 Future 。例子中，需要用到 futures 包的 ArcWake 特征，它可以提供一个方便的途径去构建一个 Waker 。编辑 Cargo.toml ，添加下面依赖:</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-section">[dependencies]</span><span class="hljs-attr">futures</span> = <span class="hljs-string">&quot;0.3&quot;</span></code></pre></div><p>在之前的内容中，我们在 src&#x2F;lib.rs 中创建了定时器 Future ，现在在 src&#x2F;main.rs 中来创建程序的主体内容，开始之前，先引入所需的包：</p><div class="code-wrapper"><pre><code class="hljs cpp">use &#123;    futures::&#123;        future::&#123;BoxFuture, FutureExt&#125;,        task::&#123;waker_ref, ArcWake&#125;,    &#125;,    std::&#123;        future::Future,        sync::mpsc::&#123;sync_channel, Receiver, SyncSender&#125;,        sync::&#123;Arc, Mutex&#125;,        task::&#123;Context, Poll&#125;,        time::Duration,    &#125;,    <span class="hljs-comment">// 引入之前实现的定时器模块</span>    timer_future::TimerFuture,&#125;;</code></pre></div><p>执行器需要从一个消息通道( channel )中拉取事件，然后运行它们。当一个任务准备好后（可以继续执行），它会将自己放入消息通道中，然后等待执行器 poll 。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">/// 任务执行器，负责从通道中接收任务然后执行</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Executor</span> &#123;    ready_queue: <span class="hljs-type">Receiver</span>&lt;<span class="hljs-type">Arc</span>&lt;<span class="hljs-type">Task</span>&gt;&gt;,&#125;<span class="hljs-comment">/// `Spawner`负责创建新的`Future`然后将它发送到任务通道中</span>#[derive(<span class="hljs-type">Clone</span>)]<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Spawner</span> &#123;    task_sender: <span class="hljs-type">SyncSender</span>&lt;<span class="hljs-type">Arc</span>&lt;<span class="hljs-type">Task</span>&gt;&gt;,&#125;<span class="hljs-comment">/// 一个Future，它可以调度自己(将自己放入任务通道中)，然后等待执行器去`poll`</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> &#123;    <span class="hljs-comment">/// 进行中的Future，在未来的某个时间点会被完成</span>    <span class="hljs-comment">///</span>    <span class="hljs-comment">/// 按理来说`Mutex`在这里是多余的，因为我们只有一个线程来执行任务。但是由于</span>    <span class="hljs-comment">/// Rust并不聪明，它无法知道`Future`只会在一个线程内被修改，并不会被跨线程修改。因此</span>    <span class="hljs-comment">/// 我们需要使用`Mutex`来满足这个笨笨的编译器对线程安全的执着。</span>    <span class="hljs-comment">///</span>    <span class="hljs-comment">/// 如果是生产级的执行器实现，不会使用`Mutex`，因为会带来性能上的开销，取而代之的是使用`UnsafeCell`</span>    future: <span class="hljs-type">Mutex</span>&lt;<span class="hljs-type">Option</span>&lt;<span class="hljs-type">BoxFuture</span>&lt;&#x27;<span class="hljs-keyword">static</span>, ()&gt;&gt;&gt;,    <span class="hljs-comment">/// 可以将该任务自身放回到任务通道中，等待执行器的poll</span>    task_sender: <span class="hljs-type">SyncSender</span>&lt;<span class="hljs-type">Arc</span>&lt;<span class="hljs-type">Task</span>&gt;&gt;,&#125;fn new_executor_and_spawner() -&gt; (<span class="hljs-type">Executor</span>, <span class="hljs-type">Spawner</span>) &#123;    <span class="hljs-comment">// 任务通道允许的最大缓冲数(任务队列的最大长度)</span>    <span class="hljs-comment">// 当前的实现仅仅是为了简单，在实际的执行中，并不会这么使用</span>    const <span class="hljs-type">MAX_QUEUED_TASKS</span>: usize <span class="hljs-operator">=</span> <span class="hljs-number">10_000</span>;    <span class="hljs-keyword">let</span> (task_sender, ready_queue) <span class="hljs-operator">=</span> sync_channel(<span class="hljs-type">MAX_QUEUED_TASKS</span>);    (<span class="hljs-type">Executor</span> &#123; ready_queue &#125;, <span class="hljs-type">Spawner</span> &#123; task_sender &#125;)&#125;</code></pre></div><p>下面再来添加一个方法用于生成 Future , 然后将它放入任务通道中:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Spawner</span> &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">spawn</span>(&amp;<span class="hljs-keyword">self</span>, future: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = ()&gt; + <span class="hljs-symbol">&#x27;static</span> + <span class="hljs-built_in">Send</span>) &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">future</span> = future.<span class="hljs-title function_ invoke__">boxed</span>();        <span class="hljs-keyword">let</span> <span class="hljs-variable">task</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Task &#123;            future: Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Some</span>(future)),            task_sender: <span class="hljs-keyword">self</span>.task_sender.<span class="hljs-title function_ invoke__">clone</span>(),        &#125;);        <span class="hljs-keyword">self</span>.task_sender.<span class="hljs-title function_ invoke__">send</span>(task).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;任务队列已满&quot;</span>);    &#125;&#125;</code></pre></div><p>在执行器 poll 一个 Future 之前，首先需要调用 wake 方法进行唤醒，然后再由 Waker 负责调度该任务并将其放入任务通道中。创建 Waker 的最简单的方式就是实现 ArcWake 特征，先来为我们的任务实现 ArcWake 特征，这样它们就能被转变成 Waker 然后被唤醒:</p><div class="code-wrapper"><pre><code class="hljs autohotkey">impl ArcWake for Task &#123;<span class="hljs-title">    fn wake_by_ref(arc_self:</span> &amp;Arc&lt;Self&gt;) &#123;        // 通过发送任务到任务管道的方式来实现`wake`，这样`wake`后，任务就能被执行器`poll`        let cloned = arc_self.clone()<span class="hljs-comment">;</span>        arc_self            .task_sender            .send(cloned)            .expect(<span class="hljs-string">&quot;任务队列已满&quot;</span>)<span class="hljs-comment">;</span>    &#125;&#125;</code></pre></div><p>当任务实现了 ArcWake 特征后，它就变成了 Waker ，在调用 wake() 对其唤醒后会将任务复制一份所有权( Arc )，然后将其发送到任务通道中。最后我们的执行器将从通道中获取任务，然后进行 poll 执行：</p><div class="code-wrapper"><pre><code class="hljs javascript">impl <span class="hljs-title class_">Executor</span> &#123;    fn <span class="hljs-title function_">run</span>(<span class="hljs-params">&amp;self</span>) &#123;        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-title class_">Ok</span>(task) = self.<span class="hljs-property">ready_queue</span>.<span class="hljs-title function_">recv</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-comment">// 获取一个future，若它还没有完成(仍然是Some，不是None)，则对它进行一次poll并尝试完成它</span>            <span class="hljs-keyword">let</span> mut future_slot = task.<span class="hljs-property">future</span>.<span class="hljs-title function_">lock</span>().<span class="hljs-title function_">unwrap</span>();            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-title class_">Some</span>(mut future) = future_slot.<span class="hljs-title function_">take</span>(<span class="hljs-params"></span>) &#123;                <span class="hljs-comment">// 基于任务自身创建一个 `LocalWaker`</span>                <span class="hljs-keyword">let</span> waker = <span class="hljs-title function_">waker_ref</span>(&amp;task);                <span class="hljs-keyword">let</span> context = &amp;mut <span class="hljs-title class_">Context</span>::<span class="hljs-title function_">from_waker</span>(&amp;*waker);                <span class="hljs-comment">// `BoxFuture&lt;T&gt;`是`Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + &#x27;static&gt;&gt;`的类型别名</span>                <span class="hljs-comment">// 通过调用`as_mut`方法，可以将上面的类型转换成`Pin&lt;&amp;mut dyn Future + Send + &#x27;static&gt;`</span>                <span class="hljs-keyword">if</span> future.<span class="hljs-title function_">as_mut</span>().<span class="hljs-title function_">poll</span>(context).<span class="hljs-title function_">is_pending</span>(<span class="hljs-params"></span>) &#123;                    <span class="hljs-comment">// Future还没执行完，因此将它放回任务中，等待下次被poll</span>                    *future_slot = <span class="hljs-title class_">Some</span>(future);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>恭喜！我们终于拥有了自己的执行器，下面再来写一段代码使用该执行器去运行之前的定时器 Future ：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> (executor, spawner) = <span class="hljs-title function_ invoke__">new_executor_and_spawner</span>();    <span class="hljs-comment">// 生成一个任务</span>    spawner.<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;howdy!&quot;</span>);        <span class="hljs-comment">// 创建定时器Future，并等待它完成</span>        TimerFuture::<span class="hljs-title function_ invoke__">new</span>(Duration::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)).<span class="hljs-keyword">await</span>;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;done!&quot;</span>);    &#125;);    <span class="hljs-comment">// drop掉任务，这样执行器就知道任务已经完成，不会再有新的任务进来</span>    <span class="hljs-title function_ invoke__">drop</span>(spawner);    <span class="hljs-comment">// 运行执行器直到任务队列为空</span>    <span class="hljs-comment">// 任务运行后，会先打印`howdy!`, 暂停2秒，接着打印 `done!`</span>    executor.<span class="hljs-title function_ invoke__">run</span>();&#125;</code></pre></div><h2 id="2-4-执行器和系统-IO"><a href="#2-4-执行器和系统-IO" class="headerlink" title="2.4 执行器和系统 IO"></a>2.4 执行器和系统 IO</h2><p>前面我们一起看过一个使用 Future 从 Socket 中异步读取数据的例子:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SocketRead</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;    socket: &amp;<span class="hljs-symbol">&#x27;a</span> Socket,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">SimpleFuture</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">SocketRead</span>&lt;<span class="hljs-symbol">&#x27;_</span>&gt; &#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, wake: <span class="hljs-title function_ invoke__">fn</span>()) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt; &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.socket.<span class="hljs-title function_ invoke__">has_data_to_read</span>() &#123;            <span class="hljs-comment">// socket有数据，写入buffer中并返回</span>            Poll::<span class="hljs-title function_ invoke__">Ready</span>(<span class="hljs-keyword">self</span>.socket.<span class="hljs-title function_ invoke__">read_buf</span>())        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// socket中还没数据</span>            <span class="hljs-comment">//</span>            <span class="hljs-comment">// 注册一个`wake`函数，当数据可用时，该函数会被调用，</span>            <span class="hljs-comment">// 然后当前Future的执行器会再次调用`poll`方法，此时就可以读取到数据</span>            <span class="hljs-keyword">self</span>.socket.<span class="hljs-title function_ invoke__">set_readable_callback</span>(wake);            Poll::Pending        &#125;    &#125;&#125;</code></pre></div><p>例子中，Future 将从 Socket 读取数据，若当前还没有数据，则会让出当前线程的所有权，允许执行器去执行其它的 Future 。当数据准备好后，会调用 wake() 函数将该 Future 的任务放入任务通道中，等待执行器的 poll 。</p><p>关于该流程已经反复讲了很多次，相信大家应该非常清楚了。然而该例子中还有一个疑问没有解决：</p><ul><li>set_readable_callback 方法到底是怎么工作的？怎么才能知道 socket 中的数据已经可以被读取了？</li></ul><p>关于第二点，其中一个简单粗暴的方法就是使用一个新线程不停的检查 socket 中是否有了数据，当有了后，就调用 wake() 函数。该方法确实可以满足需求，但是性能着实太低了，需要为每个阻塞的 Future 都创建一个单独的线程！</p><p>现实世界中，该问题往往是通过操作系统提供的 IO 多路复用机制来完成，例如 Linux 中的 epoll，FreeBSD 和 macOS 中的 kqueue ，Windows 中的 IOCP, Fuchisa中的 ports 等(可以通过 Rust 的跨平台包 mio 来使用它们)。借助 IO 多路复用机制，可以实现一个线程同时阻塞地去等待多个异步 IO 事件，一旦某个事件完成就立即退出阻塞并返回数据。相关实现类似于以下代码：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IoBlocker</span> &#123;    <span class="hljs-comment">/* ... */</span>&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Event</span> &#123;    <span class="hljs-comment">// Event的唯一ID，该事件发生后，就会被监听起来</span>    id: <span class="hljs-type">usize</span>,    <span class="hljs-comment">// 一组需要等待或者已发生的信号</span>    signals: Signals,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">IoBlocker</span> &#123;    <span class="hljs-comment">/// 创建需要阻塞等待的异步IO事件的集合</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;    <span class="hljs-comment">/// 对指定的IO事件表示兴趣</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_io_event_interest</span>(        &amp;<span class="hljs-keyword">self</span>,        <span class="hljs-comment">/// 事件所绑定的socket</span>        io_object: &amp;IoObject,        event: Event,    ) &#123; <span class="hljs-comment">/* ... */</span> &#125;    <span class="hljs-comment">/// 进入阻塞，直到某个事件出现</span>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">block</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Event &#123; <span class="hljs-comment">/* ... */</span> &#125;&#125;<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">io_blocker</span> = IoBlocker::<span class="hljs-title function_ invoke__">new</span>();io_blocker.<span class="hljs-title function_ invoke__">add_io_event_interest</span>(    &amp;socket_1,    Event &#123; id: <span class="hljs-number">1</span>, signals: READABLE &#125;,);io_blocker.<span class="hljs-title function_ invoke__">add_io_event_interest</span>(    &amp;socket_2,    Event &#123; id: <span class="hljs-number">2</span>, signals: READABLE | WRITABLE &#125;,);<span class="hljs-keyword">let</span> <span class="hljs-variable">event</span> = io_blocker.<span class="hljs-title function_ invoke__">block</span>();<span class="hljs-comment">// 当socket的数据可以读取时，打印 &quot;Socket 1 is now READABLE&quot;</span><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Socket &#123;:?&#125; is now &#123;:?&#125;&quot;</span>, event.id, event.signals);</code></pre></div><p>这样，我们只需要一个执行器线程，它会接收 IO 事件并将其分发到对应的 Waker 中，接着后者会唤醒相关的任务，最终通过执行器 poll 后，任务可以顺利地继续执行, 这种 IO 读取流程可以不停的循环，直到 socket 关闭。</p><h2 id="3-定海神针-Pin-和-Unpin"><a href="#3-定海神针-Pin-和-Unpin" class="headerlink" title="3 定海神针 Pin 和 Unpin"></a>3 定海神针 Pin 和 Unpin</h2><p>在 Rust 异步编程中，有一个定海神针般的存在，它就是 Pin，作用说简单也简单，说复杂也非常复杂，当初刚出来时就连一些 Rust 大佬都一头雾水，何况瑟瑟发抖的我。好在今非昔比，目前网上的资料已经很全，而我就借花献佛，给大家好好讲讲这个 Pin。</p><p>在 Rust 中，所有的类型可以分为两类:</p><ul><li>类型的值可以在内存中安全地被移动，例如数值、字符串、布尔值、结构体、枚举，总之你能想到的几乎所有类型都可以落入到此范畴内</li><li>自引用类型，大魔王来了，大家快跑，在之前章节我们已经见识过它的厉害</li></ul><p>下面就是一个自引用类型</p><div class="code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">SelfRef</span> &#123;    value: <span class="hljs-keyword">String</span>,    pointer_to_value: *mut <span class="hljs-keyword">String</span>,&#125;</code></pre></div><p>pointer_to_value 是一个裸指针，指向第一个字段 value 持有的字符串 String 。很简单对吧？现在考虑一个情况， 若 value 被移动了怎么办？</p><p>一个致命的问题就出现了：value 的内存地址变了，而 pointer_to_value 依然指向 value 之前的地址，一个重大 bug 就出现了！</p><p>Pin 闪亮登场，它可以防止一个类型在内存中被移动。再来回忆下之前在 Future 章节中，我们提到过在 poll 方法的签名中有一个 self: Pin&lt;&amp;mut Self&gt; ，那么为何要在这里使用 Pin 呢？</p><h2 id="3-1-为何需要-Pin"><a href="#3-1-为何需要-Pin" class="headerlink" title="3.1 为何需要 Pin"></a>3.1 为何需要 Pin</h2><p>Pin 还有一个小伙伴 UnPin ，与前者相反，后者表示类型可以在内存中安全地移动。在深入之前，我们先来回忆下 async&#x2F;.await 是如何工作的:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">fut_one</span> = <span class="hljs-comment">/* ... */</span>; <span class="hljs-comment">// Future 1</span><span class="hljs-keyword">let</span> <span class="hljs-variable">fut_two</span> = <span class="hljs-comment">/* ... */</span>; <span class="hljs-comment">// Future 2</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;    fut_one.<span class="hljs-keyword">await</span>;    fut_two.<span class="hljs-keyword">await</span>;&#125;</code></pre></div><p>在底层，async 会创建一个实现了 Future 的匿名类型，并提供了一个 poll 方法：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// `async &#123; ... &#125;`语句块创建的 `Future` 类型</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AsyncFuture</span> &#123;    fut_one: FutOne,    fut_two: FutTwo,    state: State,&#125;<span class="hljs-comment">// `async` 语句块可能处于的状态</span><span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;    AwaitingFutOne,    AwaitingFutTwo,    Done,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AsyncFuture</span> &#123;    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = ();    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> Poll&lt;()&gt; &#123;        <span class="hljs-keyword">loop</span> &#123;            <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.state &#123;                State::AwaitingFutOne =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.fut_one.<span class="hljs-title function_ invoke__">poll</span>(..) &#123;                    Poll::<span class="hljs-title function_ invoke__">Ready</span>(()) =&gt; <span class="hljs-keyword">self</span>.state = State::AwaitingFutTwo,                    Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,                &#125;                State::AwaitingFutTwo =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.fut_two.<span class="hljs-title function_ invoke__">poll</span>(..) &#123;                    Poll::<span class="hljs-title function_ invoke__">Ready</span>(()) =&gt; <span class="hljs-keyword">self</span>.state = State::Done,                    Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,                &#125;                State::Done =&gt; <span class="hljs-keyword">return</span> Poll::<span class="hljs-title function_ invoke__">Ready</span>(()),            &#125;        &#125;    &#125;&#125;</code></pre></div><p>当 poll 第一次被调用时，它会去查询 fut_one 的状态，若 fut_one 无法完成，则 poll 方法会返回。未来对 poll 的调用将从上一次调用结束的地方开始。该过程会一直持续，直到 Future 完成为止。</p><p>然而，如果我们的 async 语句块中使用了引用类型，会发生什么？例如下面例子：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = [<span class="hljs-number">0</span>; <span class="hljs-number">128</span>];    <span class="hljs-keyword">let</span> <span class="hljs-variable">read_into_buf_fut</span> = <span class="hljs-title function_ invoke__">read_into_buf</span>(&amp;<span class="hljs-keyword">mut</span> x);    read_into_buf_fut.<span class="hljs-keyword">await</span>;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, x);&#125;</code></pre></div><p>这段代码会编译成下面的形式：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ReadIntoBuf</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;buf: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>], <span class="hljs-comment">// 指向下面的`x`字段</span>&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AsyncFuture</span> &#123;x: [<span class="hljs-type">u8</span>; <span class="hljs-number">128</span>],read_into_buf_fut: ReadIntoBuf&lt;<span class="hljs-symbol">&#x27;what_lifetime</span>?&gt;,&#125;</code></pre></div><p>这里，ReadIntoBuf 拥有一个引用字段，指向了结构体的另一个字段 x ，一旦 AsyncFuture 被移动，那 x 的地址也将随之变化，此时对 x 的引用就变成了不合法的，也就是 read_into_buf_fut.buf 会变为不合法的。</p><p>若能将 Future 在内存中固定到一个位置，就可以避免这种问题的发生，也就可以安全的创建上面这种引用类型。</p><h2 id="3-2-Unpin"><a href="#3-2-Unpin" class="headerlink" title="3.2 Unpin"></a>3.2 Unpin</h2><p>绝大多数类型都不在意是否被移动(开篇提到的第一种类型)，因此它们都自动实现了 Unpin 特征。</p><p>大家可能以为 Pin 和 Unpin 都是特征吧？实际上，Pin 不按套路出牌，它是一个结构体：</p><div class="code-wrapper"><pre><code class="hljs crystal">pub <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pin</span>&lt;<span class="hljs-title">P</span>&gt; &#123;</span>    <span class="hljs-symbol">pointer:</span> P,&#125;</code></pre></div><p>它包裹一个指针，并且能确保该指针指向的数据不会被移动，例如 Pin&lt;&amp;mut T&gt; , Pin&lt;&amp;T&gt; , Pin&lt;Box<T>&gt; ，都能确保 T 不会被移动。</p><p><img src="/2025/02/27/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-async_await%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%E4%B8%8A/1.png"></p><p>而 Unpin 才是一个特征，它表明一个类型可以随意被移动，可以被 Pin 住的值，它有没有实现什么特征呢？ 答案很出乎意料，可以被 Pin 住的值实现的特征是 !Unpin ，大家可能之前没有见过，但是它其实很简单，! 代表没有实现某个特征的意思，!Unpin 说明类型没有实现 Unpin 特征，那自然就可以被 Pin 了。</p><p>那是不是意味着类型如果实现了 Unpin 特征，就不能被 Pin 了？其实，还是可以 Pin 的，毕竟它只是一个结构体，你可以随意使用，但是不再有任何效果而已，该值一样可以被移动！</p><p>例如 Pin&lt;&amp;mut u8&gt; ，显然 u8 实现了 Unpin 特征，它可以在内存中被移动，因此 Pin&lt;&amp;mut u8&gt; 跟 &amp;mut u8 实际上并无区别，一样可以被移动。</p><p>一个类型如果不能被移动，它必须实现 !Unpin 特征。</p><p>将 Unpin 与之前章节学过的 Send&#x2F;Sync 进行下对比，会发现它们都很像：</p><ul><li>都是标记特征( marker trait )，该特征未定义任何行为，非常适用于标记</li><li>都可以通过!语法去除实现</li><li>绝大多数情况都是自动实现, 无需我们的操心</li></ul><h2 id="3-3-深入理解-Pin"><a href="#3-3-深入理解-Pin" class="headerlink" title="3.3 深入理解 Pin"></a>3.3 深入理解 Pin</h2><p>对于上面的问题，我们可以简单的归结为如何在 Rust 中处理自引用类型(果然，只要是难点，都和自引用脱离不了关系)，下面用一个稍微简单点的例子来理解下 Pin :</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;    a: <span class="hljs-type">String</span>,    b: *<span class="hljs-keyword">const</span> <span class="hljs-type">String</span>,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(txt: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;        Test &#123;            a: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(txt),            b: std::ptr::<span class="hljs-title function_ invoke__">null</span>(),        &#125;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">self_ref</span>: *<span class="hljs-keyword">const</span> <span class="hljs-type">String</span> = &amp;<span class="hljs-keyword">self</span>.a;        <span class="hljs-keyword">self</span>.b = self_ref;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">a</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;        &amp;<span class="hljs-keyword">self</span>.a    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;        <span class="hljs-built_in">assert!</span>(!<span class="hljs-keyword">self</span>.b.<span class="hljs-title function_ invoke__">is_null</span>(), <span class="hljs-string">&quot;Test::b called without Test::init being called first&quot;</span>);        <span class="hljs-keyword">unsafe</span> &#123; &amp;*(<span class="hljs-keyword">self</span>.b) &#125;    &#125;&#125;</code></pre></div><p>Test 提供了方法用于获取字段 a 和 b 的值的引用。这里b 是 a 的一个引用，但是我们并没有使用引用类型而是用了裸指针，原因是：Rust 的借用规则不允许我们这样用，因为不符合生命周期的要求。 此时的 Test 就是一个自引用结构体。</p><p>如果不移动任何值，那么上面的例子将没有任何问题。</p><p>我们就移动下数据试试，将 test1 和 test2 进行下交换：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">test1</span> = Test::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;test1&quot;</span>);    test1.<span class="hljs-title function_ invoke__">init</span>();    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">test2</span> = Test::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;test2&quot;</span>);    test2.<span class="hljs-title function_ invoke__">init</span>();    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, test1.<span class="hljs-title function_ invoke__">a</span>(), test1.<span class="hljs-title function_ invoke__">b</span>());    std::mem::<span class="hljs-title function_ invoke__">swap</span>(&amp;<span class="hljs-keyword">mut</span> test1, &amp;<span class="hljs-keyword">mut</span> test2);    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>, test2.<span class="hljs-title function_ invoke__">a</span>(), test2.<span class="hljs-title function_ invoke__">b</span>());&#125;</code></pre></div><p>结果是，test2.b 指针依然指向了旧的地址，而该地址对应的值现在在 test1 里，最终会打印出意料之外的值。</p><p><img src="/2025/02/27/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-async_await%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%E4%B8%8A/2.png"></p><h2 id="3-4-Pin-在实践中的运用"><a href="#3-4-Pin-在实践中的运用" class="headerlink" title="3.4 Pin 在实践中的运用"></a>3.4 Pin 在实践中的运用</h2><p>理解了 Pin 的作用后，我们再来看看它怎么帮我们解决问题。</p><h3 id="3-4-1-将值固定到栈上"><a href="#3-4-1-将值固定到栈上" class="headerlink" title="3.4.1 将值固定到栈上"></a>3.4.1 将值固定到栈上</h3><p>回到之前的例子，我们可以用 Pin 来解决指针指向的数据被移动的问题:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::pin::Pin;<span class="hljs-keyword">use</span> std::marker::PhantomPinned;<span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;    a: <span class="hljs-type">String</span>,    b: *<span class="hljs-keyword">const</span> <span class="hljs-type">String</span>,    _marker: PhantomPinned,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(txt: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;        Test &#123;            a: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(txt),            b: std::ptr::<span class="hljs-title function_ invoke__">null</span>(),            _marker: PhantomPinned, <span class="hljs-comment">// 这个标记可以让我们的类型自动实现特征`!Unpin`</span>        &#125;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;) &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">self_ptr</span>: *<span class="hljs-keyword">const</span> <span class="hljs-type">String</span> = &amp;<span class="hljs-keyword">self</span>.a;        <span class="hljs-keyword">let</span> <span class="hljs-variable">this</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_unchecked_mut</span>() &#125;;        this.b = self_ptr;    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">a</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_ref</span>().a    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;        <span class="hljs-built_in">assert!</span>(!<span class="hljs-keyword">self</span>.b.<span class="hljs-title function_ invoke__">is_null</span>(), <span class="hljs-string">&quot;Test::b called without Test::init being called first&quot;</span>);        <span class="hljs-keyword">unsafe</span> &#123; &amp;*(<span class="hljs-keyword">self</span>.b) &#125;    &#125;&#125;</code></pre></div><p>上面代码中，我们使用了一个标记类型 PhantomPinned 将自定义结构体 Test 变成了 !Unpin (编译器会自动帮我们实现)，因此该结构体无法再被移动。</p><p>一旦类型实现了 !Unpin ，那将它的值固定到栈( stack )上就是不安全的行为，因此在代码中我们使用了 unsafe 语句块来进行处理，你也可以使用 pin_utils 来避免 unsafe 的使用。</p><p>此时，再去尝试移动被固定的值，就会导致编译错误：</p><h3 id="3-4-2-固定到堆上"><a href="#3-4-2-固定到堆上" class="headerlink" title="3.4.2 固定到堆上"></a>3.4.2 固定到堆上</h3><p>将一个 !Unpin 类型的值固定到堆上，会给予该值一个稳定的内存地址，它指向的堆中的值在 Pin 后是无法被移动的。而且与固定在栈上不同，我们知道堆上的值在整个生命周期内都会被稳稳地固定住。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::pin::Pin;<span class="hljs-keyword">use</span> std::marker::PhantomPinned;<span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;    a: <span class="hljs-type">String</span>,    b: *<span class="hljs-keyword">const</span> <span class="hljs-type">String</span>,    _marker: PhantomPinned,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Test</span> &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(txt: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> Pin&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;&gt; &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = Test &#123;            a: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(txt),            b: std::ptr::<span class="hljs-title function_ invoke__">null</span>(),            _marker: PhantomPinned,        &#125;;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">boxed</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">pin</span>(t);        <span class="hljs-keyword">let</span> <span class="hljs-variable">self_ptr</span>: *<span class="hljs-keyword">const</span> <span class="hljs-type">String</span> = &amp;boxed.<span class="hljs-title function_ invoke__">as_ref</span>().a;        <span class="hljs-keyword">unsafe</span> &#123; boxed.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">get_unchecked_mut</span>().b = self_ptr &#125;;        boxed    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">a</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_ref</span>().a    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">Self</span>&gt;) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">unsafe</span> &#123; &amp;*(<span class="hljs-keyword">self</span>.b) &#125;    &#125;&#125;<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">test1</span> = Test::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;test1&quot;</span>);    <span class="hljs-keyword">let</span> <span class="hljs-variable">test2</span> = Test::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;test2&quot;</span>);    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>,test1.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">a</span>(), test1.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">b</span>());    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a: &#123;&#125;, b: &#123;&#125;&quot;</span>,test2.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">a</span>(), test2.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">b</span>());&#125;</code></pre></div><h3 id="3-4-3-将固定住的-Future-变为-Unpin"><a href="#3-4-3-将固定住的-Future-变为-Unpin" class="headerlink" title="3.4.3 将固定住的 Future 变为 Unpin"></a>3.4.3 将固定住的 Future 变为 Unpin</h3><p>async 函数返回的 Future 默认就是 !Unpin 的。</p><p>在实际应用中，一些函数会要求它们处理的 Future 是 Unpin 的，此时，若你使用的 Future 是 !Unpin 的，必须要使用以下的方法先将 Future 进行固定:</p><ul><li>Box::pin， 创建一个 Pin&lt;Box<T>&gt;</li><li>pin_utils::pin_mut!， 创建一个 Pin&lt;&amp;mut T&gt;</li></ul><p>固定后获得的 Pin&lt;Box<T>&gt; 和 Pin&lt;&amp;mut T&gt; 既可以用于 Future ，又会自动实现 Unpin。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> pin_utils::pin_mut; <span class="hljs-comment">// `pin_utils` 可以在crates.io中找到</span><span class="hljs-comment">// 函数的参数是一个`Future`，但是要求该`Future`实现`Unpin`</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">execute_unpin_future</span>(x: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = ()&gt; + Unpin) &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-keyword">let</span> <span class="hljs-variable">fut</span> = <span class="hljs-keyword">async</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<span class="hljs-comment">// 下面代码报错: 默认情况下，`fut` 实现的是`!Unpin`，并没有实现`Unpin`</span><span class="hljs-comment">// execute_unpin_future(fut);</span><span class="hljs-comment">// 使用`Box`进行固定</span><span class="hljs-keyword">let</span> <span class="hljs-variable">fut</span> = <span class="hljs-keyword">async</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<span class="hljs-keyword">let</span> <span class="hljs-variable">fut</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">pin</span>(fut);<span class="hljs-title function_ invoke__">execute_unpin_future</span>(fut); <span class="hljs-comment">// OK</span><span class="hljs-comment">// 使用`pin_mut!`进行固定</span><span class="hljs-keyword">let</span> <span class="hljs-variable">fut</span> = <span class="hljs-keyword">async</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;pin_mut!(fut);<span class="hljs-title function_ invoke__">execute_unpin_future</span>(fut); <span class="hljs-comment">// OK</span></code></pre></div><h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><ul><li>若 T: Unpin ( Rust 类型的默认实现)，那么 Pin&lt;’a, T&gt; 跟 &amp;’a mut T 完全相同，也就是 Pin 将没有任何效果, 该移动还是照常移动</li><li>绝大多数标准库类型都实现了 Unpin ，事实上，对于 Rust 中你能遇到的绝大多数类型，该结论依然成立 ，其中一个例外就是：async&#x2F;await 生成的 Future 没有实现 Unpin</li><li>你可以通过以下方法为自己的类型添加 !Unpin 约束：<ul><li>使用文中提到的 std::marker::PhantomPinned</li><li>使用nightly 版本下的 feature flag</li></ul></li><li>可以将值固定到栈上，也可以固定到堆上<ul><li>将 !Unpin 值固定到栈上需要使用 unsafe</li><li>将 !Unpin 值固定到堆上无需 unsafe ，可以通过 Box::pin 来简单的实现</li></ul></li><li>当固定类型 T: !Unpin 时，你需要保证数据从被固定到被 drop 这段时期内，其内存不会变得非法或者被重用</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>rust圣经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RUST圣经-高阶学习-多线程并发和异步-下</title>
    <link href="/2025/02/26/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5-%E4%B8%8B/"/>
    <url>/2025/02/26/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="4-线程同步：锁、Condvar-和信号量"><a href="#4-线程同步：锁、Condvar-和信号量" class="headerlink" title="4 线程同步：锁、Condvar 和信号量"></a>4 线程同步：锁、Condvar 和信号量</h2><p>在多线程编程中，同步性极其的重要，当你需要同时访问一个资源、控制不同线程的执行次序时，都需要使用到同步性。</p><p>在 Rust 中有多种方式可以实现同步性。在上一节中讲到的消息传递就是同步性的一种实现方式，例如我们可以通过消息传递来控制不同线程间的执行次序。还可以使用共享内存来实现同步性，例如通过锁和原子操作等并发原语来实现多个线程同时且安全地去访问一个资源。</p><h2 id="4-1-该如何选择"><a href="#4-1-该如何选择" class="headerlink" title="4.1 该如何选择"></a>4.1 该如何选择</h2><p>共享内存可以说是同步的灵魂，因为消息传递的底层实际上也是通过共享内存来实现，两者的区别如下：</p><ul><li>共享内存相对消息传递能节省多次内存拷贝的成本</li><li>共享内存的实现简洁的多</li><li>共享内存的锁竞争更多</li></ul><p>消息传递适用的场景很多，我们下面列出了几个主要的使用场景:</p><ul><li>需要可靠和简单的(简单不等于简洁)实现时</li><li>需要模拟现实世界，例如用消息去通知某个目标执行相应的操作时</li><li>需要一个任务处理流水线(管道)时，等等</li></ul><p>而使用共享内存(并发原语)的场景往往就比较简单粗暴：需要简洁的实现以及更高的性能时。</p><p>总之，消息传递类似一个单所有权的系统：一个值同时只能有一个所有者，如果另一个线程需要该值的所有权，需要将所有权通过消息传递进行转移。而共享内存类似于一个多所有权的系统：多个线程可以同时访问同一个值。</p><h2 id="4-2-互斥锁-Mutex"><a href="#4-2-互斥锁-Mutex" class="headerlink" title="4.2 互斥锁 Mutex"></a>4.2 互斥锁 Mutex</h2><p>既然是共享内存，那并发原语自然是重中之重，先来一起看看皇冠上的明珠: 互斥锁Mutex(mutual exclusion 的缩写)。</p><p>Mutex让多个线程并发的访问同一个值变成了排队访问：同一时间，只允许一个线程A访问该值，其它线程需要等待A访问完成后才能继续。</p><h3 id="4-2-1-单线程中使用-Mutex"><a href="#4-2-1-单线程中使用-Mutex" class="headerlink" title="4.2.1 单线程中使用 Mutex"></a>4.2.1 单线程中使用 Mutex</h3><p>先来看看单线程中Mutex该如何使用:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-comment">// 使用`Mutex`结构体的关联函数创建新的互斥锁实例</span>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);    &#123;        <span class="hljs-comment">// 获取锁，然后deref为`m`的引用</span>        <span class="hljs-comment">// lock返回的是Result</span>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();        *num = <span class="hljs-number">6</span>;        <span class="hljs-comment">// 锁自动被drop</span>    &#125;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;m = &#123;:?&#125;&quot;</span>, m);&#125;</code></pre></div><p>和Box类似，数据被Mutex所拥有，要访问内部的数据，需要使用方法m.lock()向m申请一个锁, 该方法会阻塞当前线程，直到获取到锁，因此当多个线程同时访问该数据时，只有一个线程能获取到锁，其它线程只能阻塞着等待，这样就保证了数据能被安全的修改！</p><p>m.lock()方法也有可能报错，例如当前正在持有锁的线程panic了。在这种情况下，其它线程不可能再获得锁，因此lock方法会返回一个错误。</p><p>因为Mutex<T>是一个智能指针，准确的说是m.lock()返回一个智能指针MutexGuard<T>:</p><ul><li>它实现了Deref特征，会被自动解引用后获得一个引用类型，该引用指向Mutex内部的数据</li><li>它还实现了Drop特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁</li></ul><p>正因为智能指针的使用，使得我们无需任何操作就能获取其中的数据。</p><p>如果释放锁，你需要做的仅仅是做好锁的作用域管理，例如上述代码的内部花括号使用，建议读者尝试下去掉内部的花括号，然后再次尝试获取第二个锁num1，看看会发生什么，友情提示：不会报错，但是主线程会永远阻塞，因为不幸发生了死锁。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    *num = <span class="hljs-number">6</span>;    <span class="hljs-comment">// 锁还没有被 drop 就尝试申请下一个锁，导致主线程阻塞</span>    <span class="hljs-comment">// drop(num); // 手动 drop num ，可以让 num1 申请到下个锁</span>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num1</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    *num1 = <span class="hljs-number">7</span>;    <span class="hljs-comment">// drop(num1); // 手动 drop num1 ，观察打印结果的不同</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;m = &#123;:?&#125;&quot;</span>, m);&#125;</code></pre></div><h3 id="4-2-2-多线程中使用-Mutex"><a href="#4-2-2-多线程中使用-Mutex" class="headerlink" title="4.2.2 多线程中使用 Mutex"></a>4.2.2 多线程中使用 Mutex</h3><p>如何在多线程下使用Mutex来访问同一个资源.</p><h4 id="4-2-2-1-无法运行的Rc"><a href="#4-2-2-1-无法运行的Rc" class="headerlink" title="4.2.2.1 无法运行的Rc"></a>4.2.2.1 无法运行的Rc<T></h4><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<span class="hljs-keyword">use</span> std::sync::Mutex;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-comment">// 通过`Rc`实现`Mutex`的多所有权</span>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;counter);        <span class="hljs-comment">// 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中</span>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();            *num += <span class="hljs-number">1</span>;        &#125;);        handles.<span class="hljs-title function_ invoke__">push</span>(handle);    &#125;    <span class="hljs-comment">// 等待所有子线程完成</span>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;    <span class="hljs-comment">// 输出最终的计数结果</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());&#125;</code></pre></div><p>由于子线程需要通过move拿走锁的所有权，因此我们需要使用多所有权来保证每个线程都拿到数据的独立所有权，恰好智能指针Rc<T>可以做到(上面代码会报错！</p><p>以上代码实现了在多线程中计数的功能，由于多个线程都需要去修改该计数器，因此我们需要使用锁来保证同一时间只有一个线程可以修改计数器，否则会导致脏数据：想象一下 A 线程和 B 线程同时拿到计数器，获取了当前值1, 并且同时对其进行了修改，最后值变成2, 毕竟正确的值是3，因为两个线程各自加 1。</p><h4 id="4-2-2-2-多线程安全的-Arc"><a href="#4-2-2-2-多线程安全的-Arc" class="headerlink" title="4.2.2.2 多线程安全的 Arc"></a>4.2.2.2 多线程安全的 Arc<T></h4><p>Arc<T>，得益于它的内部计数器是多线程安全的，因此可以在多线程环境中使用:</p><p>将Rc换成Arc就可以正常使用了</p><h4 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h4><p>Rust中Rc<T>和RefCell<T>的结合，可以实现单线程的内部可变性。</p><p>现在我们又有了新的武器，由于Mutex<T>可以支持修改内部数据，当结合Arc<T>一起使用时，可以实现多线程的内部可变性。</p><p>简单总结下：Rc<T>&#x2F;RefCell<T>用于单线程内部可变性， Arc<T>&#x2F;Mutex<T>用于多线程内部可变性。</p><h4 id="需要小心使用的-Mutex"><a href="#需要小心使用的-Mutex" class="headerlink" title="需要小心使用的 Mutex"></a>需要小心使用的 Mutex</h4><ul><li>在使用数据前必须先获取锁</li><li>在数据使用完成后，必须及时的释放锁，比如文章开头的例子，使用内部语句块的目的就是为了及时的释放锁</li></ul><p>对于其它语言，忘记释放锁是经常发生的，虽然 Rust 通过智能指针的drop机制帮助我们避免了这一点，但是由于不及时释放锁导致的性能问题也是常见的。</p><p>正因为这种困难性，导致很多用户都热衷于使用消息传递的方式来实现同步，例如 Go 语言直接把channel内置在语言特性中，甚至还有无锁的语言，例如erlang，完全使用Actor模型，依赖消息传递来完成共享和同步。幸好 Rust 的类型系统、所有权机制、智能指针等可以很好的帮助我们减轻使用锁时的负担。</p><p>另一个值的注意的是在使用Mutex<T>时，Rust 无法帮我们避免所有的逻辑错误，例如在之前章节，我们提到过使用Rc<T>可能会导致循环引用的问题。类似的，Mutex<T>也存在使用上的风险，例如创建死锁(deadlock)：当一个操作试图锁住两个资源，然后两个线程各自获取其中一个锁，并试图获取另一个锁时，就会造成死锁。</p><h2 id="4-3-死锁"><a href="#4-3-死锁" class="headerlink" title="4.3 死锁"></a>4.3 死锁</h2><p>Rust 中有多种方式可以创建死锁，了解这些方式有助于你提前规避可能的风险。</p><h2 id="4-3-1-单线程死锁"><a href="#4-3-1-单线程死锁" class="headerlink" title="4.3.1 单线程死锁"></a>4.3.1 单线程死锁</h2><p>这种死锁比较容易规避，但是当代码复杂后还是有可能遇到：</p><div class="code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">use</span> std::sync::<span class="hljs-type">Mutex</span>;<span class="hljs-title">fn</span> main() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Mutex</span>::new(0);</span>    <span class="hljs-keyword">let</span> d1 = <span class="hljs-class"><span class="hljs-keyword">data</span>.lock();</span>    <span class="hljs-keyword">let</span> d2 = <span class="hljs-class"><span class="hljs-keyword">data</span>.lock();</span>&#125; // d1锁在此处释放</code></pre></div><p>只要你在另一个锁还未被释放时去申请新的锁，就会触发，当代码复杂后，这种情况可能就没有那么显眼。</p><h2 id="4-3-2-多线程死锁"><a href="#4-3-2-多线程死锁" class="headerlink" title="4.3.2 多线程死锁"></a>4.3.2 多线程死锁</h2><p>当我们拥有两个锁，且两个线程各自使用了其中一个锁，然后试图去访问另一个锁时，就可能发生死锁：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;sync::&#123;Mutex, MutexGuard&#125;, thread&#125;;<span class="hljs-keyword">use</span> std::thread::sleep;<span class="hljs-keyword">use</span> std::time::Duration;<span class="hljs-keyword">use</span> lazy_static::lazy_static;lazy_static! &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> MUTEX1: Mutex&lt;<span class="hljs-type">i64</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> MUTEX2: Mutex&lt;<span class="hljs-type">i64</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-comment">// 存放子线程的句柄</span>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">children</span> = <span class="hljs-built_in">vec!</span>[];    <span class="hljs-keyword">for</span> <span class="hljs-variable">i_thread</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">2</span> &#123;        children.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;            <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1</span> &#123;                <span class="hljs-comment">// 线程1</span>                <span class="hljs-keyword">if</span> i_thread % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;                    <span class="hljs-comment">// 锁住MUTEX1</span>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span>: MutexGuard&lt;<span class="hljs-type">i64</span>&gt; = MUTEX1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 锁住了MUTEX1，接着准备去锁MUTEX2 !&quot;</span>, i_thread);                    <span class="hljs-comment">// 当前线程睡眠一小会儿，等待线程2锁住MUTEX2</span>                    <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span>));                    <span class="hljs-comment">// 去锁MUTEX2</span>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span> = MUTEX2.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();                <span class="hljs-comment">// 线程2</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 锁住MUTEX2</span>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">_guard</span> = MUTEX2.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 锁住了MUTEX2, 准备去锁MUTEX1&quot;</span>, i_thread);                    <span class="hljs-keyword">let</span> <span class="hljs-variable">_guard</span> = MUTEX1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();                &#125;            &#125;        &#125;));    &#125;    <span class="hljs-comment">// 等子线程完成</span>    <span class="hljs-keyword">for</span> <span class="hljs-variable">child</span> <span class="hljs-keyword">in</span> children &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = child.<span class="hljs-title function_ invoke__">join</span>();    &#125;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;死锁没有发生&quot;</span>);&#125;</code></pre></div><p>在上面的描述中，我们用了”可能”二字，原因在于死锁在这段代码中不是必然发生的，总有一次运行你能看到最后一行打印输出。这是由于子线程的初始化顺序和执行速度并不确定，我们无法确定哪个线程中的锁先被执行，因此也无法确定两个线程对锁的具体使用顺序。</p><p>但是，可以简单的说明下死锁发生的必然条件：线程 1 锁住了MUTEX1并且线程2锁住了MUTEX2，然后线程 1 试图去访问MUTEX2，同时线程2试图去访问MUTEX1，就会死锁。 因为线程 2 需要等待线程 1 释放MUTEX1后，才会释放MUTEX2，而与此同时，线程 1 需要等待线程 2 释放MUTEX2后才能释放MUTEX1，这种情况造成了两个线程都无法释放对方需要的锁，最终死锁。</p><p>那么为何某些时候，死锁不会发生？原因很简单，线程 2 在线程 1 锁MUTEX1之前，就已经全部执行完了，随之线程 2 的MUTEX2和MUTEX1被全部释放，线程 1 对锁的获取将不再有竞争者。 同理，线程 1 若全部被执行完，那线程 2 也不会被锁，因此我们在线程 1 中间加一个睡眠，增加死锁发生的概率。如果你在线程 2 中同样的位置也增加一个睡眠，那死锁将必然发生!</p><h2 id="4-3-3-try-lock"><a href="#4-3-3-try-lock" class="headerlink" title="4.3.3 try_lock"></a>4.3.3 try_lock</h2><p>与lock方法不同，try_lock会尝试去获取一次锁，如果无法获取会返回一个错误，因此不会发生阻塞:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;sync::&#123;Mutex, MutexGuard&#125;, thread&#125;;<span class="hljs-keyword">use</span> std::thread::sleep;<span class="hljs-keyword">use</span> std::time::Duration;<span class="hljs-keyword">use</span> lazy_static::lazy_static;lazy_static! &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> MUTEX1: Mutex&lt;<span class="hljs-type">i64</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> MUTEX2: Mutex&lt;<span class="hljs-type">i64</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-comment">// 存放子线程的句柄</span>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">children</span> = <span class="hljs-built_in">vec!</span>[];    <span class="hljs-keyword">for</span> <span class="hljs-variable">i_thread</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">2</span> &#123;        children.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;            <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1</span> &#123;                <span class="hljs-comment">// 线程1</span>                <span class="hljs-keyword">if</span> i_thread % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;                    <span class="hljs-comment">// 锁住MUTEX1</span>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span>: MutexGuard&lt;<span class="hljs-type">i64</span>&gt; = MUTEX1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 锁住了MUTEX1，接着准备去锁MUTEX2 !&quot;</span>, i_thread);                    <span class="hljs-comment">// 当前线程睡眠一小会儿，等待线程2锁住MUTEX2</span>                    <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span>));                    <span class="hljs-comment">// 去锁MUTEX2</span>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span> = MUTEX2.<span class="hljs-title function_ invoke__">try_lock</span>();                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 获取 MUTEX2 锁的结果: &#123;:?&#125;&quot;</span>, i_thread, guard);                <span class="hljs-comment">// 线程2</span>                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 锁住MUTEX2</span>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">_guard</span> = MUTEX2.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 锁住了MUTEX2, 准备去锁MUTEX1&quot;</span>, i_thread);                    <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span>));                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span> = MUTEX1.<span class="hljs-title function_ invoke__">try_lock</span>();                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 获取 MUTEX1 锁的结果: &#123;:?&#125;&quot;</span>, i_thread, guard);                &#125;            &#125;        &#125;));    &#125;    <span class="hljs-comment">// 等子线程完成</span>    <span class="hljs-keyword">for</span> <span class="hljs-variable">child</span> <span class="hljs-keyword">in</span> children &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = child.<span class="hljs-title function_ invoke__">join</span>();    &#125;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;死锁没有发生&quot;</span>);&#125;</code></pre></div><p>将lock替换成try_lock，与之前的结果不同，这段代码将不会再有死锁发生：</p><p>当try_lock失败时，会报出一个错误:Err(“WouldBlock”)，接着线程中的剩余代码会继续执行，不会被阻塞。</p><div class="code-wrapper"><pre><code class="hljs ceylon">一个有趣的命名规则：在 Rust 标准库中，使用<span class="hljs-keyword">try</span><span class="hljs-number">_</span>xxx都会尝试进行一次操作，如果无法完成，就立即返回，不会发生阻塞。例如消息传递章节中的<span class="hljs-keyword">try</span><span class="hljs-number">_</span>recv以及本章节中的<span class="hljs-keyword">try</span><span class="hljs-number">_</span>lock</code></pre></div><h2 id="4-4-读写锁-RwLock"><a href="#4-4-读写锁-RwLock" class="headerlink" title="4.4 读写锁 RwLock"></a>4.4 读写锁 RwLock</h2><p>Mutex会对每次读写都进行加锁，但某些时候，我们需要大量的并发读，Mutex就无法满足需求了，此时就可以使用RwLock:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::RwLock;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">lock</span> = RwLock::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);    <span class="hljs-comment">// 同一时间允许多个读</span>    &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = lock.<span class="hljs-title function_ invoke__">read</span>().<span class="hljs-title function_ invoke__">unwrap</span>();        <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = lock.<span class="hljs-title function_ invoke__">read</span>().<span class="hljs-title function_ invoke__">unwrap</span>();        <span class="hljs-built_in">assert_eq!</span>(*r1, <span class="hljs-number">5</span>);        <span class="hljs-built_in">assert_eq!</span>(*r2, <span class="hljs-number">5</span>);    &#125; <span class="hljs-comment">// 读锁在此处被drop</span>    <span class="hljs-comment">// 同一时间只允许一个写</span>    &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">w</span> = lock.<span class="hljs-title function_ invoke__">write</span>().<span class="hljs-title function_ invoke__">unwrap</span>();        *w += <span class="hljs-number">1</span>;        <span class="hljs-built_in">assert_eq!</span>(*w, <span class="hljs-number">6</span>);        <span class="hljs-comment">// 以下代码会阻塞发生死锁，因为读和写不允许同时存在</span>        <span class="hljs-comment">// 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中</span>        <span class="hljs-comment">// let r1 = lock.read();</span>        <span class="hljs-comment">// println!(&quot;&#123;:?&#125;&quot;,r1);</span>    &#125;<span class="hljs-comment">// 写锁在此处被drop</span>&#125;</code></pre></div><p>RwLock在使用上和Mutex区别不大，只有在多个读的情况下不阻塞程序，其他如读写、写读、写写情况下均会对后获取锁的操作进行阻塞。</p><p>也可以使用try_write和try_read来尝试进行一次写&#x2F;读，若失败则返回错误:</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Err</span><span class="hljs-params">(<span class="hljs-string">&quot;WouldBlock&quot;</span>)</span></span></code></pre></div><p>简单总结下RwLock:</p><ul><li>同时允许多个读，但最多只能有一个写</li><li>读和写不能同时存在</li><li>读可以使用read、try_read，写write、try_write, 在实际项目中，try_xxx会安全的多</li></ul><h2 id="4-5-Mutex-还是-RwLock"><a href="#4-5-Mutex-还是-RwLock" class="headerlink" title="4.5 Mutex 还是 RwLock"></a>4.5 Mutex 还是 RwLock</h2><p>简单性上Mutex完胜，因为使用RwLock你得操心几个问题：</p><ul><li>读和写不能同时发生，如果使用try_xxx解决，就必须做大量的错误处理和失败重试机制</li><li>当读多写少时，写操作可能会因为一直无法获得锁导致连续多次失败(writer starvation)</li><li>RwLock 其实是操作系统提供的，实现原理要比Mutex复杂的多，因此单就锁的性能而言，比不上原生实现的Mutex</li></ul><p>再来简单总结下两者的使用场景：</p><ul><li>追求高并发读取时，使用RwLock，因为Mutex一次只允许一个线程去读取</li><li>如果要保证写操作的成功性，使用Mutex</li><li>不知道哪个合适，统一使用Mutex</li></ul><p>RwLock虽然看上去貌似提供了高并发读取的能力，但这个不能说明它的性能比Mutex高，事实上Mutex性能要好不少，后者唯一的问题也仅仅在于不能并发读取。</p><p>一个常见的、错误的使用RwLock的场景就是使用HashMap进行简单读写，因为HashMap的读和写都非常快，RwLock的复杂实现和相对低的性能反而会导致整体性能的降低，因此一般来说更适合使用Mutex。 </p><p>要使用RwLock要确保满足以下两个条件：并发读，且需要对读到的资源进行”长时间”的操作，HashMap也许满足了并发读的需求，但是往往并不能满足后者：”长时间”的操作。</p><h2 id="4-6-三方库提供的锁实现"><a href="#4-6-三方库提供的锁实现" class="headerlink" title="4.6 三方库提供的锁实现"></a>4.6 三方库提供的锁实现</h2><p>标准库在设计时总会存在取舍，因为往往性能并不是最好的，如果你追求性能，可以使用三方库提供的并发原语:</p><ul><li>parking_lot, 功能更完善、稳定，社区较为活跃，star 较多，更新较为活跃</li><li>spin, 在多数场景中性能比parking_lot高一点，最近没怎么更新</li></ul><p>如果不是追求特别极致的性能，建议选择前者。</p><h2 id="4-7-用条件变量-Condvar-控制线程的同步"><a href="#4-7-用条件变量-Condvar-控制线程的同步" class="headerlink" title="4.7 用条件变量(Condvar)控制线程的同步"></a>4.7 用条件变量(Condvar)控制线程的同步</h2><p>Mutex用于解决资源安全访问的问题，但是我们还需要一个手段来解决资源访问顺序的问题。而 Rust 考虑到了这一点，为我们提供了条件变量(Condition Variables)，它经常和Mutex一起使用，可以让线程挂起，直到某个条件发生后再继续执行</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc,Mutex,Condvar&#125;;<span class="hljs-keyword">use</span> std::thread::&#123;spawn,sleep&#125;;<span class="hljs-keyword">use</span> std::time::Duration;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">flag</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>));    <span class="hljs-keyword">let</span> <span class="hljs-variable">cond</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Condvar::<span class="hljs-title function_ invoke__">new</span>());    <span class="hljs-keyword">let</span> <span class="hljs-variable">cflag</span> = flag.<span class="hljs-title function_ invoke__">clone</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">ccond</span> = cond.<span class="hljs-title function_ invoke__">clone</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">hdl</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lock</span> = cflag.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> counter &lt; <span class="hljs-number">3</span> &#123;            <span class="hljs-keyword">while</span> !*lock &#123;                <span class="hljs-comment">// wait方法会接收一个MutexGuard&lt;&#x27;a, T&gt;，且它会自动地暂时释放这个锁，使其他线程可以拿到锁并进行数据更新。</span>                <span class="hljs-comment">// 同时当前线程在此处会被阻塞，直到被其他地方notify后，它会将原本的MutexGuard&lt;&#x27;a, T&gt;还给我们，即重新获取到了锁，同时唤醒了此线程。</span>                lock = ccond.<span class="hljs-title function_ invoke__">wait</span>(lock).<span class="hljs-title function_ invoke__">unwrap</span>();            &#125;                        *lock = <span class="hljs-literal">false</span>;            counter += <span class="hljs-number">1</span>;            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;inner counter: &#123;&#125;&quot;</span>, counter);        &#125;    &#125;);    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">loop</span> &#123;        <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>));        *flag.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>() = <span class="hljs-literal">true</span>;        counter += <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> counter &gt; <span class="hljs-number">3</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;outside counter: &#123;&#125;&quot;</span>, counter);        cond.<span class="hljs-title function_ invoke__">notify_one</span>();    &#125;    hdl.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, flag);&#125;</code></pre></div><p>例子中通过主线程来触发子线程实现交替打印输出：</p><div class="code-wrapper"><pre><code class="hljs nix">outside <span class="hljs-params">counter:</span> <span class="hljs-number">1</span>inner <span class="hljs-params">counter:</span> <span class="hljs-number">1</span>outside <span class="hljs-params">counter:</span> <span class="hljs-number">2</span>inner <span class="hljs-params">counter:</span> <span class="hljs-number">2</span>outside <span class="hljs-params">counter:</span> <span class="hljs-number">3</span>inner <span class="hljs-params">counter:</span> <span class="hljs-number">3</span>Mutex &#123; <span class="hljs-params">data:</span> <span class="hljs-literal">true</span>, <span class="hljs-params">poisoned:</span> <span class="hljs-literal">false</span>, .. &#125;</code></pre></div><h2 id="4-8-信号量-Semaphore"><a href="#4-8-信号量-Semaphore" class="headerlink" title="4.8 信号量 Semaphore"></a>4.8 信号量 Semaphore</h2><p>在多线程中，另一个重要的概念就是信号量，使用它可以让我们精准的控制当前正在运行的任务最大数量。<br>当一个新游戏刚开服时(有些较火的老游戏也会，比如wow)，往往会控制游戏内玩家的同时在线数，一旦超过某个临界值，就开始进行排队进服。而在实际使用中，也有很多时候，我们需要通过信号量来控制最大并发数，防止服务器资源被撑爆。</p><p>本来 Rust 在标准库中有提供一个信号量实现, 但是由于各种原因这个库现在已经不再推荐使用了，因此我们推荐使用tokio中提供的Semaphore实现: tokio::sync::Semaphore。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Arc;<span class="hljs-keyword">use</span> tokio::sync::Semaphore;<span class="hljs-meta">#[tokio::main]</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">semaphore</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Semaphore::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>));    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">join_handles</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">5</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">permit</span> = semaphore.<span class="hljs-title function_ invoke__">clone</span>().<span class="hljs-title function_ invoke__">acquire_owned</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();        join_handles.<span class="hljs-title function_ invoke__">push</span>(tokio::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;            <span class="hljs-comment">//</span>            <span class="hljs-comment">// 在这里执行任务...</span>            <span class="hljs-comment">//</span>            <span class="hljs-title function_ invoke__">drop</span>(permit);        &#125;));    &#125;    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> join_handles &#123;        handle.<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;&#125;</code></pre></div><p>上面代码创建了一个容量为 3 的信号量，当正在执行的任务超过 3 时，剩下的任务需要等待正在执行任务完成并减少信号量后到 3 以内时，才能继续执行。</p><p>这里的关键其实说白了就在于：信号量的申请和归还，使用前需要申请信号量，如果容量满了，就需要等待；使用后需要释放信号量，以便其它等待者可以继续。</p><h2 id="5-线程同步：Atomic-原子类型与内存顺序"><a href="#5-线程同步：Atomic-原子类型与内存顺序" class="headerlink" title="5 线程同步：Atomic 原子类型与内存顺序"></a>5 线程同步：Atomic 原子类型与内存顺序</h2><p>Mutex用起来简单，但是无法并发读，RwLock可以并发读，但是使用场景较为受限且性能不够，那么有没有一种全能性选手呢？ 欢迎我们的Atomic闪亮登场。</p><p>在多核 CPU 下，当某个 CPU 核心开始运行原子操作时，会先暂停其它 CPU 内核对内存的操作，以保证原子操作不会被其它 CPU 内核所干扰。</p><p>原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。</p><p>原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了CAS循环，当大量的冲突发生时，该等待还是得等待！但是总归比锁要好。</p><p><code>CAS 全称是 Compare and swap, 它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值，如果相等，则将其修改为新的值</code></p><h2 id="5-1-使用-Atomic-作为全局变量"><a href="#5-1-使用-Atomic-作为全局变量" class="headerlink" title="5.1 使用 Atomic 作为全局变量"></a>5.1 使用 Atomic 作为全局变量</h2><p>原子类型的一个常用场景，就是作为全局变量来使用:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Sub;<span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicU64, Ordering&#125;;<span class="hljs-keyword">use</span> std::thread::&#123;<span class="hljs-keyword">self</span>, JoinHandle&#125;;<span class="hljs-keyword">use</span> std::time::Instant;<span class="hljs-keyword">const</span> N_TIMES: <span class="hljs-type">u64</span> = <span class="hljs-number">10000000</span>;<span class="hljs-keyword">const</span> N_THREADS: <span class="hljs-type">usize</span> = <span class="hljs-number">10</span>;<span class="hljs-keyword">static</span> R: AtomicU64 = AtomicU64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_n_times</span>(n: <span class="hljs-type">u64</span>) <span class="hljs-punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n &#123;            R.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::Relaxed);        &#125;    &#125;)&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = Instant::<span class="hljs-title function_ invoke__">now</span>();    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">threads</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(N_THREADS);    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..N_THREADS &#123;        threads.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">add_n_times</span>(N_TIMES));    &#125;    <span class="hljs-keyword">for</span> <span class="hljs-variable">thread</span> <span class="hljs-keyword">in</span> threads &#123;        thread.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;    <span class="hljs-built_in">assert_eq!</span>(N_TIMES * N_THREADS <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>, R.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed));    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,Instant::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">sub</span>(s));&#125;</code></pre></div><p>以上代码启动了数个线程，每个线程都在疯狂对全局变量进行加 1 操作, 最后将它与线程数 * 加1次数进行比较，如果发生了因为多个线程同时修改导致了脏数据，那么这两个必将不相等。好在，它没有让我们失望，不仅快速的完成了任务，而且保证了 100%的并发安全性。</p><p>当然以上代码的功能其实也可以通过Mutex来实现，但是后者的强大功能是建立在额外的性能损耗基础上的，因此性能会逊色不少:</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Atomic</span>实现：<span class="hljs-number">673</span>ms<span class="hljs-attribute">Mutex</span>实现: <span class="hljs-number">1136</span>ms</code></pre></div><p>可以看到Atomic实现会比Mutex快41%，实际上在复杂场景下还能更快(甚至达到 4 倍的性能差距)！</p><p>还有一点值得注意: 和Mutex一样，Atomic的值具有内部可变性，你无需将其声明为mut：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<span class="hljs-keyword">use</span> std::sync::atomic::&#123;Ordering, AtomicU64&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span> &#123;    count: <span class="hljs-type">u64</span>&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(Counter &#123;        count: <span class="hljs-number">0</span>    &#125;);    n.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().count += <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = AtomicU64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);    n.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">0</span>, Ordering::Relaxed);&#125;</code></pre></div><p>这里有一个奇怪的枚举成员Ordering::Relaxed, 看上去很像是排序作用，但是我们并没有做排序操作啊？实际上它用于控制原子操作使用的内存顺序。</p><h2 id="5-2-内存顺序"><a href="#5-2-内存顺序" class="headerlink" title="5.2 内存顺序"></a>5.2 内存顺序</h2><p>内存顺序是指 CPU 在访问内存时的顺序，该顺序可能受以下因素的影响：</p><ul><li>代码中的先后顺序</li><li>编译器优化导致在编译阶段发生改变(内存重排序 reordering)</li><li>运行阶段因 CPU 的缓存机制导致顺序被打乱</li></ul><h3 id="5-2-1-编译器优化导致内存顺序的改变"><a href="#5-2-1-编译器优化导致内存顺序的改变" class="headerlink" title="5.2.1 编译器优化导致内存顺序的改变**"></a>5.2.1 编译器优化导致内存顺序的改变**</h3><p>对于第二点，我们举个例子：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> X: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> Y: <span class="hljs-type">u64</span> = <span class="hljs-number">1</span>;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    ...     <span class="hljs-comment">// A</span>    <span class="hljs-keyword">unsafe</span> &#123;        ... <span class="hljs-comment">// B</span>        X = <span class="hljs-number">1</span>;        ... <span class="hljs-comment">// C</span>        Y = <span class="hljs-number">3</span>;        ... <span class="hljs-comment">// D</span>        X = <span class="hljs-number">2</span>;        ... <span class="hljs-comment">// E</span>    &#125;&#125;</code></pre></div><p>假如在C和D代码片段中，根本没有用到X &#x3D; 1，那么编译器很可能会将X &#x3D; 1和X &#x3D; 2进行合并:</p><p>若代码A中创建了一个新的线程用于读取全局静态变量X，则该线程将无法读取到X &#x3D; 1的结果，因为在编译阶段就已经被优化掉。</p><h3 id="5-2-2-CPU-缓存导致的内存顺序的改变"><a href="#5-2-2-CPU-缓存导致的内存顺序的改变" class="headerlink" title="5.2.2 CPU 缓存导致的内存顺序的改变"></a>5.2.2 CPU 缓存导致的内存顺序的改变</h3><p>假设之前的X &#x3D; 1没有被优化掉，并且在代码片段A中有一个新的线程:</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">initial</span> state: X = <span class="hljs-number">0</span>, Y = <span class="hljs-number">1</span><span class="hljs-attribute">THREAD</span> Main     THREAD A<span class="hljs-attribute">X</span> = <span class="hljs-number">1</span>;          if X == <span class="hljs-number">1</span> &#123;<span class="hljs-attribute">Y</span> = <span class="hljs-number">3</span>;              Y *= <span class="hljs-number">2</span>;<span class="hljs-attribute">X</span> = <span class="hljs-number">2</span>;          &#125;</code></pre></div><p>我们来讨论下以上线程状态，Y最终的可能值(可能性依次降低):</p><ul><li>Y &#x3D; 3: 线程Main运行完后才运行线程A，或者线程A运行完后再运行线程Main</li><li>Y &#x3D; 6: 线程Main的Y &#x3D; 3运行完，但X &#x3D; 2还没被运行， 此时线程 A 开始运行Y *&#x3D; 2, 最后才运行Main线程的X &#x3D; 2</li><li>Y &#x3D; 2: 线程Main正在运行Y &#x3D; 3还没结束，此时线程A正在运行Y *&#x3D; 2, 因此Y取到了值 1，然后Main的线程将Y设置为 3， 紧接着就被线程A的Y &#x3D; 2所覆盖</li><li>Y &#x3D; 2: 上面的还只是一般的数据竞争，这里虽然产生了相同的结果2，但是背后的原理大相径庭: 线程Main运行完Y &#x3D; 3，但是 CPU 缓存中的Y &#x3D; 3还没有被同步到其它 CPU 缓存中，此时线程A中的Y *&#x3D; 2就开始读取Y，结果读到了值1，最终计算出结果2</li></ul><p>甚至更改成:</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">initial</span> state: X = <span class="hljs-number">0</span>, Y = <span class="hljs-number">1</span><span class="hljs-attribute">THREAD</span> Main     THREAD A<span class="hljs-attribute">X</span> = <span class="hljs-number">1</span>;          if X == <span class="hljs-number">2</span> &#123;<span class="hljs-attribute">Y</span> = <span class="hljs-number">3</span>;              Y *= <span class="hljs-number">2</span>;<span class="hljs-attribute">X</span> = <span class="hljs-number">2</span>;          &#125;</code></pre></div><p>还是可能出现Y &#x3D; 2，因为Main线程中的X和Y被同步到其它 CPU 缓存中的顺序未必一致。</p><h3 id="5-2-3-限定内存顺序的-5-个规则"><a href="#5-2-3-限定内存顺序的-5-个规则" class="headerlink" title="5.2.3 限定内存顺序的 5 个规则"></a>5.2.3 限定内存顺序的 5 个规则</h3><p>在理解了内存顺序可能存在的改变后，你就可以明白为什么 Rust 提供了Ordering::Relaxed用于限定内存顺序了，事实上，该枚举有 5 个成员:</p><ul><li>Relaxed， 这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序</li><li>Release 释放，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面</li><li>Acquire 获取, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和Release在不同线程中联合使用</li><li>AcqRel, 是 Acquire 和 Release 的结合，同时拥有它们俩提供的保证。比如你要对一个 atomic 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序</li><li>SeqCst 顺序一致性， SeqCst就像是AcqRel的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到SeqCst的原子操作，线程中该SeqCst操作前的数据操作绝对不会被重新排在该SeqCst操作之后，且该SeqCst操作后的数据操作也绝对不会被重新排在SeqCst操作前。</li></ul><p>这些规则由于是系统提供的，因此其它语言提供的相应规则也大同小异，大家如果不明白可以看看其它语言的相关解释。</p><h3 id="5-2-4-内存屏障的例子"><a href="#5-2-4-内存屏障的例子" class="headerlink" title="5.2.4 内存屏障的例子"></a>5.2.4 内存屏障的例子</h3><p>以Release和Acquire为例，使用它们构筑出一对内存屏障，防止编译器和 CPU 将屏障前(Release)和屏障后(Acquire)中的数据操作重新排在屏障围成的范围之外:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread::&#123;<span class="hljs-keyword">self</span>, JoinHandle&#125;;<span class="hljs-keyword">use</span> std::sync::atomic::&#123;Ordering, AtomicBool&#125;;<span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<span class="hljs-keyword">fn</span> <span class="hljs-title function_">reset</span>() &#123;    <span class="hljs-keyword">unsafe</span> &#123;        DATA = <span class="hljs-number">0</span>;    &#125;    READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, Ordering::Relaxed);&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">producer</span>() <span class="hljs-punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-keyword">unsafe</span> &#123;            DATA = <span class="hljs-number">100</span>;                                 <span class="hljs-comment">// A</span>        &#125;        READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Release);           <span class="hljs-comment">// B: 内存屏障 ↑</span>    &#125;)&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">consumer</span>() <span class="hljs-punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) &#123;&#125;         <span class="hljs-comment">// C: 内存屏障 ↓</span>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">100</span>, <span class="hljs-keyword">unsafe</span> &#123; DATA &#125;);               <span class="hljs-comment">// D</span>    &#125;)&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">loop</span> &#123;        <span class="hljs-title function_ invoke__">reset</span>();        <span class="hljs-keyword">let</span> <span class="hljs-variable">t_producer</span> = <span class="hljs-title function_ invoke__">producer</span>();        <span class="hljs-keyword">let</span> <span class="hljs-variable">t_consumer</span> = <span class="hljs-title function_ invoke__">consumer</span>();        t_producer.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();        t_consumer.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;&#125;</code></pre></div><p>原则上，Acquire用于读取，而Release用于写入。但是由于有些原子操作同时拥有读取和写入的功能，此时就需要使用AcqRel来设置内存顺序了。在内存屏障中被写入的数据，都可以被其它线程读取到，不会有 CPU 缓存的问题。</p><p><strong>内存顺序的选择</strong></p><ul><li>不知道怎么选择时，优先使用SeqCst，虽然会稍微减慢速度，但是慢一点也比出现错误好</li><li>多线程只计数fetch_add而不使用该值触发其他逻辑分支的简单使用场景，可以使用Relaxed 参考 Which std::sync::atomic::Ordering to use?</li></ul><h2 id="5-3-多线程中使用-Atomic"><a href="#5-3-多线程中使用-Atomic" class="headerlink" title="5.3 多线程中使用 Atomic"></a>5.3 多线程中使用 Atomic</h2><p>在多线程环境中要使用Atomic需要配合Arc：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Arc;<span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;<span class="hljs-keyword">use</span> std::&#123;hint, thread&#125;;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">spinlock</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>));    <span class="hljs-keyword">let</span> <span class="hljs-variable">spinlock_clone</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;spinlock);    <span class="hljs-keyword">let</span> <span class="hljs-variable">thread</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;        spinlock_clone.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">0</span>, Ordering::SeqCst);    &#125;);    <span class="hljs-comment">// 等待其它线程释放锁</span>    <span class="hljs-keyword">while</span> spinlock.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst) != <span class="hljs-number">0</span> &#123;        hint::<span class="hljs-title function_ invoke__">spin_loop</span>();    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Err</span>(panic) = thread.<span class="hljs-title function_ invoke__">join</span>() &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Thread had an error: &#123;:?&#125;&quot;</span>, panic);    &#125;&#125;</code></pre></div><h2 id="5-4-Atomic-能替代锁吗"><a href="#5-4-Atomic-能替代锁吗" class="headerlink" title="5.4 Atomic 能替代锁吗"></a>5.4 Atomic 能替代锁吗</h2><p>那么原子类型既然这么全能，它可以替代锁吗？答案是不行：</p><ul><li>对于复杂的场景下，锁的使用简单粗暴，不容易有坑</li><li>std::sync::atomic包中仅提供了数值类型的原子操作：AtomicBool, AtomicIsize, AtomicUsize, AtomicI8, AtomicU16等，而锁可以应用于各种类型</li><li>在有些情况下，必须使用锁来配合，例如上一章节中使用Mutex配合Condvar</li></ul><h2 id="5-5-Atomic-的应用场景"><a href="#5-5-Atomic-的应用场景" class="headerlink" title="5.5 Atomic 的应用场景"></a>5.5 Atomic 的应用场景</h2><p>事实上，Atomic虽然对于用户不太常用，但是对于高性能库的开发者、标准库开发者都非常常用，它是并发原语的基石，除此之外，还有一些场景适用：</p><ul><li>无锁(lock free)数据结构</li><li>全局变量，例如全局自增 ID, 在后续章节会介绍</li><li>跨线程计数器，例如可以用于统计指标</li></ul><p>以上列出的只是Atomic适用的部分场景，具体场景需要大家未来根据自己的需求进行权衡选择。</p><h2 id="6-基于-Send-和-Sync-的线程安全"><a href="#6-基于-Send-和-Sync-的线程安全" class="headerlink" title="6 基于 Send 和 Sync 的线程安全"></a>6 基于 Send 和 Sync 的线程安全</h2><p>为何 Rc、RefCell 和裸指针不可以在多线程间使用？如何让裸指针可以在多线程使用？我们一起来探寻下这些问题的答案。</p><h2 id="6-1-无法用于多线程的Rc"><a href="#6-1-无法用于多线程的Rc" class="headerlink" title="6.1 无法用于多线程的Rc"></a>6.1 无法用于多线程的Rc</h2><p>先来看一段多线程使用Rc的代码:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">use</span> std::rc::Rc;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,v);    &#125;);    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;</code></pre></div><p>以上代码将v的所有权通过move转移到子线程中，看似正确实则会报错：</p><p>表面原因是Rc无法在线程间安全的转移，实际是编译器给予我们的那句帮助: <code>the trait </code>Send<code>is not implemented for</code>Rc<i32><code>(Rc&lt;i32&gt;未实现Send特征),</code>那么此处的Send特征又是何方神圣？</p><h2 id="6-2-Rc-和-Arc-源码对比"><a href="#6-2-Rc-和-Arc-源码对比" class="headerlink" title="6.2 Rc 和 Arc 源码对比"></a>6.2 Rc 和 Arc 源码对比</h2><p>在介绍Send特征之前，再来看看Arc为何可以在多线程使用，玄机在于两者的源码实现上：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// Rc源码片段</span><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; !marker::<span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Rc</span>&lt;T&gt; &#123;&#125;<span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; !marker::<span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Rc</span>&lt;T&gt; &#123;&#125;<span class="hljs-comment">// Arc源码片段</span><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Sync</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Sync</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;</code></pre></div><p>!代表移除特征的相应实现，上面代码中Rc<T>的Send和Sync特征被特地移除了实现，而Arc<T>则相反，实现了Sync + Send，再结合之前的编译器报错，大概可以明白了：Send和Sync是在线程间安全使用一个值的关键。</p><h2 id="6-3-Send-和-Sync"><a href="#6-3-Send-和-Sync" class="headerlink" title="6.3 Send 和 Sync"></a>6.3 Send 和 Sync</h2><p>Send和Sync是 Rust 安全并发的重中之重，但是实际上它们只是标记特征(marker trait，该特征未定义任何行为，因此非常适合用于标记), 来看看它们的作用：</p><ul><li>实现Send的类型可以在线程间安全的传递其所有权</li><li>实现Sync的类型可以在线程间安全的共享(通过引用)</li></ul><p>这里还有一个潜在的依赖：一个类型要在线程间安全的共享的前提是，指向它的引用必须能在线程间传递。因为如果引用都不能被传递，我们就无法在多个线程间使用引用去访问同一个数据了。</p><p>由上可知，若类型 T 的引用&amp;T是Send，则T是Sync。</p><p>来看看RwLock的实现:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">RwLock</span>&lt;T&gt; &#123;&#125;</code></pre></div><p>首先RwLock可以在线程间安全的共享，那它肯定是实现了Sync，但是我们的关注点不在这里。众所周知，RwLock可以并发的读，说明其中的值T必定也可以在线程间共享，那T必定要实现Sync。</p><p>果不其然，上述代码中，T的特征约束中就有一个Sync特征，那问题又来了，Mutex是不是相反？再来看看:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Mutex</span>&lt;T&gt; &#123;&#125;</code></pre></div><p>不出所料，Mutex<T>中的T并没有Sync特征约束。</p><h2 id="6-4-实现Send和Sync的类型"><a href="#6-4-实现Send和Sync的类型" class="headerlink" title="6.4 实现Send和Sync的类型"></a>6.4 实现Send和Sync的类型</h2><p>在 Rust 中，几乎所有类型都默认实现了Send和Sync，而且由于这两个特征都是可自动派生的特征(通过derive派生)，意味着一个复合类型(例如结构体), 只要它内部的所有成员都实现了Send或者Sync，那么它就自动实现了Send或Sync。</p><p>正是因为以上规则，Rust 中绝大多数类型都实现了Send和Sync，除了以下几个(事实上不止这几个，只不过它们比较常见):</p><ul><li>裸指针两者都没实现，因为它本身就没有任何安全保证</li><li>UnsafeCell不是Sync，因此Cell和RefCell也不是</li><li>Rc两者都没实现(因为内部的引用计数器不是线程安全的)</li></ul><p>当然，如果是自定义的复合类型，那没实现那哥俩的就较为常见了：只要复合类型中有一个成员不是Send或Sync，那么该复合类型也就不是Send或Sync。</p><p>手动实现 Send 和 Sync 是不安全的，通常并不需要手动实现 Send 和 Sync trait，实现者需要使用unsafe小心维护并发安全保证。</p><p>我们来一起看看如何让裸指针可以在线程间安全的使用。</p><h2 id="6-5-为裸指针实现Send"><a href="#6-5-为裸指针实现Send" class="headerlink" title="6.5 为裸指针实现Send"></a>6.5 为裸指针实现Send</h2><p>裸指针既没实现Send，意味着下面代码会报错:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-number">5</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>;    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,p);    &#125;);    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;</code></pre></div><p>报错跟之前无二： <code>*mut u8</code> cannot be sent between threads safely, 但是有一个问题，我们无法为其直接实现Send特征，好在可以用newtype类型 :struct MyBox(*mut u8);。</p><p>还记得之前的规则吗：复合类型中有一个成员没实现Send，该复合类型就不是Send，因此我们需要手动为它实现:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>(*<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>);<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span> &#123;&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-title function_ invoke__">MyBox</span>(<span class="hljs-number">5</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>);    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,p);    &#125;);    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;</code></pre></div><p>此时，我们的指针已经可以欢快的在多线程间撒欢，以上代码很简单，但有一点需要注意：Send和Sync是unsafe特征，实现时需要用unsafe代码块包裹。</p><h2 id="6-6-为裸指针实现Sync"><a href="#6-6-为裸指针实现Sync" class="headerlink" title="6.6 为裸指针实现Sync"></a>6.6 为裸指针实现Sync</h2><p>由于Sync是多线程间共享一个值，大家可能会想这么实现：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-number">5</span>;    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,&amp;v);    &#125;);    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;</code></pre></div><p>关于这种用法，在多线程章节也提到过，线程如果直接去借用其它线程的变量，会报错:closure may outlive the current function,, 原因在于编译器无法确定主线程main和子线程t谁的生命周期更长，特别是当两个线程都是子线程时，没有任何人知道哪个子线程会先结束，包括编译器！</p><p>因此我们得配合Arc去使用:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">use</span> std::sync::Arc;<span class="hljs-keyword">use</span> std::sync::Mutex;<span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>(*<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>);<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span> &#123;&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = &amp;<span class="hljs-title function_ invoke__">MyBox</span>(<span class="hljs-number">5</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>);    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(b));    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">_v1</span> =  v.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;);    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;</code></pre></div><p>上面代码将智能指针v的所有权转移给新线程，同时v包含了一个引用类型b，当在新的线程中试图获取内部的引用时，会报错：</p><p>因为我们访问的引用实际上还是对主线程中的数据的借用，转移进来的仅仅是外层的智能指针引用。要解决很简单，为MyBox实现Sync:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span> &#123;&#125;</code></pre></div><h2 id="6-7-总结"><a href="#6-7-总结" class="headerlink" title="6.7 总结"></a>6.7 总结</h2><p>通过上面的两个裸指针的例子，我们了解了如何实现Send和Sync，以及如何只实现Send而不实现Sync，简单总结下：</p><ul><li>实现Send的类型可以在线程间安全的传递其所有权, 实现Sync的类型可以在线程间安全的共享(通过引用)</li><li>绝大部分类型都实现了Send和Sync，常见的未实现的有：裸指针、Cell、RefCell、Rc 等</li><li>可以为自定义类型实现Send和Sync，但是需要unsafe代码块</li><li>可以为部分 Rust 中的类型实现Send、Sync，但是需要使用newtype，例如文中的裸指针例子</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>rust圣经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RUST圣经-高阶学习-多线程并发和异步-上</title>
    <link href="/2025/02/21/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5-%E4%B8%8A/"/>
    <url>/2025/02/21/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1 并发和并行"></a>1 并发和并行</h2><ul><li>并发(Concurrent) 是多个队列使用同一个咖啡机，然后两个队列轮换着使用（未必是 1:1 轮换，也可能是其它轮换规则），最终每个人都能接到咖啡</li><li>并行(Parallel) 是每个队列都拥有一个咖啡机，最终也是每个人都能接到咖啡，但是效率更高，因为同时可以有两个人在接咖啡</li></ul><p>正式的定义（该定义摘选自&lt;&lt;并发的艺术&gt;&gt;）</p><p>如果某个系统支持两个或者多个动作的同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。</p><p><strong>“并行”概念是“并发”概念的一个子集。</strong></p><p>你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。</p><h2 id="1-1-编程语言的并发模型"><a href="#1-1-编程语言的并发模型" class="headerlink" title="1.1 编程语言的并发模型"></a>1.1 编程语言的并发模型</h2><ul><li>由于操作系统提供了创建线程的 API，因此部分语言会直接调用该 API 来创建线程，因此最终程序内的线程数和该程序占用的操作系统线程数相等，一般称之为1:1 线程模型，例如 Rust。</li><li>还有些语言在内部实现了自己的线程模型（绿色线程、协程），程序内部的 M 个线程最后会以某种映射方式使用 N 个操作系统线程去运行，因此称之为M:N 线程模型，其中 M 和 N 并没有特定的彼此限制关系。一个典型的代表就是 Go 语言。</li><li>还有些语言使用了 Actor 模型，基于消息传递进行并发，例如 Erlang 语言。</li></ul><p>每一种模型都有其优缺点及选择上的权衡，而 Rust 在设计时考虑的权衡就是运行时(Runtime)。出于 Rust 的系统级使用场景，且要保证调用 C 时的极致性能，它最终选择了尽量小的运行时实现。</p><p>绿色线程&#x2F;协程的实现会显著增大运行时的大小，因此 Rust 只在标准库中提供了 1:1 的线程模型，如果你愿意牺牲一些性能来换取更精确的线程控制以及更小的线程上下文切换成本，那么可以选择 Rust 中的 M:N 模型，这些模型由三方库提供了实现，例如大名鼎鼎的 tokio。</p><h2 id="2-使用多线程"><a href="#2-使用多线程" class="headerlink" title="2 使用多线程"></a>2 使用多线程</h2><h2 id="2-1-多线程编程的风险"><a href="#2-1-多线程编程的风险" class="headerlink" title="2.1 多线程编程的风险"></a>2.1 多线程编程的风险</h2><p>多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：</p><ul><li>竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源</li><li>死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行</li><li>一些因为多线程导致的很隐晦的 BUG，难以复现和解决</li></ul><h2 id="2-2-创建线程"><a href="#2-2-创建线程" class="headerlink" title="2.2 创建线程"></a>2.2 创建线程</h2><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">use</span> std::thread;<span class="hljs-selector-tag">use</span> std::time::Duration;fn <span class="hljs-selector-tag">main</span>() &#123;    thread::<span class="hljs-built_in">spawn</span>(|| &#123;        for <span class="hljs-selector-tag">i</span> in <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;            println!(&quot;hi number &#123;&#125; <span class="hljs-selector-tag">from</span> the spawned thread!&quot;, <span class="hljs-selector-tag">i</span>);            thread::<span class="hljs-built_in">sleep</span>(Duration::<span class="hljs-built_in">from_millis</span>(<span class="hljs-number">1</span>));        &#125;    &#125;);    for <span class="hljs-selector-tag">i</span> in <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;        println!(&quot;hi number &#123;&#125; <span class="hljs-selector-tag">from</span> the <span class="hljs-selector-tag">main</span> thread!&quot;, <span class="hljs-selector-tag">i</span>);        thread::<span class="hljs-built_in">sleep</span>(Duration::<span class="hljs-built_in">from_millis</span>(<span class="hljs-number">1</span>));    &#125;&#125;</code></pre></div><p>有几点值得注意：</p><ul><li>线程内部的代码使用闭包来执行</li><li>main 线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务</li><li>thread::sleep 会让当前线程休眠指定的时间，随后其它线程会被调度运行，因此就算你的电脑只有一个 CPU 核心，该程序也会表现的如同多 CPU 核心一般，这就是并发！</li></ul><h2 id="2-3-等待子线程的结束"><a href="#2-3-等待子线程的结束" class="headerlink" title="2.3 等待子线程的结束"></a>2.3 等待子线程的结束</h2><p>上面的代码你不但可能无法让子线程从 1 顺序打印到 10，而且可能打印的数字会变少，因为主线程会提前结束，导致子线程也随之结束，更过分的是，如果当前系统繁忙，甚至该子线程还没被创建，主线程就已经结束了！</p><div class="code-wrapper"><pre><code class="hljs lasso">use std<span class="hljs-type">::thread</span>;use std<span class="hljs-type">::time</span><span class="hljs-type">::Duration</span>;fn main() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">handle</span> = <span class="hljs-keyword">thread</span><span class="hljs-type">::spawn</span>(|| &#123;        for i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span> &#123;            println!(<span class="hljs-string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);            <span class="hljs-keyword">thread</span><span class="hljs-type">::sleep</span>(<span class="hljs-built_in">Duration</span><span class="hljs-type">::from_millis</span>(<span class="hljs-number">1</span>));        &#125;    &#125;);    <span class="hljs-keyword">handle</span>.<span class="hljs-keyword">join</span>().unwrap();    for i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span> &#123;        println!(<span class="hljs-string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);        <span class="hljs-keyword">thread</span><span class="hljs-type">::sleep</span>(<span class="hljs-built_in">Duration</span><span class="hljs-type">::from_millis</span>(<span class="hljs-number">1</span>));    &#125;&#125;</code></pre></div><p>通过调用 handle.join，可以让当前线程阻塞，直到它等待的子线程的结束，在上面代码中，由于 main 线程会被阻塞，因此它直到子线程结束后才会输出自己的 1..5：</p><p>在Java中有守护线程守护用户线程，等待所有的用户线程退出后守护线程退出</p><ul><li>1.守护线程是用来为用户线程服务的，当一个程序中的所有用户线程都结束之后，无论守护线程是否在工作都会跟随用户线程一起结束；</li><li>2.守护线程的子线程也是守护线程；</li><li>3.守护线程的优先级和用户线程优先级一致；</li><li>4.守护线程setDaemon(true) 如果设置在 start() 之后，程序执行会报错，守护线程也不会生效。</li></ul><p>主线程就是主线程不是守护线程也不是用户线程</p><h2 id="2-4-在线程闭包中使用move"><a href="#2-4-在线程闭包中使用move" class="headerlink" title="2.4 在线程闭包中使用move"></a>2.4 在线程闭包中使用move</h2><p>可以使用 move 来将所有权从一个线程转移到另外一个线程。</p><p>不用move会报错</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);    &#125;);    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;</code></pre></div><p>代码本身并没有什么问题，问题在于 Rust 无法确定新的线程会活多久（多个线程的结束顺序并不是固定的），所以也无法确定新线程所引用的 v 是否在使用过程中一直合法：</p><p>有可能发生如下情况</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);    &#125;);    <span class="hljs-title function_ invoke__">drop</span>(v); <span class="hljs-comment">// oh no!</span>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;</code></pre></div><p>线程的启动时间点和结束时间点是不确定的，因此存在一种可能，当主线程执行完， v 被释放掉时，新的线程很可能还没有结束甚至还没有被创建成功，此时新线程对 v 的引用立刻就不再合法！</p><h2 id="2-5-线程是如何结束的"><a href="#2-5-线程是如何结束的" class="headerlink" title="2.5 线程是如何结束的"></a>2.5 线程是如何结束的</h2><p>main 线程是程序的主线程，一旦结束，则程序随之结束，同时各个子线程也将被强行终止。</p><p>如果父线程不是 main 线程，那么父线程的结束会导致什么？自生自灭还是被干掉？</p><p>系统编程中，操作系统提供了直接杀死线程的接口，简单粗暴，但是 Rust 并没有提供这样的接口，原因在于，粗暴地终止一个线程可能会导致资源没有释放、状态混乱等不可预期的结果。</p><p>那么 Rust 中线程是如何结束的呢？答案很简单：线程的代码执行完，线程就会自动结束。但是如果线程中的代码不会执行完呢？那么情况可以分为两种进行讨论：</p><ul><li>线程的任务是一个循环 IO 读取，任务流程类似：IO 阻塞，等待读取新的数据 -&gt; 读到数据，处理完成 -&gt; 继续阻塞等待 ··· -&gt; 收到 socket 关闭的信号 -&gt; 结束线程，在此过程中，绝大部分时间线程都处于阻塞的状态，因此虽然看上去是循环，CPU 占用其实很小，也是网络服务中最最常见的模型</li><li>线程的任务是一个循环，里面没有任何阻塞，包括休眠这种操作也没有，此时 CPU 很不幸的会被跑满，而且你如果没有设置终止条件，该线程将持续跑满一个 CPU 核心，并且不会被终止，直到 main 线程的结束</li></ul><h2 id="2-6-多线程的性能"><a href="#2-6-多线程的性能" class="headerlink" title="2.6 多线程的性能"></a>2.6 多线程的性能</h2><h3 id="2-6-1-创建线程的性能"><a href="#2-6-1-创建线程的性能" class="headerlink" title="2.6.1 创建线程的性能"></a>2.6.1 创建线程的性能</h3><p>大概需要0.24ms，线程的创建耗时是不可忽略的，只有当真的需要处理一个值得用线程去处理的任务时，才使用线程，一些鸡毛蒜皮的任务，就无需创建线程了。</p><h3 id="2-6-2-创建多少线程合适"><a href="#2-6-2-创建多少线程合适" class="headerlink" title="2.6.2 创建多少线程合适"></a>2.6.2 创建多少线程合适</h3><p>当任务是 CPU 密集型时，就算线程数超过了 CPU 核心数，也并不能帮你获得更好的性能。因为每个线程的任务都可以轻松让 CPU 的某个核心跑满，既然如此，让线程数等于 CPU 核心数是最好的。</p><p>当你的任务大部分时间都处于阻塞状态时，就可以考虑增多线程数量，这样当某个线程处于阻塞状态时，会被切走，进而运行其它的线程，典型就是网络 IO 操作，我们可以为每一个进来的用户连接创建一个线程去处理，该连接绝大部分时间都是处于 IO 读取阻塞状态，因此有限的 CPU 核心完全可以处理成百上千的用户连接线程，但是事实上，对于这种网络 IO 情况，一般都不再使用多线程的方式了，毕竟操作系统的线程数是有限的，意味着并发数也很容易达到上限，而且过多的线程也会导致线程上下文切换的代价过大，使用 async&#x2F;await 的 M:N 并发模型，就没有这个烦恼。</p><h3 id="2-6-3-多线程的开销"><a href="#2-6-3-多线程的开销" class="headerlink" title="2.6.3 多线程的开销"></a>2.6.3 多线程的开销</h3><ul><li>虽然是无锁，但是内部是 CAS 实现，大量线程的同时访问，会让 CAS 重试次数大幅增加</li><li>线程过多时，CPU 缓存的命中率会显著下降，同时多个线程竞争一个 CPU Cache-line 的情况也会经常发生</li><li>大量读写可能会让内存带宽也成为瓶颈</li><li>读和写不一样，无锁数据结构的读往往可以很好地线性增长，但是写不行，因为写竞争太大多线程的开销往往是在锁、数据竞争、缓存失效上，这些限制了现代化软件系统随着 CPU 核心的增多性能也线性增加的野心。</li></ul><h2 id="2-7-线程屏障"><a href="#2-7-线程屏障" class="headerlink" title="2.7 线程屏障"></a>2.7 线程屏障</h2><p>在 Rust 中，可以使用 Barrier 让多个线程都执行到某个点后，才继续一起往后执行：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Barrier&#125;;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">6</span>);    <span class="hljs-keyword">let</span> <span class="hljs-variable">barrier</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Barrier::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">6</span>));    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">6</span> &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = barrier.<span class="hljs-title function_ invoke__">clone</span>();        handles.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;before wait&quot;</span>);            b.<span class="hljs-title function_ invoke__">wait</span>();            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;after wait&quot;</span>);        &#125;));    &#125;    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;&#125;</code></pre></div><p>上面代码，我们在线程打印出 before wait 后增加了一个屏障，目的就是等所有的线程都打印出before wait后，各个线程再继续执行：</p><h2 id="2-8-线程局部变量（Thread-Local-Variable）"><a href="#2-8-线程局部变量（Thread-Local-Variable）" class="headerlink" title="2.8 线程局部变量（Thread Local Variable）"></a>2.8 线程局部变量（Thread Local Variable）</h2><p>对于多线程编程，线程局部变量在一些场景下非常有用，而 Rust 通过标准库和三方库对此进行了支持。</p><h3 id="2-8-1标准库-thread-local"><a href="#2-8-1标准库-thread-local" class="headerlink" title="2.8.1标准库 thread_local"></a>2.8.1标准库 thread_local</h3><p>使用 thread_local 宏可以初始化线程局部变量，然后在线程内部使用该变量的 with 方法获取变量值：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<span class="hljs-keyword">use</span> std::thread;thread_local!(<span class="hljs-keyword">static</span> FOO: RefCell&lt;<span class="hljs-type">u32</span>&gt; = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>));FOO.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;    <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">1</span>);    *f.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">2</span>;&#125;);<span class="hljs-comment">// 每个线程开始时都会拿到线程局部变量的FOO的初始值</span><span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;    FOO.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;        <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">1</span>);        *f.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">3</span>;    &#125;);&#125;);<span class="hljs-comment">// 等待线程完成</span>t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<span class="hljs-comment">// 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2</span>FOO.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;    <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">2</span>);&#125;);</code></pre></div><p>上面代码中，FOO 即是我们创建的线程局部变量，每个新的线程访问它时，都会使用它的初始值作为开始，各个线程中的 FOO 值彼此互不干扰。注意 FOO 使用 static 声明为生命周期为 ‘static 的静态变量。<br>线程中对 FOO 的使用是通过借用的方式，但是若我们需要每个线程独自获取它的拷贝，最后进行汇总，就有些强人所难了。</p><p>还可以在结构体中使用线程局部变量：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> &#123;    thread_local! &#123;        <span class="hljs-keyword">static</span> FOO: RefCell&lt;<span class="hljs-type">usize</span>&gt; = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);    &#125;&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    Foo::FOO.<span class="hljs-title function_ invoke__">with</span>(|x| <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, x));&#125;</code></pre></div><p>或者通过引用的方式使用它:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<span class="hljs-keyword">use</span> std::thread::LocalKey;thread_local! &#123;    <span class="hljs-keyword">static</span> FOO: RefCell&lt;<span class="hljs-type">usize</span>&gt; = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bar</span> &#123;    foo: &amp;<span class="hljs-symbol">&#x27;static</span> LocalKey&lt;RefCell&lt;<span class="hljs-type">usize</span>&gt;&gt;,&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Bar</span> &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">constructor</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;        <span class="hljs-keyword">Self</span> &#123;            foo: &amp;FOO,        &#125;    &#125;&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">bar</span> = Bar::<span class="hljs-title function_ invoke__">constructor</span>();    bar.foo.<span class="hljs-title function_ invoke__">with</span>(|f| &#123;        <span class="hljs-built_in">assert_eq!</span>(*f.<span class="hljs-title function_ invoke__">borrow</span>(), <span class="hljs-number">1</span>);        *f.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-number">2</span>;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, *f);    &#125;);&#125;</code></pre></div><h3 id="2-8-2-三方库-thread-local"><a href="#2-8-2-三方库-thread-local" class="headerlink" title="2.8.2 三方库 thread-local"></a>2.8.2 三方库 thread-local</h3><p>除了标准库外，一位大神还开发了 thread-local 库，它允许每个线程持有值的独立拷贝：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> thread_local::ThreadLocal;<span class="hljs-keyword">use</span> std::sync::Arc;<span class="hljs-keyword">use</span> std::cell::Cell;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">let</span> <span class="hljs-variable">tls</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(ThreadLocal::<span class="hljs-title function_ invoke__">new</span>());<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[];<span class="hljs-comment">// 创建多个线程</span><span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">5</span> &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">tls2</span> = tls.<span class="hljs-title function_ invoke__">clone</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-comment">// 将计数器加1</span>        <span class="hljs-comment">// 请注意，由于线程 ID 在线程退出时会被回收，因此一个线程有可能回收另一个线程的对象</span>        <span class="hljs-comment">// 这只能在线程退出后发生，因此不会导致任何竞争条件</span>        <span class="hljs-keyword">let</span> <span class="hljs-variable">cell</span> = tls2.<span class="hljs-title function_ invoke__">get_or</span>(|| Cell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));        cell.<span class="hljs-title function_ invoke__">set</span>(cell.<span class="hljs-title function_ invoke__">get</span>() + <span class="hljs-number">1</span>);    &#125;);    v.<span class="hljs-title function_ invoke__">push</span>(handle);&#125;<span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> v &#123;    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;<span class="hljs-comment">// 一旦所有子线程结束，收集它们的线程局部变量中的计数器值，然后进行求和</span><span class="hljs-keyword">let</span> <span class="hljs-variable">tls</span> = Arc::<span class="hljs-title function_ invoke__">try_unwrap</span>(tls).<span class="hljs-title function_ invoke__">unwrap</span>();<span class="hljs-keyword">let</span> <span class="hljs-variable">total</span> = tls.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">fold</span>(<span class="hljs-number">0</span>, |x, y| &#123;    <span class="hljs-comment">// 打印每个线程局部变量中的计数器值，发现不一定有5个线程，</span>    <span class="hljs-comment">// 因为一些线程已退出，并且其他线程会回收退出线程的对象</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, x, y.<span class="hljs-title function_ invoke__">get</span>());    x + y.<span class="hljs-title function_ invoke__">get</span>()&#125;);<span class="hljs-comment">// 和为5</span><span class="hljs-built_in">assert_eq!</span>(total, <span class="hljs-number">5</span>);</code></pre></div><p>该库不仅仅使用了值的拷贝，而且还能自动把多个拷贝汇总到一个迭代器中，最后进行求和，非常好用。</p><p>用条件控制线程的挂起和执行</p><p>条件变量(Condition Variables)经常和 Mutex 一起使用，可以让线程挂起，直到某个条件发生后再继续执行：</p><h2 id="2-9-用条件控制线程的挂起和执行"><a href="#2-9-用条件控制线程的挂起和执行" class="headerlink" title="2.9 用条件控制线程的挂起和执行"></a>2.9 用条件控制线程的挂起和执行</h2><p>条件变量(Condition Variables)经常和 Mutex 一起使用，可以让线程挂起，直到某个条件发生后再继续执行：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex, Condvar&#125;;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair</span> = Arc::<span class="hljs-title function_ invoke__">new</span>((Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>), Condvar::<span class="hljs-title function_ invoke__">new</span>()));    <span class="hljs-keyword">let</span> <span class="hljs-variable">pair2</span> = pair.<span class="hljs-title function_ invoke__">clone</span>();    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;        <span class="hljs-keyword">let</span> (lock, cvar) = &amp;*pair2;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">started</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;changing started&quot;</span>);        *started = <span class="hljs-literal">true</span>;        cvar.<span class="hljs-title function_ invoke__">notify_one</span>();    &#125;);    <span class="hljs-keyword">let</span> (lock, cvar) = &amp;*pair;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">started</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    <span class="hljs-keyword">while</span> !*started &#123;        started = cvar.<span class="hljs-title function_ invoke__">wait</span>(started).<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;started changed&quot;</span>);&#125;</code></pre></div><p>上述代码流程如下：</p><p>main 线程首先进入 while 循环，调用 wait 方法挂起等待子线程的通知，并释放了锁 started 子线程获取到锁，并将其修改为 true，然后调用条件变量的 notify_one 方法来通知主线程继续执行</p><h2 id="2-10-只被调用一次的函数"><a href="#2-10-只被调用一次的函数" class="headerlink" title="2.10 只被调用一次的函数"></a>2.10 只被调用一次的函数</h2><p>有时，我们会需要某个函数在多线程环境下只被调用一次，例如初始化全局变量，无论是哪个线程先调用函数来初始化，都会保证全局变量只会被初始化一次，随后的其它线程调用就会忽略该函数：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">use</span> std::sync::Once;<span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> VAL: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>;<span class="hljs-keyword">static</span> INIT: Once = Once::<span class="hljs-title function_ invoke__">new</span>();<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        INIT.<span class="hljs-title function_ invoke__">call_once</span>(|| &#123;            <span class="hljs-keyword">unsafe</span> &#123;                VAL = <span class="hljs-number">1</span>;            &#125;        &#125;);    &#125;);    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        INIT.<span class="hljs-title function_ invoke__">call_once</span>(|| &#123;            <span class="hljs-keyword">unsafe</span> &#123;                VAL = <span class="hljs-number">2</span>;            &#125;        &#125;);    &#125;);    handle1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    handle2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; VAL &#125;);&#125;</code></pre></div><p>代码运行的结果取决于哪个线程先调用 INIT.call_once （虽然代码具有先后顺序，但是线程的初始化顺序并无法被保证！因为线程初始化是异步的，且耗时较久），若 handle1 先，则输出 1，否则输出 2。</p><p>call_once 方法</p><p>执行初始化过程一次，并且只执行一次。</p><p>如果当前有另一个初始化过程正在运行，线程将阻止该方法被调用。</p><p>当这个函数返回时，保证一些初始化已经运行并完成，它还保证由执行的闭包所执行的任何内存写入都能被其他线程在这时可靠地观察到。</p><h2 id="2-11-总结"><a href="#2-11-总结" class="headerlink" title="2.11 总结"></a>2.11 总结</h2><p>Rust 的线程模型是 1:1 模型，因为 Rust 要保持尽量小的运行时。</p><p>我们可以使用 thread::spawn 来创建线程，创建出的多个线程 之间并不存在执行顺序关系，因此代码逻辑千万不要依赖于线程间的执行顺序。</p><p>main 线程若是结束，则所有子线程都将被终止，如果希望等待子线程结束后，再结束 main 线程，你需要使用创建线程时返回的句柄的 join 方法。</p><p>在线程中无法直接借用外部环境中的变量值，因为新线程的启动时间点和结束时间点是不确定的，所以 Rust 无法保证该线程中借用的变量在使用过程中依然是合法的。你可以使用 move 关键字将变量的所有权转移给新的线程，来解决此问题。</p><p>父线程结束后，子线程仍在持续运行，直到子线程的代码运行完成或者 main 线程的结束。</p><h2 id="3-线程间的消息传递"><a href="#3-线程间的消息传递" class="headerlink" title="3 线程间的消息传递"></a>3 线程间的消息传递</h2><p>在多线程间有多种方式可以共享、传递数据，最常用的方式就是通过消息传递或者将锁和Arc联合使用，而对于前者，在编程界还有一个大名鼎鼎的Actor线程模型为其背书，典型的有 Erlang 语言，还有 Go 语言中很经典的一句话：</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">Do</span> <span class="hljs-keyword">not</span> communicate <span class="hljs-keyword">by</span> sharing memory; <span class="hljs-keyword">instead</span>, <span class="hljs-keyword">share</span> memory <span class="hljs-keyword">by</span> communicating</code></pre></div><h2 id="3-1-消息通道"><a href="#3-1-消息通道" class="headerlink" title="3.1 消息通道"></a>3.1 消息通道</h2><p>Rust 是在标准库里提供了消息通道(channel)，你可以将其想象成一场直播，多个主播联合起来在搞一场直播，最终内容通过通道传输给屏幕前的我们，其中主播被称之为发送者，观众被称之为接收者，显而易见的是：一个通道应该支持多个发送者和接收者。</p><p>但是，在实际使用中，我们需要使用不同的库来满足诸如：多发送者 -&gt; 单接收者，多发送者 -&gt; 多接收者等场景形式，此时一个标准库显然就不够了。</p><h2 id="3-2-多发送者，单接收者"><a href="#3-2-多发送者，单接收者" class="headerlink" title="3.2 多发送者，单接收者"></a>3.2 多发送者，单接收者</h2><p>标准库提供了通道std::sync::mpsc，其中mpsc是multiple producer, single consumer的缩写，代表了该通道支持多个发送者，但是只支持唯一的接收者。</p><p>当然，支持多个发送者也意味着支持单个发送者，我们先来看看单发送者、单接收者的简单例子:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-comment">// 创建一个消息通道, 返回一个元组：(发送者，接收者)</span>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();    <span class="hljs-comment">// 创建线程，并发送消息</span>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-comment">// 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span>        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>();        <span class="hljs-comment">// 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span>        <span class="hljs-comment">// tx.send(Some(1)).unwrap()</span>    &#125;);    <span class="hljs-comment">// 在主线程中接收子线程发送的消息并输出</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>());&#125;</code></pre></div><ul><li>tx,rx对应发送者和接收者，它们的类型由编译器自动推导: tx.send(1)发送了整数，因此它们分别是mpsc::Sender<i32>和mpsc::Receiver<i32>类型，需要注意，由于内部是泛型实现，一旦类型被推导确定，该通道就只能传递对应类型的值, 例如此例中非i32类型的值将导致编译错误</li><li>接收消息的操作rx.recv()会阻塞当前线程，直到读取到值，或者通道被关闭</li><li>需要使用move将tx的所有权转移到子线程的闭包中</li></ul><p>在注释中提到send方法返回一个Result&lt;T,E&gt;，说明它有可能返回一个错误，例如接收者被drop导致了发送的值不会被任何人接收，此时继续发送毫无意义，因此返回一个错误最为合适，在代码中我们仅仅使用unwrap进行了快速处理，但在实际项目中你需要对错误进行进一步的处理。</p><p>同样的，对于recv方法来说，当发送者关闭时，它也会接收到一个错误，用于说明不会再有任何值被发送过来。</p><h2 id="3-3-不阻塞的-try-recv-方法"><a href="#3-3-不阻塞的-try-recv-方法" class="headerlink" title="3.3 不阻塞的 try_recv 方法"></a>3.3 不阻塞的 try_recv 方法</h2><p>除了上述recv方法，还可以使用try_recv尝试接收一次消息，该方法并不会阻塞线程，当通道中没有消息时，它会立刻返回一个错误：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;);    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="hljs-title function_ invoke__">try_recv</span>());&#125;</code></pre></div><p>由于子线程的创建需要时间，因此println!和try_recv方法会先执行，而此时子线程的消息还未被发出。try_recv会尝试立即读取一次消息，因为消息没有发出，此次读取最终会报错，且主线程运行结束(</p><p>可悲的是，相对于主线程中的代码，子线程的创建速度实在是过慢，直到主线程结束，都无法完成子线程的初始化。</p><h2 id="3-4-传输具有所有权的数据"><a href="#3-4-传输具有所有权的数据" class="headerlink" title="3.4 传输具有所有权的数据"></a>3.4 传输具有所有权的数据</h2><p>使用通道来传输数据，一样要遵循 Rust 的所有权规则：</p><ul><li>若值的类型实现了Copy特征，则直接复制一份该值，然后传输过去，例如之前的i32类型</li><li>若值没有实现Copy，则它的所有权会被转移给接收端，在发送端继续使用该值将报错</li></ul><p>第二种情况</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;我，飞走咯!&quot;</span>);        tx.<span class="hljs-title function_ invoke__">send</span>(s).<span class="hljs-title function_ invoke__">unwrap</span>();        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;val is &#123;&#125;&quot;</span>, s);    &#125;);    <span class="hljs-keyword">let</span> <span class="hljs-variable">received</span> = rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);&#125;</code></pre></div><p>以上代码中，String底层的字符串是存储在堆上，并没有实现Copy特征，当它被发送后，会将所有权从发送端的s转移给接收端的received，之后s将无法被使用:</p><h2 id="3-5-使用for进行循环接收"><a href="#3-5-使用for进行循环接收" class="headerlink" title="3.5 使用for进行循环接收"></a>3.5 使用for进行循环接收</h2><p>下面来看看如何连续接收通道中的值:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">use</span> std::time::Duration;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>),            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;from&quot;</span>),            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;the&quot;</span>),            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;thread&quot;</span>),        ];        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals &#123;            tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));        &#125;    &#125;);    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);    &#125;&#125;</code></pre></div><p>在上面代码中，主线程和子线程是并发运行的，子线程在不停的发送消息 -&gt; 休眠 1 秒，与此同时，主线程使用for循环阻塞的从rx迭代器中接收消息，当子线程运行完成时，发送者tx会随之被drop，此时for循环将被终止，最终main线程成功结束。</p><h3 id="3-5-1-使用多发送者"><a href="#3-5-1-使用多发送者" class="headerlink" title="3.5.1 使用多发送者"></a>3.5.1 使用多发送者</h3><p>由于子线程会拿走发送者的所有权，因此我们必须对发送者进行克隆，然后让每个线程拿走它的一份拷贝:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">tx1</span> = tx.<span class="hljs-title function_ invoke__">clone</span>();    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi from raw tx&quot;</span>)).<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;);    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        tx1.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi from cloned tx&quot;</span>)).<span class="hljs-title function_ invoke__">unwrap</span>();    &#125;);    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);    &#125;&#125;</code></pre></div><p>有几点需要注意:</p><ul><li>需要所有的发送者都被drop掉后，接收者rx才会收到错误，进而跳出for循环，最终结束主线程</li><li>这里虽然用了clone但是并不会影响性能，因为它并不在热点代码路径中，仅仅会被执行一次</li><li>由于两个子线程谁先创建完成是未知的，因此哪条消息先发送也是未知的，最终主线程的输出顺序也不确定</li></ul><h2 id="3-6-消息顺序"><a href="#3-6-消息顺序" class="headerlink" title="3.6 消息顺序"></a>3.6 消息顺序</h2><p>上述第三点的消息顺序仅仅是因为线程创建引起的，并不代表通道中的消息是无序的，对于通道而言，消息的发送顺序和接收顺序是一致的，满足FIFO原则(先进先出)。</p><h2 id="3-7-同步和异步通道"><a href="#3-7-同步和异步通道" class="headerlink" title="3.7 同步和异步通道"></a>3.7 同步和异步通道</h2><p>Rust 标准库的mpsc通道其实分为两种类型：同步和异步。</p><h3 id="3-7-1-异步通道"><a href="#3-7-1-异步通道" class="headerlink" title="3.7.1 异步通道"></a>3.7.1 异步通道</h3><p>之前我们使用的都是异步通道：无论接收者是否正在接收消息，消息发送者在发送消息时都不会阻塞:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">use</span> std::time::Duration;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> (tx, rx)= mpsc::<span class="hljs-title function_ invoke__">channel</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;发送之前&quot;</span>);        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>();        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;发送之后&quot;</span>);    &#125;);    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;睡眠之前&quot;</span>);    thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">3</span>));    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;睡眠之后&quot;</span>);    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>());    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;</code></pre></div><p>主线程因为睡眠阻塞了 3 秒，因此并没有进行消息接收，而子线程却在此期间轻松完成了消息的发送。等主线程睡眠结束后，才姗姗来迟的从通道中接收了子线程老早之前发送的消息。</p><p>从输出还可以看出，发送之前和发送之后是连续输出的，没有受到接收端主线程的任何影响，因此通过mpsc::channel创建的通道是异步通道。</p><h3 id="3-7-2-同步通道"><a href="#3-7-2-同步通道" class="headerlink" title="3.7.2 同步通道"></a>3.7.2 同步通道</h3><p>与异步通道相反，同步通道发送消息是阻塞的，只有在消息被接收后才解除阻塞，例如：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<span class="hljs-keyword">use</span> std::thread;<span class="hljs-keyword">use</span> std::time::Duration;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> (tx, rx)= mpsc::<span class="hljs-title function_ invoke__">sync_channel</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;发送之前&quot;</span>);        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>();        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;发送之后&quot;</span>);    &#125;);    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;睡眠之前&quot;</span>);    thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">3</span>));    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;睡眠之后&quot;</span>);    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>());    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;</code></pre></div><p>主线程由于睡眠被阻塞导致无法接收消息，因此子线程的发送也一直被阻塞，直到主线程结束睡眠并成功接收消息后，发送才成功：发送之后的输出是在receive 1之后，说明只有接收消息彻底成功后，发送消息才算完成。</p><h3 id="3-7-3-消息缓存"><a href="#3-7-3-消息缓存" class="headerlink" title="3.7.3 消息缓存"></a>3.7.3 消息缓存</h3><p>在创建同步通道时，我们传递了一个参数0: mpsc::sync_channel(0);，这是什么意思呢？</p><p>该值可以用来指定同步通道的消息缓存条数，当你设定为N时，发送者就可以无阻塞的往通道中发送N条消息，当消息缓冲队列满了后，新的消息发送将被阻塞(如果没有接收者消费缓冲队列中的消息，那么第N+1条消息就将触发发送阻塞)。</p><p>异步通道的缓冲上限取决于你的内存大小，不要撑爆就行。</p><p>使用异步消息虽然能非常高效且不会造成发送线程的阻塞，但是存在消息未及时消费，最终内存过大的问题。在实际项目中，可以考虑使用一个带缓冲值的同步通道来避免这种风险。</p><h2 id="3-8-关闭通道"><a href="#3-8-关闭通道" class="headerlink" title="3.8 关闭通道"></a>3.8 关闭通道</h2><p>所有发送者被drop或者所有接收者被drop后，通道会自动关闭。</p><p>这件事是在编译期实现的，完全没有运行期性能损耗！</p><h2 id="3-9-传输多种类型的数据"><a href="#3-9-传输多种类型的数据" class="headerlink" title="3.9 传输多种类型的数据"></a>3.9 传输多种类型的数据</h2><p>一个消息通道只能传输一种类型的数据，如果你想要传输多种类型的数据，可以为每个类型创建一个通道，你也可以使用枚举类型来实现：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc::&#123;<span class="hljs-keyword">self</span>, Receiver, Sender&#125;;<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Fruit</span> &#123;    <span class="hljs-title function_ invoke__">Apple</span>(<span class="hljs-type">u8</span>),    <span class="hljs-title function_ invoke__">Orange</span>(<span class="hljs-type">String</span>)&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> (tx, rx): (Sender&lt;Fruit&gt;, Receiver&lt;Fruit&gt;) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();    tx.<span class="hljs-title function_ invoke__">send</span>(Fruit::<span class="hljs-title function_ invoke__">Orange</span>(<span class="hljs-string">&quot;sweet&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())).<span class="hljs-title function_ invoke__">unwrap</span>();    tx.<span class="hljs-title function_ invoke__">send</span>(Fruit::<span class="hljs-title function_ invoke__">Apple</span>(<span class="hljs-number">2</span>)).<span class="hljs-title function_ invoke__">unwrap</span>();    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">2</span> &#123;        <span class="hljs-keyword">match</span> rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#123;            Fruit::<span class="hljs-title function_ invoke__">Apple</span>(count) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;received &#123;&#125; apples&quot;</span>, count),            Fruit::<span class="hljs-title function_ invoke__">Orange</span>(flavor) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;received &#123;&#125; oranges&quot;</span>, flavor),        &#125;    &#125;&#125;</code></pre></div><p>枚举类型还能让我们带上想要传输的数据，Rust 会按照枚举中占用内存最大的那个成员进行内存对齐，这意味着就算你传输的是枚举中占用内存最小的成员，它占用的内存依然和最大的成员相同, 因此会造成内存上的浪费。</p><h2 id="3-10-新手容易遇到的坑"><a href="#3-10-新手容易遇到的坑" class="headerlink" title="3.10 新手容易遇到的坑"></a>3.10 新手容易遇到的坑</h2><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">use</span> std::thread;    <span class="hljs-keyword">let</span> (send, recv) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();    <span class="hljs-keyword">let</span> <span class="hljs-variable">num_threads</span> = <span class="hljs-number">3</span>;    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..num_threads &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">thread_send</span> = send.<span class="hljs-title function_ invoke__">clone</span>();        thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;            thread_send.<span class="hljs-title function_ invoke__">send</span>(i).<span class="hljs-title function_ invoke__">unwrap</span>();            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread &#123;:?&#125; finished&quot;</span>, i);        &#125;);    &#125;    <span class="hljs-comment">// 在这里drop send...</span>    <span class="hljs-keyword">for</span> <span class="hljs-variable">x</span> <span class="hljs-keyword">in</span> recv &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, x);    &#125;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;finished iterating&quot;</span>);&#125;</code></pre></div><p>以上代码看起来非常正常，但是运行后主线程会一直阻塞，最后一行打印输出也不会被执行，原因在于： 子线程拿走的是复制后的send的所有权，这些拷贝会在子线程结束后被drop，因此无需担心，但是send本身却直到main函数的结束才会被drop。</p><p>之前提到，通道关闭的两个条件：发送者全部drop或接收者被drop，要结束for循环显然是要求发送者全部drop，但是由于send自身没有被drop，会导致该循环永远无法结束，最终主线程会一直阻塞。</p><p>解决办法很简单，drop掉send即可：在代码中的注释下面添加一行drop(send);。</p><h2 id="3-11-mpmc-更好的性能"><a href="#3-11-mpmc-更好的性能" class="headerlink" title="3.11 mpmc 更好的性能"></a>3.11 mpmc 更好的性能</h2><p>如果你需要 mpmc(多发送者，多接收者)或者需要更高的性能，可以考虑第三方库:</p><ul><li>crossbeam-channel, 老牌强库，功能较全，性能较强，之前是独立的库，但是后面合并到了crossbeam主仓库中</li><li>flume, 官方给出的性能数据某些场景要比 crossbeam 更好些</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>rust圣经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RUST圣经-高阶学习-生命周期</title>
    <link href="/2025/02/19/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2025/02/19/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Rust-的基本借用规则"><a href="#1-Rust-的基本借用规则" class="headerlink" title="1 Rust 的基本借用规则"></a>1 Rust 的基本借用规则</h2><p>对于正常的代码实现来说，Rust中要么一个可变借用，要么多个不可变借用</p><p>我们不能对一个不可变的值进行可变借用，这会破坏 Rust 的安全性保证，相反，你可以对一个可变值进行不可变借用。<br>原因是：当值不可变时，可能会有多个不可变的引用指向它，此时若将其中一个修改为可变的，会造成可变引用与不可变引用共存的情况；而当值可变时，最多只会有一个可变引用指向它，将其修改为不可变，那么最终依然是只有一个不可变的引用指向它。</p><h2 id="2-Rust-中的-static-和-const"><a href="#2-Rust-中的-static-和-const" class="headerlink" title="2 Rust 中的 static 和 const"></a>2 Rust 中的 static 和 const</h2><p>全局变量的生命周期肯定是’static，但是不代表它需要用static来声明，常量、字符串字面值等无需使用static进行声明，原因是它们已经被打包到二进制可执行文件中。</p><p>static 和 const 都用于定义全局值</p><p>常量与普通变量的区别</p><ul><li>关键字是const而不是let</li><li>定义常量必须指明类型（如 i32）不能省略</li><li>定义常量时变量的命名规则一般是全部大写</li><li>常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址</li><li>常量的赋值只能是常量表达式&#x2F;数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式</li><li>对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义</li></ul><p>静态变量</p><p>静态变量允许声明一个全局的变量，常用于全局数据统计，例如我们希望用一个变量来统计程序当前的总请求数：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> REQUEST_RECV: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;   <span class="hljs-keyword">unsafe</span> &#123;        REQUEST_RECV += <span class="hljs-number">1</span>;        <span class="hljs-built_in">assert_eq!</span>(REQUEST_RECV, <span class="hljs-number">1</span>);   &#125;&#125;</code></pre></div><p>只有在同一线程内或者不在乎数据的准确性时，才应该使用全局静态变量。</p><p>和常量相同，定义静态变量的时候必须赋值为在编译期就可以计算出的值(常量表达式&#x2F;数学表达式)，不能是运行时才能计算出的值(如函数)</p><p>static 和 const的区别</p><ol><li>可变性</li></ol><ul><li>static（静态变量）可以是 可变 (mut) 的（但访问 static mut 需要 unsafe）。</li><li>const（常量）是 不可变 的，不能使用 mut。</li></ul><ol start="2"><li>存储位置</li></ol><ul><li>static 变量存储在全局内存（.data 或 .bss 段），静态变量只有一个实例，所有的引用都会指向同一个地址，在程序运行期间一直存在。</li><li>const 没有分配存储，它的值会在 编译期直接内联 到代码中。</li></ul><ol start="3"><li>生命周期</li></ol><ul><li>static 变量有 ‘static 生命周期，即整个程序运行期间都有效。</li><li>const 变量没有存储生命周期，只是个编译期常量，它的生命周期由它所在的作用域决定。</li></ul><ol start="4"><li>可变性和线程安全</li></ol><ul><li>static mut 不安全，需要 unsafe 访问，因为多个线程可能会修改它，导致数据竞争，存储在静态变量中的值必须要实现 Sync trait。</li><li>const 始终不可变，天然线程安全。</li></ul><p>如果 static mut 需要线程安全，必须用 Mutex 或 Atomic（原子类型） 保护：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<span class="hljs-keyword">static</span> GLOBAL_COUNTER: Mutex&lt;<span class="hljs-type">i32</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = GLOBAL_COUNTER.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    *counter += <span class="hljs-number">1</span>;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Counter: &#123;&#125;&quot;</span>, counter);&#125;</code></pre></div><p>想要全局计数器、状态控制等功能，又想要线程安全的实现，原子类型是非常好的办法。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;<span class="hljs-keyword">static</span> REQUEST_RECV: AtomicUsize  = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">100</span> &#123;        REQUEST_RECV.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::Relaxed);    &#125;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;当前用户请求数&#123;:?&#125;&quot;</span>,REQUEST_RECV);&#125;</code></pre></div><p>示例：全局 ID 生成器</p><p>来看看如何使用上面的内容实现一个全局 ID 生成器:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::&#123;Ordering, AtomicUsize&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factory</span>&#123;    factory_id: <span class="hljs-type">usize</span>,&#125;<span class="hljs-keyword">static</span> GLOBAL_ID_COUNTER: AtomicUsize = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">const</span> MAX_ID: <span class="hljs-type">usize</span> = <span class="hljs-type">usize</span>::MAX / <span class="hljs-number">2</span>;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_id</span>()<span class="hljs-punctuation">-&gt;</span><span class="hljs-type">usize</span>&#123;    <span class="hljs-comment">// 检查两次溢出，否则直接加一可能导致溢出</span>    <span class="hljs-keyword">let</span> <span class="hljs-variable">current_val</span> = GLOBAL_ID_COUNTER.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed);    <span class="hljs-keyword">if</span> current_val &gt; MAX_ID&#123;        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Factory ids overflowed&quot;</span>);    &#125;    GLOBAL_ID_COUNTER.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::Relaxed);    <span class="hljs-keyword">let</span> <span class="hljs-variable">next_id</span> = GLOBAL_ID_COUNTER.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed);    <span class="hljs-keyword">if</span> next_id &gt; MAX_ID&#123;        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Factory ids overflowed&quot;</span>);    &#125;    next_id&#125;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Factory</span>&#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>()<span class="hljs-punctuation">-&gt;</span><span class="hljs-keyword">Self</span>&#123;        <span class="hljs-keyword">Self</span>&#123;            factory_id: <span class="hljs-title function_ invoke__">generate_id</span>()        &#125;    &#125;&#125;</code></pre></div><ol start="5"><li>初始化时机</li></ol><ul><li>const 必须用编译期可计算的值初始化。</li><li>static 可以使用运行时计算的值初始化,无法用函数进行静态初始化（但不能依赖 non-const 变量）。</li></ul><p>如果需要运行时初始化，应该使用 lazy_static! 或 OnceCell：</p><p>lazy_static </p><p>lazy_static是社区提供的非常强大的宏，用于懒初始化静态变量，之前的静态变量都是在编译期初始化的，因此无法使用函数调用进行赋值，而lazy_static允许我们在运行期初始化静态变量！</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<span class="hljs-keyword">use</span> lazy_static::lazy_static;lazy_static! &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> NAMES: Mutex&lt;<span class="hljs-type">String</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Sunface, Jack, Allen&quot;</span>));&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = NAMES.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();    v.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, Myth&quot;</span>);    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,v);&#125;</code></pre></div><p>使用lazy_static在每次访问静态变量时，会有轻微的性能损失，因为其内部实现用了一个底层的并发原语std::sync::Once，在每次访问该变量时，程序都会执行一次原子指令用于确认静态变量的初始化是否完成。</p><p>lazy_static宏，匹配的是static ref，所以定义的静态变量都是不可变引用</p><p>为何需要在运行期初始化一个静态变量，除了上面的全局锁，你会遇到最常见的场景就是：一个全局的动态配置，它在程序开始后，才加载数据进行初始化，最终可以让各个线程直接访问使用</p><p>再来看一个使用lazy_static实现全局缓存的例子:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> lazy_static::lazy_static;<span class="hljs-keyword">use</span> std::collections::HashMap;lazy_static! &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> HASHMAP: HashMap&lt;<span class="hljs-type">u32</span>, &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&gt; = &#123;        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();        m.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;foo&quot;</span>);        m.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;bar&quot;</span>);        m.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;baz&quot;</span>);        m    &#125;;&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-comment">// 首次访问`HASHMAP`的同时对其进行初始化</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The entry for `0` is \&quot;&#123;&#125;\&quot;.&quot;</span>, HASHMAP.<span class="hljs-title function_ invoke__">get</span>(&amp;<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>());    <span class="hljs-comment">// 后续的访问仅仅获取值，再不会进行任何初始化操作</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The entry for `1` is \&quot;&#123;&#125;\&quot;.&quot;</span>, HASHMAP.<span class="hljs-title function_ invoke__">get</span>(&amp;<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>());&#125;</code></pre></div><p>lazy_static直到运行到main中的第一行代码时，才进行初始化，非常lazy static。</p><p>Box::leak</p><p>Box::leak可以用于全局变量，例如用作运行期初始化的全局动态配置。</p><p>它可以将一个变量从内存中泄漏，然后将其变为’static生命周期，最终该变量将和程序活得一样久，因此可以赋值给全局静态变量CONFIG。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> &#123;    a: <span class="hljs-type">String</span>,    b: <span class="hljs-type">String</span>&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> CONFIG: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> Config&gt; = <span class="hljs-literal">None</span>;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Config &#123;        a: <span class="hljs-string">&quot;A&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),        b: <span class="hljs-string">&quot;B&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),    &#125;);    <span class="hljs-keyword">unsafe</span> &#123;        <span class="hljs-comment">// 将`c`从内存中泄漏，变成`&#x27;static`生命周期</span>        CONFIG = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(c));        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, CONFIG);    &#125;&#125;</code></pre></div><p>从函数中返回全局变量</p><p>如果我们需要在运行期，从一个函数返回一个全局变量该如何做？例如：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Config</span> &#123;    a: <span class="hljs-type">String</span>,    b: <span class="hljs-type">String</span>,&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> CONFIG: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> Config&gt; = <span class="hljs-literal">None</span>;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> Config&gt; &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Config &#123;        a: <span class="hljs-string">&quot;A&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),        b: <span class="hljs-string">&quot;B&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),    &#125;);    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(c))&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">unsafe</span> &#123;        CONFIG = <span class="hljs-title function_ invoke__">init</span>();        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, CONFIG)    &#125;&#125;</code></pre></div><p>标准库中的 OnceCell</p><p>在 Rust 标准库中提供了实验性的 lazy::OnceCell 和 lazy::SyncOnceCell 两种 Cell ，前者用于单线程，后者用于多线程，它们用来存储堆上的信息，并且具有最 多只能赋值一次的特性。 如实现一个多线程的日志组件 Logger：</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// 低于Rust 1.70版本中， OnceCell 和 SyncOnceCell 的API为实验性的 ，</span><span class="hljs-comment">// 需启用特性 `#![feature(once_cell)]`。</span><span class="hljs-meta">#![feature(once_cell)]</span><span class="hljs-keyword">use</span> std::&#123;lazy::SyncOnceCell, thread&#125;;<span class="hljs-comment">// Rust 1.70版本以上,</span><span class="hljs-comment">// use std::&#123;sync::OnceLock, thread&#125;;</span><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-comment">// 子线程中调用</span>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;        <span class="hljs-keyword">let</span> <span class="hljs-variable">logger</span> = Logger::<span class="hljs-title function_ invoke__">global</span>();        logger.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">&quot;thread message&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());    &#125;);    <span class="hljs-comment">// 主线程调用</span>    <span class="hljs-keyword">let</span> <span class="hljs-variable">logger</span> = Logger::<span class="hljs-title function_ invoke__">global</span>();    logger.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">&quot;some message&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());    <span class="hljs-keyword">let</span> <span class="hljs-variable">logger2</span> = Logger::<span class="hljs-title function_ invoke__">global</span>();    logger2.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">&quot;other message&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();&#125;<span class="hljs-meta">#[derive(Debug)]</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Logger</span>;<span class="hljs-comment">// 低于Rust 1.70版本</span><span class="hljs-keyword">static</span> LOGGER: SyncOnceCell&lt;Logger&gt; = SyncOnceCell::<span class="hljs-title function_ invoke__">new</span>();<span class="hljs-comment">// Rust 1.70版本以上</span><span class="hljs-comment">// static LOGGER: OnceLock&lt;Logger&gt; = OnceLock::new();</span><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Logger</span> &#123;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">global</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> Logger &#123;        <span class="hljs-comment">// 获取或初始化 Logger</span>        LOGGER.<span class="hljs-title function_ invoke__">get_or_init</span>(|| &#123;            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Logger is being created...&quot;</span>); <span class="hljs-comment">// 初始化打印</span>            Logger        &#125;)    &#125;    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">log</span>(&amp;<span class="hljs-keyword">self</span>, message: <span class="hljs-type">String</span>) &#123;        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, message)    &#125;&#125;</code></pre></div><p>以上代码我们声明了一个 global() 关联函数，并在其内部调用 get_or_init 进行初始化 Logger，之后在不同线程上多次调用 Logger::global() 获取其实例：</p><p>可以看到，Logger is being created… 在多个线程中使用也只被打印了一次。</p><p>特别注意，目前 OnceCell 和 SyncOnceCell API 暂未稳定，需启用特性 #![feature(once_cell)]。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> once_cell::sync::OnceCell;<span class="hljs-keyword">static</span> START_TIME: OnceCell&lt;<span class="hljs-type">i32</span>&gt; = OnceCell::<span class="hljs-title function_ invoke__">new</span>();<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    START_TIME.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-number">1629876543</span>).<span class="hljs-title function_ invoke__">unwrap</span>();    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Start time: &#123;&#125;&quot;</span>, START_TIME.<span class="hljs-title function_ invoke__">get</span>().<span class="hljs-title function_ invoke__">unwrap</span>());&#125;</code></pre></div><ol start="6"><li>作用域</li></ol><ul><li>static 只能用于 全局作用域，不能定义在函数内部。</li><li>const 可以在任何作用域（包括函数内部）。</li></ul><ol start="7"><li>总结</li></ol><table><thead><tr><th>特性</th><th>static</th><th>const</th></tr></thead><tbody><tr><td>是否可变</td><td>可变 (mut)，但需要 unsafe</td><td>不可变</td></tr><tr><td>存储位置</td><td>全局内存（data&#x2F;bss 段）</td><td>无存储，直接内联</td></tr><tr><td>生命周期</td><td>‘static，程序整个生命周期有效</td><td>取决于作用域</td></tr><tr><td>线程安全</td><td>static mut 不安全，可能有数据竞争</td><td>天然线程安全</td></tr><tr><td>允许运行时初始化</td><td>允许</td><td>仅允许编译期计算</td></tr><tr><td>作用域</td><td>只能是全局</td><td>任意作用域</td></tr><tr><td>访问方式</td><td>直接访问（static mut 需要 unsafe）</td><td>直接访问</td></tr><tr><td>使用场景</td><td>全局变量、跨线程共享数据</td><td>编译期常量、优化性能</td></tr></tbody></table><p>什么时候用 static？</p><ul><li>需要一个 全局变量，比如 日志记录器、缓存、计数器。</li><li>变量必须在整个程序生命周期内有效。</li><li>可能需要线程安全，搭配 Mutex 或 Atomic 使用。</li></ul><p>什么时候用 const？</p><ul><li>需要一个 编译期常量，比如 数学常数、固定参数。</li><li>需要在局部作用域定义常量（比如函数内部）。</li><li>推荐优先使用 const，只有在必须时才用 static！</li></ul><h2 id="Rust-中-Copy-和-Clone-的区别"><a href="#Rust-中-Copy-和-Clone-的区别" class="headerlink" title="Rust 中 Copy 和 Clone 的区别"></a>Rust 中 Copy 和 Clone 的区别</h2><p>Copy 和 Clone 都是用来表示类型如何被复制的特性</p><ol><li>语义和适用场景</li></ol><ul><li>Copy：表示一个类型的值可以按位复制（bitwise copy），即直接复制值而不需要额外的资源分配。Copy<br>类型的值不会“所有权”转移，复制后原始值依然可以使用。常见于简单的、轻量级的类型，如整数类型、布尔值、字符等。</li><li>Clone：表示一个类型的值可以通过显式调用 .clone() 方法来创建其<br>深拷贝。这个过程可能涉及到额外的资源分配，比如为堆上的数据分配新的内存。适用于需要“深拷贝”的类型，通常在拥有堆分配数据的类型中（如<br>String 或 Vec）会实现 Clone。</li></ul><ol start="2"><li>是否强制复制</li></ol><ul><li>Copy：Copy 特性意味着该类型的值在赋值、函数传参等情况下会被自动按位复制，无需显式调用 clone()。Copy 类型的值直接以“按位拷贝”的方式进行复制。</li></ul><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">42</span>;    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a; <span class="hljs-comment">// a 会被自动复制到 b，a 仍然有效</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a); <span class="hljs-comment">// a 仍然有效</span>&#125;</code></pre></div><ul><li>Clone：Clone 必须显式调用 .clone() 方法，只有当你明确需要深拷贝时才会发生。</li></ul><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a.<span class="hljs-title function_ invoke__">clone</span>(); <span class="hljs-comment">// 使用 clone() 进行深拷贝，a 被转移，b 是独立的副本</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a); <span class="hljs-comment">// a 不能再使用，因为它的所有权被转移</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b); <span class="hljs-comment">// b 是有效的副本</span>&#125;</code></pre></div><ol start="3"><li>性能开销</li></ol><ul><li>Copy：由于是按位复制，没有额外的性能开销。它适用于存储在栈上的简单数据类型，不涉及堆内存分配。</li><li>Clone：通常会涉及到内存分配和深拷贝，因此比 Copy 有更高的性能开销。对于堆分配的类型，如 String、Vec，clone() 会分配新内存并复制堆上的数据。</li></ul><ol start="4"><li>实现方式</li></ol><ul><li>Copy：是一个 自动实现 的特性。只要类型满足按位复制的条件，Rust 会自动实现 Copy。例如，整数类型（i32、f64 等）和一些简单的结构体会自动实现<br>Copy。</li></ul><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Copy, Clone)]</span>  <span class="hljs-comment">// 明确要求类型实现 `Copy` 和 `Clone`</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;    x: <span class="hljs-type">i32</span>,    y: <span class="hljs-type">i32</span>,&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span> &#125;;    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = p1;  <span class="hljs-comment">// 按位复制，p1 仍然有效</span>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, p1);&#125;</code></pre></div><ul><li>Clone：Clone 必须由类型显式实现。例如，String、Vec 等类型需要自己实现 clone() 方法，通常是进行深拷贝操作。</li></ul><div class="code-wrapper"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span><span class="hljs-type">::from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-keyword">let</span> s2 = s1.clone(); <span class="hljs-comment">// 调用 clone() 来创建一个新对象</span></code></pre></div><ol start="5"><li>类型要求</li></ol><ul><li>Copy：要求类型的值没有堆分配，也没有引用其他堆内存。如果类型涉及到堆分配或借用，它通常不能实现 Copy。<ul><li>Copy 类型必须满足以下条件：<ul><li>类型的所有字段也必须实现 Copy。</li><li>类型的值可以按位复制。</li></ul></li></ul></li><li>Clone：不要求类型只能存储栈上的数据，可以是堆分配类型，甚至包含引用。Clone 实现可以根据需要对堆数据进行深拷贝。</li></ul><ol start="6"><li>总结：</li></ol><table><thead><tr><th>特性</th><th>Copy</th><th>Clone</th></tr></thead><tbody><tr><td>语义</td><td>适用于按位复制，值可以自动复制</td><td>适用于深拷贝，显式调用 .clone()</td></tr><tr><td>自动性</td><td>自动执行，无需调用方法</td><td>必须显式调用 .clone()</td></tr><tr><td>性能</td><td>低开销，按位复制</td><td>较高开销，可能涉及内存分配和深拷贝</td></tr><tr><td>实现方式</td><td>由 Rust 自动实现，简单类型（如整数、浮点数）</td><td>由类型自己实现 clone() 方法</td></tr><tr><td>类型要求</td><td>只适用于简单、没有堆分配的类型</td><td>适用于复杂类型，包括堆分配数据</td></tr></tbody></table><ul><li>如果你的类型可以按位复制，并且不涉及堆内存分配（例如基础数据类型，如 i32、f64 等），那么可以实现 Copy，Rust 会自动进行按位复制。</li><li>如果你的类型涉及堆内存或更复杂的数据结构（例如 String、Vec 等），你需要显式调用 .clone()，这时候它会通过深拷贝来创建副本，并且会有更高的性能开销。</li></ul><h2 id="’static-和-T-‘static"><a href="#’static-和-T-‘static" class="headerlink" title="&amp;’static 和 T: ‘static"></a>&amp;’static 和 T: ‘static</h2><p>‘static 在 Rust 中是相当常见的，例如字符串字面值就具有 ‘static 生命周期:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;  <span class="hljs-keyword">let</span> <span class="hljs-variable">mark_twain</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;Samuel Clemens&quot;</span>;  <span class="hljs-title function_ invoke__">print_author</span>(mark_twain);&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_author</span>(author: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>) &#123;  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, author);&#125;</code></pre></div><p>除此之外，特征对象的生命周期也是 ‘static</p><p>除了 &amp;’static 的用法外，我们在另外一种场景中也可以见到 ‘static 的使用:</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">mark_twain</span> = <span class="hljs-string">&quot;Samuel Clemens&quot;</span>;    <span class="hljs-title function_ invoke__">print</span>(&amp;mark_twain);&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>&lt;T: Display + <span class="hljs-symbol">&#x27;static</span>&gt;(message: &amp;T) &#123;    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, message);&#125;</code></pre></div><p>在这里，很明显 ‘static 是作为生命周期约束来使用了。 那么问题来了， &amp;’static 和 T: ‘static 的用法到底有何区别？</p><h3 id="’static"><a href="#’static" class="headerlink" title="&amp;’static"></a>&amp;’static</h3><p>&amp;’static 对于生命周期有着非常强的要求：一个引用必须要活得跟剩下的程序一样久，才能被标注为 &amp;’static。</p><p>对于字符串字面量来说，它直接被打包到二进制文件中，永远不会被 drop，因此它能跟程序活得一样久，自然它的生命周期是 ‘static。</p><p>但是，&amp;’static 生命周期针对的仅仅是引用，而不是持有该引用的变量，对于变量来说，还是要遵循相应的作用域规则 :</p><p>&amp;’static 的引用确实可以和程序活得一样久，因为我们通过 get_str_at_location 函数直接取到了对应的字符串。持有 &amp;’static 引用的变量，它的生命周期受到作用域的限制，大家务必不要搞混了</p><h3 id="T-‘static"><a href="#T-‘static" class="headerlink" title="T: ‘static"></a>T: ‘static</h3><p>在以下两种情况下，T: ‘static 与 &amp;’static 有相同的约束：T 必须活得和程序一样久。</p><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Debug</span>;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_it</span>&lt;T: <span class="hljs-built_in">Debug</span> + <span class="hljs-symbol">&#x27;static</span>&gt;( input: T) &#123;    <span class="hljs-built_in">println!</span>( <span class="hljs-string">&quot;&#x27;static value passed in is: &#123;:?&#125;&quot;</span>, input );&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_it1</span>( input: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Debug</span> + <span class="hljs-symbol">&#x27;static</span> ) &#123;    <span class="hljs-built_in">println!</span>( <span class="hljs-string">&quot;&#x27;static value passed in is: &#123;:?&#125;&quot;</span>, input );&#125;<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">5</span>;    <span class="hljs-title function_ invoke__">print_it</span>(&amp;i);    <span class="hljs-title function_ invoke__">print_it1</span>(&amp;i);&#125;</code></pre></div><p>以上代码会报错，原因很简单: &amp;i 的生命周期无法满足 ‘static 的约束，如果大家将 i 修改为常量，那自然一切 OK。</p>]]></content>
    
    
    
    <tags>
      
      <tag>rust圣经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP深入理解计算机系统-第十章-系统级IO</title>
    <link href="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/"/>
    <url>/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
    
    <content type="html"><![CDATA[<p>输入&#x2F;输出（I&#x2F;O）是在主存和外部设备之间复制数据的过程。输入操作是从I&#x2F;O设备复制数据到主存，而输出操作是从主存复制数据到I&#x2F;O设备。</p><h2 id="10-1-Unix-I-O"><a href="#10-1-Unix-I-O" class="headerlink" title="10.1 Unix I&#x2F;O"></a>10.1 Unix I&#x2F;O</h2><p>一个Linux文件就是一个m字节的序列</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">B0</span></span>,B1,...,Bk,...,Bm<span class="hljs-number">-1</span></code></pre></div><p>所有I&#x2F;O设备（网络、磁盘和终端）都被模型化为文件，所有的输入输出都被当作对应文件的读和写来执行。这种将设备映射为文件的方式，允许Linux内核引出一个简单、第几的应用接口，所有的输入输出都能以一种统一且一致的方式来执行。</p><ul><li>打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I&#x2F;O设备。内核返回一个小的非负整数，叫描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需要记住描述符。</li><li>Linux shell创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符为1）。头文件定义了常量STDIN_FILENO、STDIN_FILENO和STDERR_FILENO，它们可用来代替显式的描述符值。</li><li>改变当前文件位置。对于每个打开的文件，内核都保持着一个文件位置k，初始为0.这个文件位置上从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式的设置文件的当前位置k。</li><li>读写文件。一个读操作就是从文件复制n&gt;0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k&gt;&#x3D;m时执行读操作回触发一个称为end-of-file（EOF）的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的“EOF”符号。<ul><li>类似的，写操作就是从内存复制n&gt;0个字节到一个文件，从当前文件位置k开始，然后更新k。</li></ul></li><li>关闭文件。应用完成啦对文件的访问后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放他们的内存资源。</li></ul><h2 id="10-2-文件"><a href="#10-2-文件" class="headerlink" title="10.2 文件"></a>10.2 文件</h2><p>每个Linux文件都有一个类型（type）来表明它在系统中的角色：</p><ul><li><p>普通文件（regular file）包含任意数据。应用程序常常要区分文本文件和二进制文件，文本文件是只含有ASCLL或UNicode字符的普通文件；二进制文件是左右其他的文件。对内核而言，文本文件和二进制文件没有区别。</p><ul><li>Linux文本文件包含来一个文本行序列，其中每一行都是一个字符序列，以一个新行符（”\n”）结束。</li></ul></li><li><p>目录是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。每个目录至少有两个条目“.”和“..”，到该目录本身的联合和到目录的层次结构中父目录的链接。mkdir创建目录，rmdir删除目录</p></li><li><p>套接字是用来与另一个进程进行跨网络通信的文件。</p><p>其他文件类型包含命名通道、符号链接，以及字符和块设备。</p></li></ul><h2 id="10-3-打开和关闭文件"><a href="#10-3-打开和关闭文件" class="headerlink" title="10.3 打开和关闭文件"></a>10.3 打开和关闭文件</h2><p>进程通过调用open函数打开一个已经存在的文件或者创建一个新文件</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.1.png" alt="image-10.1"></p><p>open函数将filename转换为一个文件描述符，并返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flag参数指明来进程打算如何访问这个文件：</p><ul><li>O_RDONLY：只读</li><li>O_WRONLY：只写</li><li>O_RDWR：可读可写</li></ul><p>例如，下面代码说明如何以读的方式打开一个已经存在的文件：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">fd</span> = Open（<span class="hljs-string">&quot;foo.txt&quot;</span>,O_RDONLY, <span class="hljs-number">0</span>）<span class="hljs-comment">;</span></code></pre></div><p>flag参数也可以是一个或者更多位掩码的或，为写提供给一些额外的提示：</p><ul><li>O_CREAT：如果文件不存在就创建它的一个空文件。</li><li>O_TRUNC：如果文件已经存在，就截断它。</li><li>O_APPEND：在没错写操作前，设置文件位置到文件结尾处。</li></ul><p>例如，代码的代码说明的是如何打开一个已存在文件，并在后面添加一些数据：</p><div class="code-wrapper"><pre><code class="hljs coq">fd = <span class="hljs-keyword">Open</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>,O_WRDONLY|<span class="hljs-type">O_APPEND</span>, <span class="hljs-number">0</span>)</code></pre></div><p>mode参数指定来新文件的访问权限位。这些位的符号名字如图所示</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.2.png" alt="image-10.2"></p><p>作为上下文的一部分，每个进程都有一个umask，它是通过调用umask函数来设置的。当进程通过某个mode参数的open函数调用来创建一个新文件时，文件的访问权限位被设置为mode &amp; ～umask。例如，假设我们给定下面的mode和umask默认值：</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.3.png" alt="image-10.3"></p><p>接下来创建一个新文件，文件的拥有者有读写权限，而所有其他的用户都有读权限。</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.4.png" alt="image-10.4"></p><p>最后进程通过调用close函数关闭一个打开的文件。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;</code></pre></div><h2 id="10-4-读和写文件"><a href="#10-4-读和写文件" class="headerlink" title="10.4 读和写文件"></a>10.4 读和写文件</h2><p>应用程序通过分别调用read和write函数来执行输入输出</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.5.png" alt="image-10.5"></p><p>read函数从当前文件位置复制最多n个字节到内存位置buf。</p><p>write函数从内存位置buf复制最多n个字节到描述符fd当前文件位置。</p><p>调用lseek函数，应用程序能够显示地修改当前文件的位置。</p><p>某些情况下，read和write传送的字节比应用程序要求的要少，原因有：</p><ul><li>读到EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有20多个字节，而我们以50个字节的片进行读取。这样一来，下一个read返回的值不足20，此后的read将通过返回不足值0来发出EOF信号。</li><li>从终端读文本行。如果打开文件是与终端相关联的（键盘和显示器），那么每个read函数将一次传送一个文本行，返回的不足值等于文本行的大小。</li><li>读和写网络套接字。如果打开的文件对应于网络套接字，那么内部缓存越是和较长的网络延迟会满足read和write返回不足值。对Linux管道调用read和write时，也可能出现不足值。</li></ul><h2 id="10-5-用RIO包健壮的读写"><a href="#10-5-用RIO包健壮的读写" class="headerlink" title="10.5 用RIO包健壮的读写"></a>10.5 用RIO包健壮的读写</h2><p>RIO 会自动处理不足值，RIO提供了更为健壮高效的IO。</p><ul><li>无缓冲的输入输出函数。这些函数直接在内存和文件直接传送数据，没有应用级缓冲。他们对将二进制数据读写到网络和从网络读写二进制数据很有用。</li><li>带缓冲的输入函数。这些函数允许高校的从文件中读取文本行和二进制数据，这些文件内容缓冲在应用级缓冲区内，带缓冲的RIO输入函数是现场安全的。</li></ul><h3 id="10-5-1-RIO的无缓冲的输入输出函数"><a href="#10-5-1-RIO的无缓冲的输入输出函数" class="headerlink" title="10.5.1 RIO的无缓冲的输入输出函数"></a>10.5.1 RIO的无缓冲的输入输出函数</h3><p>通过调用rio_readn和rio_writen函数，应用程序可以在内存和文件之间直接传送数据。</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.6.png" alt="image-10.6"></p><p>rio_readn函数从描述符fd的当前文件位置最多传送n个字节到内存位置usrbuf。</p><p>类似的，rio_writen函数从位置usrbuf传送n个字节到描述符fd。rio_read函数在遇到EOF时只能返回一个不足值。rio_writen函数决不会返回不足值。对同一个描述符，可以任意交错地调用rio_readn和rio_writen。</p><p>如果他俩被一个应用信号处理程序返回中断，那么每个函数都会手动的重启read或write。</p><h3 id="10-5-2-RIO的带缓冲的输入函数"><a href="#10-5-2-RIO的带缓冲的输入函数" class="headerlink" title="10.5.2 RIO的带缓冲的输入函数"></a>10.5.2 RIO的带缓冲的输入函数</h3><p>要编写一个程序来计算文本文件中文本行的数量，如果一次一个字节的从文件传送到用户内存，读每一个字节都要求陷入内核。</p><p>更好的办法是调用一个包装函数，它从缓冲区复制一个文本行，缓存区变空，会自动的调用read重新填满缓冲区。</p><h2 id="10-6-读取文件元数据"><a href="#10-6-读取文件元数据" class="headerlink" title="10.6 读取文件元数据"></a>10.6 读取文件元数据</h2><p>应用程序通过调用stat和fstat函数，检索到关于文件的信息，也称文件的元数据。</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.7.png" alt="image-10.7"></p><p>stat函数输入一个文件名，并写入一个stat数据结构。</p><p>在Web服务器中，会需要stat数据结构中的st_mode和st_size成员。</p><p>st_size成员包含来文件的字节数大小。st_mode成员则编码来文件访问许可位和文件类型。</p><h2 id="10-7-读取目录内容"><a href="#10-7-读取目录内容" class="headerlink" title="10.7 读取目录内容"></a>10.7 读取目录内容</h2><p>应用程序可以用readdir系列函数来读取目录的内容。</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.8.png" alt="image-10.8"></p><p>函数opendir以路径名为参数，返回指向目录流的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.9.png" alt="image-10.9"></p><p>每次调用返回的都是指向流dirp中下一个目录项的指针，如果没有更多目录项则返回NULL，每个目录项都是一个结构。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> &#123;<span class="hljs-type">ino_t</span> d_ino;     <span class="hljs-comment">//inode number</span><span class="hljs-type">char</span> d_name[<span class="hljs-number">256</span>] <span class="hljs-comment">//Filename</span>&#125;</code></pre></div><p>d_name是文件名，d_ino是文件位置。</p><h2 id="10-8共享文件"><a href="#10-8共享文件" class="headerlink" title="10.8共享文件"></a>10.8共享文件</h2><p>可以用许多不同的方式来共享Linux文件，内核用三个相关的数据结构来标识打开的文件：</p><ul><li>描述符表。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</li><li>文件表。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成包括当前的文件位置、引用计数，以及一个指向v-node表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到引用计数为0。</li><li>v-node表。同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息，包括st_mode和st_size成员。</li></ul><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.10.png" alt="image-10.10"></p><p>其中描述符1和4通过不同的打开文件表表项来引用两个不同的文件。这种情况没有共享文件，并且每个描述符对应一个不同的文件。</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.11.png" alt="image-10.11"></p><p>多个描述符也可以通过不同的文件表表项来引用同一个文件，例如以同一个filename调用open函数2次，就会发生这种情况。关键是每个描述符都有它自己的文件位置，所以对不同描述符的读操作可以从文件的不同位置获取数据。</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.12.png" alt="image-10.12"></p><p>父子进程共享文件，在调用fork之前，父进程有10-12所示打开文件。然后调用fork之后。子进程有一个父进程描述符表的副本，父子进程共享相同的打开文件表集合，因此共享相同的文件位置。</p><p>在内核删除对应文件表项之前，父子进程必须都关闭了他们的描述符。</p><h2 id="10-9-I-O重定向"><a href="#10-9-I-O重定向" class="headerlink" title="10.9 I&#x2F;O重定向"></a>10.9 I&#x2F;O重定向</h2><p>Linux shell提供了I&#x2F;O重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。输入</p><div class="code-wrapper"><pre><code class="hljs bash">linux &gt; <span class="hljs-built_in">ls</span> &gt; foo.txt</code></pre></div><p>使得shell加载和执行ls程序，将标准输出重定向到磁盘文件foo.txt。</p><p>当一个Web服务器代表客户端运行CGI程序时，它就执行一种相似度重定向，通过使用dup2函数</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;</code></pre></div><p>dup2函数父子描述符表表项oldfd到描述符表表项newfd，覆盖描述符表表项newfd以前到内容。如果newfd已经打开了，dup2会在父子oldfd之前关闭newfd。</p><p>在调用dup2(4,1)之前，我们的状态如10-12所示，其中描述符1（标准输出）对应于文件A（比如一个终端），描述符4对应于文件B（比如一个磁盘文件）。A和B的引用计数都等于1.图10-15显示了调用dup2(4,1)之后的情况。两个描述符现在都指向文件B；文件A已经被关闭了，并且它的文件表和v-node表表项也已经被删除了；文件B都引用计数已经增加了。从此之后，人后写到标准输出的数据都被重定向到文件B。</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.13.png" alt="image-10.13"></p><h2 id="10-10-标准-I-O"><a href="#10-10-标准-I-O" class="headerlink" title="10.10 标准 I&#x2F;O"></a>10.10 标准 I&#x2F;O</h2><p>C语言定义了一组高级输入输出函数，称为标准I&#x2F;O库。库 libc 提供了打开和关闭文件的函数（fopen 和 fclose）、读和写字节的函数（fread 和 fwrite）、读和写字符串的函数（fgets 和 fputs），以及复杂的格式化的I&#x2F;O函数（scanf 和 printf）。</p><p>标准I&#x2F;O库将一个打开的文件模型化为一个流。对于程序员一个流就是一个指向FILE类型的结构的指针。每个ANSI C程序开始时都有三个打开的流 stdin、stdout 和 stderr，分别对应于标准输入、标准输出和标准错误：</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.14.png" alt="image-10.14"></p><p>类型为FILE的流是对文件描述符和流缓冲区的抽象。流缓冲区的目的和RIO读缓冲区的一样：就是使开销较高的LinuxI&#x2F;O系统调用的数量尽可能的小。</p><p>例如，我们有一个程序，它反复调用标准I&#x2F;O的getc函数，每次调用返回文件的下一个字符。当第一次调用getc时，库通过调用一次read函数来填充缓冲区，然后将缓冲区中的第一个字节返回给应用程序。子要缓冲区中还有未读的字节，接下来对getc的调用就能直接从流缓冲区得到服务。</p><h2 id="10-11-综合：该使用哪些I-O函数"><a href="#10-11-综合：该使用哪些I-O函数" class="headerlink" title="10.11 综合：该使用哪些I&#x2F;O函数"></a>10.11 综合：该使用哪些I&#x2F;O函数</h2><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.15.png" alt="image-10.15"></p><ul><li>G1:只要有可能就使用标准I&#x2F;O。对磁盘和终端设备I&#x2F;O来说，标准I&#x2F;O函数是首选方法。</li><li>G2:不要使用scanf或rio_readlined来读二进制文件，是来专门读文本文件的，因为二进制文件有很多0xa字节，然而这些字节与终止文本行无关。</li><li>G3:对网络套接字的I&#x2F;O使用RIO函数。不幸的是，当使用标准I&#x2F;O用于网络输入输出时，出现了一些令人讨厌的问题。Linux对网络的抽象是一种称为套接字的文件类型。就像所有的Linux文件一样，套接字由文件描述符来引用，在这种情况下称为套接字描述符。应用程序进程通过读写套接字描述符来与运行在其他计算机的进程实现通信。</li></ul><p>标准I&#x2F;O流，某种意义上而言是全双工的，因为程序能够在同一个流上执行输入和输出。然而，对流的限制和对套接字的限制，有时候会互相冲突。</p><ul><li>限制一：跟在输出函数之后的输入函数。如果中间没有插入对fflush、fseek、fsetpos或者rewind的调用，一个输入函数不能跟随在一个输出函数之后。fflush函数清空与流相关的缓冲区。后三个函数使用Unix I&#x2F;O lseek函数来重置当前的文件位置。</li><li>限制二：跟着输入函数之后的输出函数。如果中间没有插入对fseek、fsetpos或者rewind的调用，一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到来一个文件结束。</li></ul><p>这些限制带来一个问题，因为对套接字使用lseek函数的非法的。对流I&#x2F;O的第一个限制能够通过采用在每个输入操作前刷新缓冲区这样的规则来满足。然而，要满足第二个限制的唯一方法，是对同一个打开的到套接字描述符打开两个流，一个读，一个写。</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.16.png" alt="image-10.16"></p><p>但是这种方法也有问题，因为它要求应用程序在两个流上都调用fclose，这样才能释放与每个流相关联的内存资源，避免内存泄漏：</p><p><img src="/2025/02/17/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10.17.png" alt="image-10.17"></p><p>这些操作中的每一个都试图关闭同一个底层的套接字描述符，所以第二个close操作就会失败。对顺序的程序来说，这不是问题，但是在一个线程化的程序中关闭一个已经关闭了的描述符会导致灾难。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP深入理解计算机系统-第九章-虚拟内存</title>
    <link href="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>进程都是共享CPU以及主存资源的，如果一个程序没有空间可用时，会破坏别的进程的内存。</p><p>为了更有效的管理内存并少出错，提出了一种对主存的抽象概念，叫虚拟内存。</p><p>虚拟内存提供了三个重要的能力</p><ul><li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，高效的使用了主存。</li><li>它为每个进程提供了一致的地址空间，从而简化了内存管理。</li><li>它保护了每个进程的地址空间不被其他进程破坏。</li></ul><p>虚拟内存沉默地、自动地工作，但是还需要理解它</p><ul><li><p>虚拟内存是核心的</p><p>虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中担任重要角色。</p></li><li><p>虚拟内存是强大的</p><p>虚拟内存给予应用程序强大的能力，可以创建和销毁内存片、将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存。</p></li><li><p>虚拟内存是危险的</p><p>每次应用程序引用一个变量、间接引用一个指针，或者调用一个 malloc 的动态分配程序时，就会和虚拟内存发生交互。如果使用不当，程序就可以立即崩溃于“段错误”或者“保护错误”。</p></li></ul><p>从两部分看虚拟内存</p><p>第一部分描述虚拟内存是如何工作的。第二部分描述的是应用程序如何管理虚拟内存。</p><h2 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h2><p>主存被组织成一个由M个连续的字节大小的单元组成的数组。</p><p>每字节都有一个唯一的<strong>物理地址</strong>。</p><p>第一个字节的地址为0，下一个为1，再下一个为2，CPU访问内存最自然的方式就是使用物理地址，这种方式称为<strong>物理寻址</strong>。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.1.png" alt="image-9.1"></p><p>上图读取物理地址4处开始的4字节字。当CPU执行这条加载指令时，会生成一个有效的物理地址，通过内存总线，传递给主存。主存从物理地址取出四字节字，返回给cpu放到一个寄存器里。</p><p>早期PC使用物理寻址，现代计算机使用虚拟寻址。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.2.png" alt="image-9.2"></p><p>CPU通过虚拟地址（VA）来访问主存，虚拟地址在被送到内存之前先转换成适当的物理地址。将虚拟地址转为物理地址的行为叫做地址翻译。CPU上的内存管理单元（Memory Management Unit）为专用硬件，利用存放在主存中的地址表来动态翻译虚拟地址。</p><h2 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h2><p>地址空间是一个非负整数地址的有序集合。</p><p>如果地址空间中的整数是连续的，那么我们说是一个线性地址空间。</p><p>我们假设使用的是线性地址空间，CPU从一个有N&#x3D;2^n个地址的地址空间生成虚拟地址，这个地址空间称为虚拟地址空间。</p><ul><li>虚拟地址空间</li></ul><p>一个地址空间的大小是由表示最大地址所需要的位数来描述。一个包含 N&#x3D;2^n 个地址的虚拟地址空间就叫做一个n位地址空间。现在多为32位或64位。</p><ul><li>物理地址空间</li></ul><p>一个系统还有一个物理地址空间，对应于系统中物理内存的 M 个字节，M可以不为2的幂，未来简化讨论假定M&#x3D;2^m。</p><p>地址空间的概念区分了数据对象（字节）和他们的属性（地址）。</p><p>每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间，这是虚拟内存的基本思想。主存的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p><h2 id="9-3-虚拟内存作为缓存工具"><a href="#9-3-虚拟内存作为缓存工具" class="headerlink" title="9.3 虚拟内存作为缓存工具"></a>9.3 虚拟内存作为缓存工具</h2><p>虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。</p><p>每字节都有唯一的虚拟地址，作为到数组的索引。磁盘上数组内容被缓存在主存中。</p><p>VM系统通过将虚拟内存分割为<strong>虚拟页</strong>（VP）的大小固定块来传输。</p><p>每个虚拟页的大小为P&#x3D;2^p字节。</p><p>同样物理内存被分割为物理页（PP），大小也为P字节物理页也称为页帧。</p><p>任意时刻虚拟页面的集合都分为三个不相交的子集：</p><ul><li>未分配的：VM 系统还未分配或创建的页。未分配的快没有任何数据和他们相关联，也不占用任何空间。</li><li>缓存的：当前已缓存在物理内存中的已分配页。</li><li>未缓存的：未缓存在物理内存中的已分配页。</li></ul><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.3.png" alt="image-9.3"></p><p>上图是一个有8个虚拟页的小虚拟内存，虚拟页0和3还没有分配，所以在磁盘上还不存在。虚拟页1、4、6被缓存在物理内存中。页2、5、7已经被分配；但是并未缓存在主存中。</p><h3 id="9-3-1-DRAM缓存的组织结构"><a href="#9-3-1-DRAM缓存的组织结构" class="headerlink" title="9.3.1 DRAM缓存的组织结构"></a>9.3.1 DRAM缓存的组织结构</h3><p>SRAM缓存表示位于CPU和主存之间的L1、L2和L3高速缓存。</p><p>DRAM缓存表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</p><p>DRAM比SRAM要慢大约10倍，磁盘比DRAM慢大约100000多倍。</p><p>所以DRAM的不命中比SRAM不命中要昂贵的多，因为DRAM缓存不命中是需要磁盘来服务，SRAM不命中是需要DRAM来服务。</p><p>因为大大不命中处罚和访问第一个字节的开销，虚拟页往往很大，4KB～2MB。</p><p>由于大的不命中处罚，DRAM缓存是全关联的，任何虚拟页都可以放置在任何物理页中。</p><p>不命中时的替换策略也很重要，因为替换错了虚拟页的处罚也非常高，系统对DRAM缓存使用了更精密的替换算法。</p><p>DRAM缓存总是使用写回，而不是直写。</p><h3 id="9-3-2-页表"><a href="#9-3-2-页表" class="headerlink" title="9.3.2 页表"></a>9.3.2 页表</h3><p>虚拟内存系统必须有种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还需要确定这个虚拟内存存放在哪个物理页中。如果不命中，需要判断虚拟页在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换掉牺牲页。</p><p>这些功能通过软硬件结合实现，包括操作系统软件、MMU中的地址翻译硬件和一个存放在物理内存中叫页表的数据结构，页表将虚拟内存页映射到物理页。</p><p>每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.4.png" alt="image-9.4"></p><p>页表就是一个页表条目（Page Table Entry）的数组。虚拟地址空间中每个页在页表中一个固定偏移量处都有一个PTE。</p><p>假设每个PTE是由一个有效位和一个n位地址字段组成的。有效位表明该虚拟页当前是否被缓存在DRAM中。如果设置的有效位，那么地址字段就表示DRAM中对应的物理页的起始位置，物理页中缓存了该虚拟页。如果没有有效位，那么一个空地址表示这个虚拟页还未被分配。否则这个地址应该指向该虚拟页在磁盘上的起始位置。</p><h3 id="9-3-3-页命中"><a href="#9-3-3-页命中" class="headerlink" title="9.3.3 页命中"></a>9.3.3 页命中</h3><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.5.png" alt="image-9.5"></p><p>当CPU想要读包含在VP2中的虚拟内存的一个字时。</p><p>VP2被缓存在DRAM中。地址翻译硬件将虚拟地址作为索引来定位PTE2，并从内存中读取它。</p><p>因为设置了有效位，地址翻译硬件就知道VP2已经缓存在内存中了。所以它使用PTE中的物理内存地址，得到这个字的物理地址。</p><h3 id="9-3-4-缺页"><a href="#9-3-4-缺页" class="headerlink" title="9.3.4 缺页"></a>9.3.4 缺页</h3><p>DRAM缓存不命中为缺页。</p><p>CPU引用了VP3中的一个字，VP3并未缓存在DRAM中。地址翻译硬件从内存中读取PTE3，从有效位判断VP3未被缓存，并触发一个<strong>缺页异常</strong>。</p><p>缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如放在pp3中的vp4，如果vp4已经被修改了，内核就将它复制回磁盘（回写）。无论怎样都会修改VP4的页表条目。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.6.png" alt="image-9.6"></p><p>接下来内核从磁盘中复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时会重新启动导致缺页的指令，该指令回把导致缺页的地址重新发送到地址翻译软件，现在VP3已经在主存中了，所以页面能正常由地址翻译正常处理了。</p><p>在虚拟内存的习惯说法中，快被称为页。在磁盘和内存之间传送页的活动叫做<code>交换</code>或者<code>页面调度</code>。页从磁盘换入DRAM和从DRAM中换出。</p><p>当有不命中发生时才换入页面的策略叫做按需页面调度。</p><h3 id="9-3-5-分配页面"><a href="#9-3-5-分配页面" class="headerlink" title="9.3.5 分配页面"></a>9.3.5 分配页面</h3><p>当操作系统分配一个新的虚拟内存页时，调用malloc，在磁盘上创建空间并更新PTE5，使它指向磁盘上这个新创建的页面。</p><h3 id="9-3-6-局部性"><a href="#9-3-6-局部性" class="headerlink" title="9.3.6 局部性"></a>9.3.6 局部性</h3><p>虚拟内存不会因为不命中处罚很大，担心页面调度会影响性能。</p><p>尽管在运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫工作集或者常驻集合。</p><p>初始开销中，也就是将工作集页面调度到内存中，之后对这个工具集的引用将导致命中不会产生额外的磁盘流量。</p><p>在将工作集页面调度到内存中之后，接下来对这个工作集的引用将导致命中，不会产生额外的磁盘流量。</p><p>只要程序有良好的时间局部性，虚拟内存就可以工作的很好。</p><p>如果工作集的大小超出了物理内存的大小，那么程序将产生抖动，页面不断的换进换出，性能像爬一样。</p><div class="code-wrapper"><pre><code class="hljs">可以利用Linux的getrusage函数监测缺页数量（以及许多其他的信息）</code></pre></div><h2 id="9-4-虚拟内存作为内存管理的工具"><a href="#9-4-虚拟内存作为内存管理的工具" class="headerlink" title="9.4 虚拟内存作为内存管理的工具"></a>9.4 虚拟内存作为内存管理的工具</h2><p>早期系统支持的是一个比物理内存更小的虚拟地址空间。然而虚拟地址还是一个有用的机制，其大大简化的内存管理，并提供了一种自然保护内存的方法。</p><p>之前假设是一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上，操作系统为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.7.png" alt="image-9.7"></p><p>多个虚拟页面可以映射到同一个共享物理页面上。</p><p>VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。</p><ul><li><p>简化链接</p><p>独立的地址空间允许每个进程的内存映像使用相同的基本格式，无论代码和数据实际存放在何处。</p><p>代码段总是从虚拟地址0x400000开始。数据段跟在代码段之后，中间有一段符合要求的对其空白。</p><p>栈占据用户进程地址空间最高部分，并向下生长，这样极大的简化了链接器的设计和实现，运行链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</p></li><li><p>简化加载</p><p>讯内存使得容易想内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，把标记无效的（未被缓存的），将页表条目指向目标文件中适当的位置。</p><p>加载器从不从磁盘到内存实际复制任何数据。在每个页初次被使用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。</p></li></ul><p>将一组连续的虚拟页映射到任意一个文件中任意位置的表示法为内存映射。Linux提供一个mmap允许应用程序自己做内存映射。</p><ul><li><p>简化共享</p><p>独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将对应的虚拟页映射到不连续的物理页面。</p></li></ul><p>在一些情况还是需要进程来共享代码和数据。例如每个进程都要调用相同的操作系统内核代码，每个C都会调用C标准库中的程序，操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码调度副本，而不是在每个进程中都包含内核和C标准库的副本。</p><ul><li><p>简化内存分配</p><p>虚拟内存为向用户进程提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时，操作系统分配一个适当的数字（k）个连续的虚拟内存页面，并将他们映射到物理内存中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配k个连续的物理内存页面。页面可以随机地分散在物理内存中。</p></li></ul><h2 id="9-5-虚拟内存作为内存保护的工具"><a href="#9-5-虚拟内存作为内存保护的工具" class="headerlink" title="9.5 虚拟内存作为内存保护的工具"></a>9.5 虚拟内存作为内存保护的工具</h2><p>计算机不应该允许一个用户进程修改它的只读代码段，也不应该允许它读或者修改任何内核中的代码和数据结构。不应该读其他进程的私有内存，而且不允许修改任何与其他进程共享的虚拟页面，除非所有共享者都显式的允许它这么做。</p><p>独立的地址空间使得区分不同进程的私有内存变得容易。但是地址翻译机制可以用自然的方式扩展到提供更好的访问控制。因为每次CPU生成一个地址时，地址翻译硬件都会读一个PTE，所以通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.8.png" alt="image-9.8"></p><p>每个PTE中已经添加了三个许可位。SUP位表示进程是否必须运行在内核模式下才能访问该页。</p><p>运行在内核模式下可以反问任何页面，但是运行在用户模式的进程只允许访问那些SUP为0的页面。READ位和WRITE位控制对页面的读和写访问。例如进程i运行在用户模式下，那么它有读VP0和读写VP1的权限。然而，不允许它访问VP2。</p><p>如果一个指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell一般将这种异常报告为，段错误。</p><h2 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h2><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.9.png" alt="image-9.9"></p><p>地址翻译是一个N元素的虚拟地址空间（VAS）中的元素和一个M元素的物理地址空间（PAS）中的元素之间的映射。</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">MAP</span>:VAS -&gt; PAS U ⌀</code></pre></div><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.10.png" alt="image-9.10"></p><p>上图表示了MMU如何利用页表来实现这种映射。CPU中的一个控制寄存器，页表基址寄存器（PTBR）指向当前页表。</p><p>n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。</p><p>MMU将利用VPN来选择适当的PTE。</p><p>将页表条目中物理页号（PPN）和虚拟地址中的VPO串联起来，就得到相应的物理地址。</p><p>物理和虚拟页面都是p字节的，所以物理页面偏移（VPO）和PPO是相同的。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.11.png" alt="image-9.11"></p><p>页面命中时，CPU硬件执行的步骤。</p><ul><li>第一步：处理器生成一个虚拟地址，并把它传送给MMU。</li><li>第二步：MMU生成PTE地址，并从高速缓存&#x2F;主存请求得到它。</li><li>第三步：高速缓存&#x2F;主存向MMU返回PTE。</li><li>第四步：MMU构造物理地址，并把它传送给高速缓存&#x2F;主存。</li><li>第五步：高速缓存&#x2F;主存返回所请求的数据字给处理器。</li></ul><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.12.png" alt="image-9.12"></p><p>页面命中完全是由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成。</p><ul><li>第一步到第三步与命中完全相同。</li><li>第四步：PTE中的有效位是0，所以MMU触发来一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>第五步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第六步：缺页处理程序页面调入新的页面，并更新内存中的PTE。</li><li>第七步：缺页程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中。</li></ul><h3 id="9-6-1-结合高速缓存和虚拟缓存"><a href="#9-6-1-结合高速缓存和虚拟缓存" class="headerlink" title="9.6.1 结合高速缓存和虚拟缓存"></a>9.6.1 结合高速缓存和虚拟缓存</h3><p>在任何使用虚拟内存又实用SRAM高速缓存的系统中，都有应该使用虚拟地址还是使用物理地址来访问SRAM高数缓存的问题。</p><p>大多数系统是物理寻址的。使用物理寻址，多个进程很容易同时在高速缓存中有存储块和共享来自相同虚拟页面的块。而且，改善缓存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.13.png" alt="image-9.13"></p><p>将VM与物理寻址的高速缓存结合起来：VA：虚拟地址。PTEA：页表条目地址。PTE：页表条目。PA：物理地址</p><h3 id="9-6-2-利用TLB加速地址翻译"><a href="#9-6-2-利用TLB加速地址翻译" class="headerlink" title="9.6.2 利用TLB加速地址翻译"></a>9.6.2 利用TLB加速地址翻译</h3><p>CPU产生一个虚拟地址，MMU就必须查阅一个PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，会要求从内存多取一次数据，代价是几十到几百个周期。如果PTE碰巧缓存在L1中，那么开销就下降到1个或2个周期。然而，许多系统都试图消除即使是这样的开销，他们在MMU中包括来一个关于PTE的小缓存，称为翻译后备缓冲器（TLB）。</p><p>TLB是一个小的虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相联度。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.14.png" alt="image-9.14"></p><p>用于组选择和行匹配度索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB有T&#x3D;2^t个组，那么TLB索引是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.15.png" alt="image-9.15"></p><p>当TLB命中时（通常情况）所包括的步骤。这里的关键是，所有的地址翻译步骤都是在芯片上的MMU中执行的，因此非常的块。</p><ul><li><p>第一步：CPU产生一个虚拟地址VA</p></li><li><p>第二步和第三步：MMU从TLB中取出对应的PTE。</p></li><li><p>第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存&#x2F;主存。</p></li><li><p>第五步：高速缓存&#x2F;主存将所请求的数据字返回给CPU。</p><p>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE，新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p></li></ul><h3 id="9-6-3-多级页表"><a href="#9-6-3-多级页表" class="headerlink" title="9.6.3 多级页表"></a>9.6.3 多级页表</h3><p>假设系统只用一个单独的页表来进行地址翻译。但是如果我们有一个32位的地址空间、4KB的页面和一个4字节的PTE，那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个4MB的页表驻留在内存中。对于地址空间为64位的系统来说，问题将变得更复杂。</p><p>压缩页表的常用方法是使用层次结构的页表。</p><p>假设32位虚拟地址空间被分为4KB的页，而每个页表条目都是4字节。</p><p>假设在这样时刻，虚拟地址空间有如下形式：内存的前2K页面分配给了代码和数据，接下来的6K个页面还未分配，再接下来的1023个页面也未被分配，接下来的1个页面分配给了用户栈。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.16.png" alt="image-9.16"></p><p>为虚拟地址空间构造的两级的页表层次结构。</p><p>一级页表中的每个PTE负责映射虚拟地址空间中一个4MB的片，这里每一个片都是由1024个连续的页面组成的。比如，PTE0 映射第一片，PTE1 映射接下来的一片。</p><p>假设地址空间是4GB，1024个PTE一级足够覆盖整个空间了。</p><p>如果片i中的每个页面都未被分配，那么一级PTE i就为空。</p><p>上图片2～7是未被分配的。然而如果片i中至少有一个页是分配了的，那么一级PTE i 就指向一个二级页表的基址。</p><p>片0、1和8的所有或者已被分配，所以它们的一级PTE就指向二级页表。</p><p>二级页表中的每个PTE都负责映射一个4KB的虚拟内存页面，就像我们查看只有一级的页表一样。</p><p>使用4字节的PTE，每个一级和二级页表都是4KB字节，这刚好和一个页面的大小是一样的。</p><p>这种方法从两个方面减少了内存要求。</p><ul><li>第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就不会存在</li><li>第二，只有一级页表才需要总是在主存中；</li></ul><p>虚拟内存系统可以在需要时创建、页面调入和调出二级页表，这就减少了主存的压力，只有最经常使用的二级页表才需要缓存在主存中。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.17.png" alt="image-9.17"></p><p>上图使用k级页表层次结构的地址翻译。虚拟地址被划分成为k个VPN和一个VPO。每个VPN i 都是一个到第i 级页表的索引，其中 1&lt;&#x3D;i&lt;&#x3D;k。</p><p>第j级页表中的每个PTE， 1&lt;&#x3D;j&lt;&#x3D;k-1，都指向第 j+1级的某个页表的基址。第k级页表中的每个PTE包含某个物理页面的PPN，或者一个磁盘块的地址。</p><p>为了构造物理地址，在能够确定PPN之前，MMU必须访问k个PTE。对于只有一级的页表结构，PPO和VPO是相同的。</p><p>表面上，使用多级页表看上去昂贵，但是TLB能够在里面起作用，正是通过将不同层次上页表的PTE缓存起来。实际上，多级页表并不比单级页表慢很多。</p><h3 id="9-6-4-综合：端到端的地址翻译"><a href="#9-6-4-综合：端到端的地址翻译" class="headerlink" title="9.6.4 综合：端到端的地址翻译"></a>9.6.4 综合：端到端的地址翻译</h3><p>端到端的地址翻译示例，保证可管理性，做出如下假设</p><ul><li>内存是按字节寻址的</li><li>内存访问是针对1字节的字的（不是4字节的字）</li><li>虚拟地址是14位长的（n&#x3D;14）</li><li>物理地址是12位长的（m&#x3D;12）</li><li>页面大小是64字节（P&#x3D;64）</li><li>TLB是四路相联的，总共有16个条目</li><li>系统是物理寻址、直接映射的，行大小为4字节，而总共有16个组。</li></ul><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.18.png" alt="image-9.18"></p><p>因为页大小是64字节的，所以虚拟地址和物理地址的低6位分别作为VPO和PPO。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.19.png" alt="image-9.19"></p><ul><li><p>TLB</p><p>TLB是利用VPN的位进行虚拟寻址的。因为TLB有四组，所以VPN的低2位就作为组索引TLBI。VPN中的高6位作为标记（TLBT），用了区别可能映射到同一个TLB组的不同的VPN。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.20.png" alt="image-9.20"></p></li><li><p>页表</p><p>这个页表是一个单级设计，一共有2^8&#x3D;256个页表条目（PTE）。然而，我们只对这些条目中的开头16个感兴趣。为了方便，我们用索引它的VPN来标识每个PTE；但这些VPN不是页表的一部分，也不存储在内存中。同时有效位为0的数据是没有意义的。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.21.png" alt="image-9.21"></p></li><li><p>高速缓存</p><p>直接映射就是通过物理地址中的字段来寻址的。因为每个块都是4字节，所以物理地址的低2位作为块偏移（CO）。因为有16组，所以接下来的四位就用来标识组索引（CI）。剩下的6位作为标记（CT）。</p></li></ul><p>当CPU执行读一条0x03d4处字节的加载指令时会发生什么。</p><p>这是虚拟地址的各个位</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.22.png" alt="image-9.22"></p><p>开始时，MMU从虚拟地址中抽取出VPN（0x0f），并且检查TLB，看它是否因为前面某个内存引用缓存来PTE0x0f的一个副本。TLB从VPN中抽取出TLB索引（0x03）和TLB标记（0x03），组0x03的第二个条目中有效匹配，所以命中，然后将缓存的PPN（0x0D）返回给MMU。</p><p>如果TLB不命中，那么MMU就需要从主存中取出相应的PTE。这样MMU就有了形成物理地址所需要的所有东西。通过来自PTE的PPN（0x0D）和来自虚拟地址的VPO（0x14）链接起来，这就形成来物理地址（0x354）。</p><p>接下来，MMU发送物理地址给缓存，缓存从物理地址中抽取出缓存偏移CO（0x0）、缓存组索引CI（0x05）以及缓存标记CT（0x0D）。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.23.png" alt="image-9.23"></p><p>因为0x5中标记与CT相匹配，索引检测到一个命中，读出在偏移量CO处的数据字节（0x36），并将它返回给MMU，随后MMU将它传递回CPU。</p><p>如果TLB不命中，那么MMU就必须从页表中的PTE中取出PPN。如果得到的PTE是无效的就会产生一个缺页，内核就要调入合适的页面，重新运行这条加载指令。如果PTE是有效的，但是所需要的内存块在缓存中不命中。</p><h1 id="9-7-Linux虚拟内存系统"><a href="#9-7-Linux虚拟内存系统" class="headerlink" title="9.7 Linux虚拟内存系统"></a>9.7 Linux虚拟内存系统</h1><p>Linux为每一个进程维护了一个单独的虚拟地址空间，</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.24.png" alt="image-9.24"></p><p>内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理界面。</p><p>例如每个进程共享内核的代码和全局数据结构。Linux也将一组连续的虚拟页面（大小等于系统中DRAM的总量）映射到相应的一组连续的物理页面。</p><p>这就为内核提供了一种便利的方法来访问物理内存中特定的位置，当它要访问页表，或者在设备上执行内存映射I&#x2F;O操作，而这些设备被映射到特定的物理内存位置时。</p><p>内核虚拟内存的其他区域包含每个进程都不相同的数据。比如，页表、内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p><h3 id="9-7-1-Linux虚拟内存区域"><a href="#9-7-1-Linux虚拟内存区域" class="headerlink" title="9.7.1 Linux虚拟内存区域"></a>9.7.1 Linux虚拟内存区域</h3><p>Linux将虚拟内存组织成一些区域（段）的集合。一个区域就是已经存在着的虚拟内存连续片，这些页以某种方式相关联。</p><p>代码段、数据段、堆、共享库段，以及用户栈都是不同的区域。每个存在的虚拟页都保存在某个区域中，不属于某个区域的虚拟页是不存在的，并且不能被进程引用。区域允许虚拟地址空间有间隙。内核不用记录那些不存在的虚拟页，而这样的页不用占用内存，或者是其他任何资源。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.25.png" alt="image-9.25"></p><p>上图为一个进程中虚拟内存区域的内核数据结构。内核为系统中的每个进程维护一个单独的任务结构。（task_struct）任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（PID、指向用户栈的指针、可执行目标文件的名字、程序计数器）。</p><p>任务结构中的一个条目指向mm_struct，它描述来虚拟内存的当前状态。我们感兴趣的两个字段是pgd和mmap，其中pgd指向第一级页表（页全局目录）的基址，而mmap指向一个vm_area_structs（区域结构）的链表，其中每个vm_area_structs都描述来当前虚拟地址空间的一个区域。当内核运行这个进程时，就将pgd存放在CR3控制寄存器中。</p><p>一个具体区域结构包含下面的字段：</p><ul><li>vm_start：指向这个区域的起始处。</li><li>vm_end：指向这个区域的结束处。</li><li>vm_prot：描述这个区域内包含的所有页的读写许可权限。</li><li>vm_flags：描述这个区域内的页面是与其他进程共享的，还是这个进程私有的</li><li>vm_next：指向链表中下一个区域结构</li></ul><h3 id="9-7-2-Linux缺页异常处理"><a href="#9-7-2-Linux缺页异常处理" class="headerlink" title="9.7.2 Linux缺页异常处理"></a>9.7.2 Linux缺页异常处理</h3><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.26.png" alt="image-9.26"></p><p>当MMU试图翻译某个虚拟地址A时，触发来一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤：</p><ul><li><p>1 虚拟地址A是合法的吗？A在某个区域结构定义的区域内吗？缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end做比较。如果这个指令不合法，那么缺页处理程序就触发一个段错误，从而终止这个进程（标识为1）。</p><p>因为一个进程可以创建任意数量的新虚拟内存区域（使用在下一节中的mmap），所以顺序搜索区域结构的链表花销可能会很大。在实际中，Linux使用某些我们没有显示出来的字段，Linux在链表中构建了一棵树，并在这棵树上进行查找。</p></li><li><p>2 试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个缺页是不是有一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？这个缺页是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字段造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。（标识2）</p></li><li><p>3 此刻，内核指导这个缺页是由对合法的模拟地址进行合法的操作造成的。</p><ul><li>它是这样处理缺页的<ul><li>选择一个牺牲页面，如果这个页面被修改过，那么久将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送到A到MMU。这回MMU就能正常翻译地址A。</li></ul></li></ul></li></ul><h2 id="9-8-内存映射"><a href="#9-8-内存映射" class="headerlink" title="9.8 内存映射"></a>9.8 内存映射</h2><p>Linux将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型的对象中的一种。</p><ul><li>1 Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。文件区（section）被分成页大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到CPU第一次引用到页面（即发射一个虚拟地址，落在地址空间这个页面的范围之内）。如果区域比文件区要大，那么就用0来填充这个区域余下部分。</li><li>2 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件由内核创建，全是二进制的0。CPU第一次引用这样的区域时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制0覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制0的页。</li></ul><p>无论怎样，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件之间换来换去。交换文件也叫交换空间，或者交换区域。</p><p>任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。</p><h3 id="9-8-1-再看共享对象"><a href="#9-8-1-再看共享对象" class="headerlink" title="9.8.1 再看共享对象"></a>9.8.1 再看共享对象</h3><p>如果讯内存系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到内存中的方法。</p><p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些把这个共享对象映射到他们虚拟内存的其他进程而言，也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。</p><p>另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟内存区域叫做共享区域。类似的，也有私有区域。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.27.png" alt="image-9.27"></p><p>假设进程1将一个共享对象映射到它的虚拟内存的一个区域中。现在假设进程2将同一个共享对象映射到它的地址空间，因为每个对象有唯一文件名，内核可以迅速地判定进程1已经映射了这个对象，而且可以使进程2中的页表条目指向相应的物理页面。关键是即使对象被映射到啦多个共享区域，物理内存中也只需要存放共享对象的一个副本。</p><p>私有对象使用写时复制的技术被映射到虚拟内存中。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.28.png" alt="image-9.28"></p><p>私有对象开始生命周期的方式与共享对象基本一样，在物理内存中只保存有私有对象的一份副本。</p><p>上图两个进程将一个私有对象映射到它们虚拟内存的不同区域，但共享同一个物理副本。对于每个映射啦私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程试图写他自己的私有区域，他们就可以继续共享物理内存中对象的一个单独副本。然而，只要有一个进程试图写私有区域的某个页面，那么这个写操作就会触发一个保护故障。</p><p>当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限。</p><p>如图当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。</p><h3 id="9-8-2-再看fork函数"><a href="#9-8-2-再看fork函数" class="headerlink" title="9.8.2 再看fork函数"></a>9.8.2 再看fork函数</h3><p>fork函数创建一个带有自己独立虚拟地址空间的新进程</p><p>当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID。未来给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</p><p>当fork返回时，新进程现在的虚拟内存刚好和调用fork时的虚拟内存相同，当这两个进程中的任一个来进行写操作时，写时复制机制就会创建新页面。位每个进程保持来私有地址空间的抽象。</p><h3 id="9-8-3-再看execve函数"><a href="#9-8-3-再看execve函数" class="headerlink" title="9.8.3 再看execve函数"></a>9.8.3 再看execve函数</h3><p>假设运行在当前进程中的程序执行了如下的execve调用：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-string">&quot;a.out&quot;</span>,NULL,NULL)</span></span></code></pre></div><p>execve函数在当前进程中加载并运行包含在a.out中的程序，用a.out替代了当前程序，加载并运行一共有一下几个步骤。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.29.png" alt="image-9.29"></p><ul><li>删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li>映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为a.out文件中的.text和.data区。bss区域是请求二进制0的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制0的，初始长度为0。</li><li>映射共享区域。如果a.out程序与共享对象（或目标）链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li><li>设置程序计数器（PC）。execve最后会设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。下一次调度这个进程时，它将从这个入口点开始执行。Linux会根据需要换入代码和数据页面。</li></ul><h3 id="9-8-4-使用mmap函数的用户级内存映射"><a href="#9-8-4-使用mmap函数的用户级内存映射" class="headerlink" title="9.8.4 使用mmap函数的用户级内存映射"></a>9.8.4 使用mmap函数的用户级内存映射</h3><p>mmap被用来创建新的虚拟内存区域，并将对象映射到这些区域中。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.30.png" alt="image-9.30"></p><p>mmap函数要求内核创建一个新的虚拟内存区域，最好从start开始的一个区域，并将文件描述符fd指定的对象的一个连续的片映射到这个新的区域。连续的对象片大小为length字节，从文件开始处偏移量为offset字节的地方开始。start地址仅仅是一个暗示，通常被定义为NULL。我们总是假设起始地址为NULL。</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.31.png" alt="image-9.31"></p><p>prot包含描述新映射的虚拟内存区域的访问权限位（vm_prot位）</p><ul><li>PROT_EXEC：这个区域内的页面由可以被CPU执行的指令组成。</li><li>PROT_READ：这个区域内的页面可读。</li><li>PROT_WRITE：这个区域内的页面可写。</li><li>PROT_NONE：这个区域内的页面不能被访问。</li></ul><p>参数flags由描述被映射对象类型的位组成。如果设置了MAP_ANON标记位，那么被映射的对象就是匿名对象，相应的页面上请求二进制0的。</p><p>MAP_PRIVATE表示被映射的对象是一个私有的、写时复制对象，而MAP_SHARED表示是一个共享对象</p><div class="code-wrapper"><pre><code class="hljs 1c">bufp<span class="hljs-punctuation">=</span>Mmap<span class="hljs-punctuation">(</span><span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span>size<span class="hljs-punctuation">,</span>PROT_READ<span class="hljs-punctuation">,</span>MAP_PRIVATE<span class="hljs-string">|MAP_ANON,0,0)</span></code></pre></div><p>如果嗲用成功bufp包含新的区域地址。</p><p>munmap函数删除虚拟内存的区域：</p><p><img src="/2025/01/10/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.32.png" alt="image-9.32"></p><p>munmap删除函数从start开始，到接下来length字节组成的区域，如果再引用已删除的区域会导致段错误。</p><h2 id="9-9-动态内存分配"><a href="#9-9-动态内存分配" class="headerlink" title="9.9 动态内存分配"></a>9.9 动态内存分配</h2><h2 id="9-10-垃圾收集"><a href="#9-10-垃圾收集" class="headerlink" title="9.10 垃圾收集"></a>9.10 垃圾收集</h2><p>如果程序猿分配了一块内存空间，但忘记释放这个块。它就是内存泄漏。</p><p>垃圾收集器定期识别垃圾块，并相应的调用free，将这些块放回到空闲链表中。</p><h3 id="9-10-1-垃圾收集器的基本知识"><a href="#9-10-1-垃圾收集器的基本知识" class="headerlink" title="9.10.1 垃圾收集器的基本知识"></a>9.10.1 垃圾收集器的基本知识</h3><p>垃圾收集器将内存视为一张有向可达图，该图的节点被分成一组根节点和一组堆节点。根节点对应一种不在堆中的位置，从根节点不可达的节点对应为垃圾。</p><p>需要堆空间时，调用malloc，如果找不到一个合适的空闲块，那么就调用垃圾收集器，希望能回收一些垃圾，收集器去调用free，返回后malloc重试。</p><h3 id="9-10-2-Mark-Sweep垃圾收集器"><a href="#9-10-2-Mark-Sweep垃圾收集器" class="headerlink" title="9.10.2 Mark&amp;Sweep垃圾收集器"></a>9.10.2 Mark&amp;Sweep垃圾收集器</h3><p>标记清除垃圾收集器</p><p>如果一个块不指向任何块，mark函数就立刻返回，否则就标记这个块，这样任何未标记的都被认为是不可达的，在清除阶段回收。</p><p>sweep在堆上反复循环，释放它所遇到所有未标记的已分配块。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP深入理解计算机系统-第八章-异常控制流</title>
    <link href="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="8-0-学习ECF-异常控制流"><a href="#8-0-学习ECF-异常控制流" class="headerlink" title="8.0 学习ECF(异常控制流)"></a>8.0 学习ECF(异常控制流)</h2><ul><li>帮助操作系统实现I&#x2F;O、进程和虚拟内存的基本机制</li><li>应用程序通过（trap）或者（system call）的ECF形式，向操作系统进行交互</li><li>并发的基本机制</li><li>理解软件异常如何工作</li></ul><h2 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h2><p>异常就是控制流中的突变，用来响应处理器状态中的某些变化</p><p>有异常事件发生时，会通过一张异常表的跳转表，进行一个间接调用，到一个专门设计用来处理操作系统子程序。异常处理程序完成处理后，会有以下三种情况。</p><ul><li>处理程序将控制返回给当前指令，即当事件发生时正在执行的指令；</li><li>处理程序将控制返回给原指令，如果没有发生异常将会执行的下一跳指令；</li><li>处理程序终止被中断的程序。</li></ul><h3 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h3><p>系统启动时，操作系统分配和初始化一张异常表，包含异常的处理程序的地址。<br>当异常发生时，确定了相对应的异常号后，触发异常，通过间接过程进行调用，通过异常表的表目跳转到相对应的处理程序。</p><p>异常表的起始地址放在一个叫做异常表基址寄存器的特殊CPU寄存器里。<br>异常类似于过程调用，有一些不同之处。</p><ul><li>过程调用，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令，要么是下一条的指令。</li><li>处理器把额外的处理器状态压到栈里，在处理程序返回是，重新开始执行被中断的程序也会需要这些状态。</li><li>如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。</li><li>异常处理程序运行在内核模式下，意味着它们对所有的资源都有完全访问权限。</li></ul><p>异常处理完成后执行重中断返回指令，回到中断程序或将控制返回到下一跳执行，或者终止程序。</p><h3 id="8-1-2-异常的类别"><a href="#8-1-2-异常的类别" class="headerlink" title="8.1.2 异常的类别"></a>8.1.2 异常的类别</h3><p>异常有四种</p><ul><li>中断<ul><li>原因：来自I&#x2F;O设备的信号</li><li>异步</li><li>总是返回到下一条指令</li></ul></li><li>陷阱<ul><li>原因：有意的异常</li><li>同步</li><li>总是返回到下一条指令</li></ul></li><li>故障<ul><li>原因：潜在可恢复的错误</li><li>同步</li><li>可能返回到当前指令</li></ul></li><li>终止<ul><li>原因：不可恢复的错误</li><li>同步</li><li>不会返回</li></ul></li></ul><p>异步异常是由处理器外部的 I&#x2F;O设备中的事件产生。同步异常是执行一条指令的直接产物。</p><h4 id="8-1-2-1、中断"><a href="#8-1-2-1、中断" class="headerlink" title="8.1.2.1、中断"></a>8.1.2.1、中断</h4><p>硬件中断的异常处理程序常常称为中断处理程序。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.1.png"></p><p>当前指令完成执行后，中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。处理程序返回就执行下一条指令。</p><p>剩下的是同步异常，是执行当前指令的结果，也叫做故障指令。</p><h4 id="8-1-2-2、陷阱和系统调用"><a href="#8-1-2-2、陷阱和系统调用" class="headerlink" title="8.1.2.2、陷阱和系统调用"></a>8.1.2.2、陷阱和系统调用</h4><p>陷阱是有意的异常，陷阱处理程序将控制返回到下一条指令。陷阱更多是提供一个过程接口，叫做系统调用。</p><p>例如用户程序需要向内核请求服务，比如读一个文件，创建一个新的进程，加载一个新的程序，或者终止当前进程。为了允许，对这些内核的受控访问，处理器提供 syscall 指令，会进入一个陷阱，在这里处理程序解析参数，并调用适当的内核程序。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.2.png"></p><p>程序调用在用户模式，系统调用在内核模式中。</p><h4 id="8-1-2-3、故障"><a href="#8-1-2-3、故障" class="headerlink" title="8.1.2.3、故障"></a>8.1.2.3、故障</h4><p>故障由错误引起，如果处理程序能够修正，就控制返回到引起故障的指令，从而重新执行它，否则处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.3.png"></p><p>例如缺页异常，当引用的虚拟地址，匹配的物理页面不在内存中，会发生故障，缺页处理程序从磁盘加载适当的页面，然后将控制返回引起故障的指令。当指令执行的时候页面已经在内存中了，就可以继续执行下去了。</p><h4 id="8-1-2-4、终止"><a href="#8-1-2-4、终止" class="headerlink" title="8.1.2.4、终止"></a>8.1.2.4、终止</h4><p>终止是不可恢复的致命错误，如DRAM或SRAM被损坏时发生的错误，处理程序不会将控制返回应用程序，而是直接返回给一个abort例程，终止这个应用程序。</p><h3 id="8-1-3-Linux中的异常"><a href="#8-1-3-Linux中的异常" class="headerlink" title="8.1.3 Linux中的异常"></a>8.1.3 Linux中的异常</h3><p>0～31 是Intel架构师定义的异常；</p><p>32～255 是操作系统中的中断和陷阱；</p><h4 id="8-1-3-1-故障和终止"><a href="#8-1-3-1-故障和终止" class="headerlink" title="8.1.3.1 故障和终止"></a>8.1.3.1 故障和终止</h4><ul><li><p>除法错误<br>除0的时候会发生除法错误（异常0）。Unix会终止程序.</p></li><li><p>一般保护故障<br>许多原因导致（异常13），通常是因为一个程序引用了未定义虚拟内存区域，或者试图写一个只读的文本段，Linux不会修复这类故障。</p></li><li><p>缺页<br>物理页没有映射到引发的故障，（异常14）</p></li><li><p>机器检查<br>机器检查（异常18）指令执行中遭遇致命硬件错误时发生的。</p></li></ul><h4 id="8-1-3-2-系统调用"><a href="#8-1-3-2-系统调用" class="headerlink" title="8.1.3.2 系统调用"></a>8.1.3.2 系统调用</h4><p>每个系统调用都有一个唯一的整数号，对应到内核中跳转表的偏移量，可通过syscall陷阱指令来调用。</p><p>系统调用的参数都是通过寄存器而不是栈传递的。</p><p>一般</p><ul><li>rax 包含系统调用号</li><li>rdi rsi rdx r10 r8 r9 包含最多6个参数</li></ul><p>系统调用返回时，寄存器 rcx 和 r11 都会被破坏，rax包含返回值。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.4.png"></p><p>返回 -4095 到 -1 之间的负数代表发生了错误。</p><h2 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h2><p>异常是允许系统内核提供进程概念的基本模块，是计算机科学中最深刻，最成功的概念之一。</p><p>现代系统运行时有一个假象</p><ul><li>程序独占的使用处理器</li><li>程序独占的使用内存系统</li></ul><p>程序好像是无间的一条一条执行程序中的指令，这些假象是通过进程的概念提供给我们的。</p><p>系统中的每个程序都运行在某个进程的上下文中。</p><ul><li>上下文是由程序正确运行所需的状态组成的。状态包括存放在内存中的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</li></ul><p>用户向shell输入一个新的可执行文件的名字，运行程序时，shell就会创建一个新进程，然后在这个新进程的上下文中运行这个可执行目标文件。</p><p>进程提供给应用程序的关键抽象</p><ul><li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器</li><li>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。</li></ul><h4 id="8-2-1-逻辑控制流"><a href="#8-2-1-逻辑控制流" class="headerlink" title="8.2.1 逻辑控制流"></a>8.2.1 逻辑控制流</h4><p>执行程序时，程序计数器（PC）值的序列叫逻辑控制流简称逻辑流。</p><p>是轮流使用处理器的，执行一部分然后被挂起。</p><h4 id="8-2-2-并发流"><a href="#8-2-2-并发流" class="headerlink" title="8.2.2 并发流"></a>8.2.2 并发流</h4><p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流，这两个流并发的运行。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.5.png"></p><ul><li>A 和 B是并发运行</li><li>A 和 C也是并发运行</li><li>B 和 C 不是，因为B已经运行结束了</li></ul><p>多个流并发的执行的一般现象被称为并发。一个进程和其他进程轮流运行称为多任务。一个进程执行它的控制流的一部分的每一时间段叫时间片。因此多任务也叫时间分片。</p><ul><li>进程A有两个时间片</li><li>进程B有一个时间片</li><li>进程C有两个时间片</li></ul><p>如果两个流并发的运行在不同的处理器核或者计算机上，那么我们称它们为并行流，并行的运行且并行的执行。</p><h4 id="8-2-3-私有地址空间"><a href="#8-2-3-私有地址空间" class="headerlink" title="8.2.3 私有地址空间"></a>8.2.3 私有地址空间</h4><p>每个进程好像独占的使用系统地址空间。</p><p>在一台n位地址的机器上，地址空间是是2^n个可能地址的集合，0，1，…，2^n-1。进程为每个程序提供它自己的私有地址空间。这个空间中某个地址关联的内存字节是不能被其他进程读或者写的，所以地址空间是私有的。</p><p>进程的地址空间结构相同。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.6.png"></p><ul><li>底部是用户程序的，包括通常的代码、数据、堆和栈。总是从0x400000开始。</li><li>地址空间顶部保留给内核（操作系统常驻内存的部分）属于用户代码不可见。</li></ul><h4 id="8-2-4-用户模式和内核模式"><a href="#8-2-4-用户模式和内核模式" class="headerlink" title="8.2.4 用户模式和内核模式"></a>8.2.4 用户模式和内核模式</h4><p>为了使操作系统内核提供一个无懈可击的进程对象，处理器限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p><p>处理器通常是控制寄存器中的一个模式位来提供这种功能的，该寄存器描述了进程当前享有的特权。</p><ul><li>当设置了模式位时，进程就运行在内核模式中。运行在内核模式中的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</li><li>没有设置位置位时，进程运行在用户模式中，用户模式中的进程不允许执行特权指令，如停止处理器、改变模式位，或者发起一个I&#x2F;O操作。也不许用户模式中的进程之间引用地址空间中内核区的代码和数据。任何这种操作都会导致致命的保护故障，用户程序必须通过系统调用接口间接地访问内核代码和数据。</li></ul><p>运行应用程序代码的进程一开始是在用户模式中运行，变成内核模式的唯一方法就是中断、故障、陷入这种异常。</p><p>一发生异常，处理器就会从用户模式转为内核模式，处理程序运行在内核模式中，返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。</p><p>Linux 可以通过 &#x2F;proc文件访问内核的数据结构。</p><h4 id="8-2-5-上下文切换"><a href="#8-2-5-上下文切换" class="headerlink" title="8.2.5 上下文切换"></a>8.2.5 上下文切换</h4><p>内核使用上下文切换的较高层形式的异常控制流来实现多任务。</p><p>内核为每一个进程维护一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。由一些对象的值组成。包含通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p><p>进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占流的进程。这种决策叫做调度。由调度器处理。</p><p>内核新运行一个进程时会抢占当前进程，并使用上下文切换将控制转移到新进程</p><p>上下文切换</p><ul><li>1 保存当前进程的上下文；</li><li>2 恢复某个先前被抢占的进程被保存的上下文；</li><li>3 将控制传递给这个新恢复的进程。</li></ul><p>内核代表用户执行系统调用时，可能会发生上下文切换，如果系统调用因为等待某个事件发生而阻塞，内核可以让当前进程休眠，切换到另一个进程。</p><p>如果一个read系统调用需要访问的磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。</p><p>中断也有可能引发上下文切换。所有系统都有某种产生周期性定时器中断的机制，通常为1毫秒或10毫秒，每次定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新进程。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.7.png"></p><ul><li>进程 A 在用户模式下执行；</li><li>A 需要读取数据执行read陷入到内核中，磁盘读取数据时间较长；</li><li>上下文切换到进程 B 在用户模式下运行；</li><li>磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存；</li><li>内核判断 B 运行时间足够长；</li><li>就上下文切换到 A ，继续执行。</li></ul><h2 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h2><p>错误检查让代码臃肿难读<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.8.png"></p><p>可以一定程度上包装一个函数来简化这一切<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.9.png"></p><p>这样调用变为<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.10.png"></p><p>通过使用错误处理包装函数，可以进一步简化代码。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.11.png"></p><p>给定这个包装函数，堆fork的调用为<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.12.png"></p><h2 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h2><h3 id="8-4-1-获取进程ID"><a href="#8-4-1-获取进程ID" class="headerlink" title="8.4.1 获取进程ID"></a>8.4.1 获取进程ID</h3><p>每个进程都有一个唯一的正数（非0）进程ID。</p><p>getpid函数返回调用进程的PID。</p><p>getpid函数返回它的父进程的PID</p><p>getpid 和 getppid 函数返回一个类型为pid_t的整数值，在Linux系统上它在types.h中被定义为int。</p><h3 id="8-4-2-创建和终止进程"><a href="#8-4-2-创建和终止进程" class="headerlink" title="8.4.2 创建和终止进程"></a>8.4.2 创建和终止进程</h3><p>程序员的角度，进程处于下面三种状态之一。</p><ul><li>运行，进程要么在CPU上执行，要么在等待执行并最终会被调度。</li><li>停止，进程的执行被挂起，且不会被调度。当收到SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOU信号时，进程就会停止，且保持停止直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。</li><li>终止，进程永远的终止了，进程会因为三种原因终止：<ul><li>收到一个信号，该信号的默认行为是终止进程；</li><li>从主程序返回</li><li>调用exit函数。</li></ul></li></ul><p>exit函数以status退出状态来终止进程，另一种退出状态的方法是从主程序中返回整数值。</p><p>父进程通过调用fork函数创建一个新的运行的子进程。</p><ul><li>子进程与父进程用户级虚拟地址空间相同，是一份独立的副本，包含代码数据段、堆、共享库以及用户栈；</li><li>子进程还获得与父进程中打开堆任何文件，父进程和新创建的子进程有两个不同的PID。</li></ul><p>如</p><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.13.png"></p><p>上面的例子会创建一个子进程。</p><ul><li><p>调用一次，返回两次。<br>一次是返回到父进程，一次是返回到新创建的子进程</p></li><li><p>并发执行。<br>父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行逻辑控制流中的指令</p></li><li><p>相同但是独立的地址空间。<br>能够在fork函数在父进程和子进程中返回后理解暂停这两个进程，会看到两个进程的地址空间都是相同的。每个进程都有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。本地变量x在父子进程的私有地址空间里的任何改变都是独立的，不会反应在另一个进程的内存中。</p></li><li><p>共享文件。<br>父进程和子进程都把它们的输出显示在屏幕上，子进程继承里父进程所有的打开文件。当父进程调用fork时，stdout文件是打开的，并指向屏幕，子进程继承了这个文件，所以输出也是指向屏幕的。</p></li></ul><h3 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h3><p>当一个进程终止时，内核不会立即清楚它，而是保持在一种已终止的状态中，直到被父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已经终止的进程，从此时开始，该进程就不存在了。一个终止了但未被回收的进程称为僵死进程。</p><p>当一个父进程终止了，内核会安排init进程称为它的孤儿进程的养父。init进程的PID为1，是系统启动时由内核创建的，不会终止，是所有进程的祖先。而后由init进程去回收它们。</p><p>进程可以通过调用<code>waitpid</code>函数来等待它的子进程终止或停止。</p><p>如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么waitpid就立即返回，内核会删除它的所有痕迹。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.14.png"></p><ul><li><p>1.判定等待集合的成员</p><ul><li>等待集合的成员是由参数pid来确定的：</li><li>如果pid&gt;0，那么等待集合就是一个单独的子进程，它的进程ID等于pid</li><li>如果pid&#x3D;-1那么等待集合就是由父进程所有的子进程组成。</li></ul></li><li><p>修改默认行为</p><p>通过将options设置为常量 WNOHANG、WUNTRACED、WCONTINUED 的各种组合来修改默认行为。</p><ul><li><p>WNOHANG<br>如果等待集合中的任何子进程都没有终止，那么就立即返回（返回0）。默认行为是挂起调用进程，直到有子进程终止。</p></li><li><p>WUNTRACED<br>挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PID为导致返回的已终止或被停止的子进程PID。默认行为是只返回已终止的子进程。当你想要检查已终止和被停止的子进程时使用。</p></li><li><p>WCONTINUED<br>挂起调用进程的执行，直到等待集合中的一个正在运行的进程终止，或等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。</p></li><li><p>WNOHANG ｜ WUNTRACED<br>立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为0；如果有进程停止或终止，返回中为该子进程的PID。</p></li></ul></li><li><p>检查已回收子进程的退出进程<br>如果<code>statusp</code>参数是非空的，<code>waitpid</code>就会在<code>status</code>中放上关于导致返回的子进程的状态信息，<code>status</code>是<code>statusp</code>指向的值。wait.h头文件定义了解释<code>status</code>参数的几个宏</p><ul><li><p>WIFEXITED(status)<br>如果子进程通过调用exit或者一个返回（return）正常终止，就返回真</p></li><li><p>WEXITSTATUS(status)<br>返回一个正常终止的子进程的退出状态。只有在 WIFEXITED() 返回为真时，才会定义这个状态。</p></li><li><p>WIFSIGNALED(status)<br>如果子进程是因为一个未被捕获的信号终止的，那么就返回真</p></li><li><p>WTERMSIG(status)<br>返回导致子进程终止的信号的编号。只有在 WIFSIGNALED() 返回为真时，才定义这个状态。</p></li><li><p>WIFCONTINUED(status)<br>如果子进程收到SIGCONT信号重新启动，则返回真。</p></li></ul></li><li><p>错误条件<br>如果调用进程没有子进程，那么waitpid 返回 -1，并且设置 errno 为 ECHILD。如果waitpid函数被一个信号中断，那么返回 -1， 并设置errno 为EINTR。</p></li></ul><h3 id="8-4-4-让进程休眠"><a href="#8-4-4-让进程休眠" class="headerlink" title="8.4.4 让进程休眠"></a>8.4.4 让进程休眠</h3><p>sleep 函数将一个进程挂起一段指定的时间</p><p>如果时间量已经到了，sleep返回0，否则返回还剩下要休眠的秒数。</p><p>pause 函数让函数休眠，直到该进程收到一个信号。</p><h3 id="8-4-5-加载并运行程序"><a href="#8-4-5-加载并运行程序" class="headerlink" title="8.4.5 加载并运行程序"></a>8.4.5 加载并运行程序</h3><p>execve 函数在当前进程的上下文中加载并运行一个新程序。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.15.png"></p><p>execve 函数加载并运行目标文件filename，并且带参数列表argv和环境变量列表envp。</p><p>参数列表 argv数组<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.16.png"></p><ul><li>argv[0] 是可执行目标文件的名字；</li><li>argv[1]表示第一个参数；</li><li>argc表示参数的个数。</li></ul><p>环境变量列表envp<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.17.png"></p><ul><li>包括当前的工作目录等环境变量</li></ul><p>execve加载了filename之后，调用启动代码设置栈，并将控制传递给新程序的主函数，指向数组中的第一个元素<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.18.png"></p><p>当main开始执行时，用户栈的组织结构如下。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.19.png"></p><ul><li>main 由libc_start_main调用，所以main在低地址。</li></ul><h2 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h2><p>信号就是一条小消息，通知进程系统中发生率某种类型的事件，运行内核或进程可以中断其他进程。</p><p>正常情况下异常由内核处理，用户程序不可见，通过信号可以通知进程发生了什么异常情况。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.20.png"></p><h3 id="8-5-1-信号术语"><a href="#8-5-1-信号术语" class="headerlink" title="8.5.1 信号术语"></a>8.5.1 信号术语</h3><p>传送一个信号到目的进程是由灵感不同的步骤组成</p><ul><li><p>发送信号<br>内核检测到一个系统事件，或是调用了kill函数，显式的要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</p></li><li><p>接收信号<br>目的进程被内核强迫以某种方式对信号的发送做出反应，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为<code>信号处理程序</code>的用户层函数捕获这个信号。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.21.png"></p></li></ul><p>信号处理。接收到信号会触发控制转移到信号处理程序。在信号处理程序完成处理后，它将控制返回给被中断的程序。</p><p>发出而没被接收的信号叫待处理信号。任何时刻，一种类型最多只会有一个待处理信号。如果一个进程有一个k类型的待处理信号，接下来接收的任何k类型的信号都会被丢弃。</p><p>一个进程可以有选择的阻塞接收某种信号，当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p><p>一个待处理信号最多被接收一次，内核在pading位向量中维护着待处理信号的集合，而在blocked位向量中维护着被阻塞的信号集合。只要传送了一个类型位k的信号，内核就会设置pending中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。</p><h3 id="8-5-2-发送信号"><a href="#8-5-2-发送信号" class="headerlink" title="8.5.2 发送信号"></a>8.5.2 发送信号</h3><p>发送信号的机制是机遇进程组实现的。</p><h4 id="8-5-2-1-进程组"><a href="#8-5-2-1-进程组" class="headerlink" title="8.5.2.1 进程组"></a>8.5.2.1 进程组</h4><p>每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。</p><p>getpgrp函数返回当前进程的进程组ID<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.22.png"></p><p>可以通过 setpgid 函数改变自己或者其他进程的进程组。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.23.png"></p><p>setpgid函数将进程pid的进程组改为pgid。如果pid是0，那么就使用当前进程的pid。如果pgid是0，那么就用pid指定的进程的PID作为进程组ID。</p><div class="code-wrapper"><pre><code class="hljs stylus">例如进程<span class="hljs-number">15213</span>调用进程<span class="hljs-function"><span class="hljs-title">setpgid</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>会创建一个新的进程组，其进程组ID是<span class="hljs-number">15213</span>，并且把进程<span class="hljs-number">15213</span>加入到这个新进程组中。</code></pre></div><h4 id="8-5-2-2-用-bin-kill程序发送信号"><a href="#8-5-2-2-用-bin-kill程序发送信号" class="headerlink" title="8.5.2.2 用&#x2F;bin&#x2F;kill程序发送信号"></a>8.5.2.2 用&#x2F;bin&#x2F;kill程序发送信号</h4><p>kill指令可以向另外的进程发送任意的信号。</p><p><code>/bin/kill -9 -15213</code>发送了一个SIGKILL信号给进程组15213中的每个进程</p><h4 id="8-5-2-3-从键盘发送信号"><a href="#8-5-2-3-从键盘发送信号" class="headerlink" title="8.5.2.3 从键盘发送信号"></a>8.5.2.3 从键盘发送信号</h4><p>shell 使用job概念表示对一条命令行求值而创建的进程。在任何时刻，最多有一个前台作业，0或多个后台作业。</p><p>输入<code>Ctrl + C</code>发送一个SIGINT信号到前台进程组中的每一个进程。</p><p>输入<code>Ctrl + Z</code>发送一个SIGSTP信号到前台进程组中的每一个进程，会挂起前台作业。</p><p><code>ls | sort</code>会创建由两个进程组合的前台作业，一个运行ls程序，一个运行sort程序，</p><p>ls的结果通过管道符成为sort的输入。</p><p>shell为每个作业创建了独立的进程组。进程组ID通常取自作业中父进程的一个<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.24.png"></p><h4 id="8-5-2-4-用kill函数发送信号"><a href="#8-5-2-4-用kill函数发送信号" class="headerlink" title="8.5.2.4 用kill函数发送信号"></a>8.5.2.4 用kill函数发送信号</h4><p>可以通过调用函数kill向其他进程发送信号（包括自己）。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.25.png"></p><ul><li>pid 大于0，函数发送信号给进程pid</li><li>pid 等于0，很少发送信号给调用进程所在组的所有进程，包括自己</li><li>pid小于0，kill发送信号sig给进程组 ｜pid｜（pid的绝对值）中的每个进程。</li></ul><h4 id="8-5-2-5-alarm发送信号"><a href="#8-5-2-5-alarm发送信号" class="headerlink" title="8.5.2.5 alarm发送信号"></a>8.5.2.5 alarm发送信号</h4><p>进程可以通过调用alarm函数向自己发送 SIGALRM信号<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.26.png"></p><p>alarm 函数安排内核在 secs 秒后发送一个 AIGALRM 信号给调用进程。</p><p>如果secs是0那么就不会调度安排新的alarm。</p><p>对alarm的调用都将取消任何待处理的alarm，并返回任何待处理alarm在被发送前还剩下的秒数，如果没有alarm就返回0。</p><h3 id="8-5-3-接收信号"><a href="#8-5-3-接收信号" class="headerlink" title="8.5.3 接收信号"></a>8.5.3 接收信号</h3><p>当内核把进程切换到用户模式时，会检查进程的未被阻塞的待处理信号的集合，如果集合为空，那么内核将控制传递到逻辑控制流中的下一条指令。如果集合是非空的，那么内核选择集合中某个信号k（一般是最小的），并强制进程接收信号k。接收到这个信号会采取一定行为，完成后控制就传递回进程的逻辑控制流中的下一条指令。每个信号都有一个预定义的默认行为。</p><ul><li>进程终止；</li><li>进程终止并转储内存（把代码和数据写到磁盘上）；</li><li>进程停止（挂起）直到被SIGCONT信号重庆；</li><li>进程忽略该信号（SIGCHLD）</li></ul><p>信号处理程序可以被其他信号中断。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8.27.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP深入理解计算机系统_第七章-链接</title>
    <link href="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/"/>
    <url>/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>链接是将各种代码和数据片段收集并合并成一个单一文件的过程，这个文件可被加载到内存并执行。</p><h2 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h2><ol><li>预处理器 生成一个ASCII码的中间文件 main.i</li><li>编译器 将main.i翻译成ASCII汇编语言文件 main.s</li><li>汇编器 将main.s翻译成可重定位目标文件 main.o</li><li>链接器 ld将main.o和一些重要的文件组合起来，创建一个可执行目标文件prog</li><li>运行文件时，shell调用加载器将可执行文件prog中的代码和数据复制到内存，然后将控制转移到程序开头</li></ol><h2 id="7-2-静态链接"><a href="#7-2-静态链接" class="headerlink" title="7.2 静态链接"></a>7.2 静态链接</h2><p>linux ld这种的静态链接器，以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件为输出。输入的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全集变量在另一节中，未初始化的变量在另外一节中</p><ul><li><p>符号解析：目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。目的是将每个符号引用正好和一个符号定义关联起来。</p></li><li><p>重定位：编译器和汇编器生成从地址 0 开始的代码和数据节，连通器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。连接器使用汇编器产生的重定位条目的详细指令，不加甄别的执行。</p></li></ul><h2 id="7-3-目标文件"><a href="#7-3-目标文件" class="headerlink" title="7.3 目标文件"></a>7.3 目标文件</h2><ul><li><p>可重定位目标文件<br>包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</p></li><li><p>可执行目标文件<br>包含二进制代码和数据，其形式可以被直接复制到内存并执行。</p></li><li><p>共享目标文件<br>一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地价值进内存并链接。</p></li></ul><p>编译器和汇编器生成可重定位目标文件（共享目标文件）。链接器生成可执行目标文件。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.1.png"></p><p>编译指令</p><ul><li><p>预处理阶段：-E 只做预处理将头文件、宏定义展开、条件编译等选择等，转为c语言</p><ul><li>处理头文件（#include）、宏展开（#define），生成预处理后的<code>中间代码</code> .i 文件<br><code>gcc -E main.c -o main.i</code></li></ul></li><li><p>编译阶段：-S 只编译不连接，将<code>中间代码</code>编译为汇编代码“.s”</p><ul><li>针对预处理的结果进行一系列词法分析、语法分析、语义分析，优化后生成汇编指令，存放在.s目标文件中<br><code>gcc -S main.i -o main.s</code></li></ul></li><li><p>优化: -O 选择优化级别： -O0 -O1 -O3 最大优化<br> <code>gcc -O2 main.s -o main.s</code></p></li><li><p>汇编阶段：-c 汇编输出文件转换成机器语言，并生成为可重定位目标文件，.o，跳过了生成汇编代码的步骤。<br><code>gcc -c main.s -o main.o</code></p></li><li><p>链接：生成可执行文件<br><code>gcc main.o -o main.out</code> <code>or</code><br><code>ld -static -o prog main.o sum.o </code></p><p>还需要其它文件</p><div class="code-wrapper"><pre><code class="hljs stylus">crt1<span class="hljs-selector-class">.o</span>crti<span class="hljs-selector-class">.o</span>crtbeginT<span class="hljs-selector-class">.o</span>crtend<span class="hljs-selector-class">.o</span>crtn.o</code></pre></div></li><li><p>gcc -g 在输出的文件中加热支持调试的信息</p></li><li><p>gcc -v 显示输出项目的命令执行过程信息</p></li></ul><p>GDB调试指令</p><ul><li>编译程序并在选项中加入 -g<ul><li><code>gcc -g test.c</code></li></ul></li><li>运行 gdb 和程序<ul><li><code>gdb a.out</code></li></ul></li><li>设置断点<ul><li><code>(gdb) b6</code></li></ul></li><li>运行程序<ul><li><code>(gdb) r</code></li></ul></li><li>程序暂停在断点处，执行查看<ul><li><code>(gdb) p xxx</code></li></ul></li><li>继续、单步或者恢复程序运行<ul><li><code>(gdb) s/n/c</code></li></ul></li></ul><h2 id="7-4-可重定位目标文件"><a href="#7-4-可重定位目标文件" class="headerlink" title="7.4 可重定位目标文件"></a>7.4 可重定位目标文件</h2><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.2.png"></p><p>ELF: 可执行可链接格式，二进制文件格式标准</p><p>ELF类型</p><ul><li>可从定位目标文件，内容包含代码和数据，可以被连接成可执行文件或共享目标文件，如Linux 上的 .o文件</li><li>可执行文件，可以直接执行的程序，Linux上的 a.out</li><li>共享目标文件， 内容包含代码和数据，可以作为链接器的输入，在连接阶段和其他的Relocatable File 或者 Shared Object File一起链接称新的Object File；或者在运行阶段，作为动态链接器的输入，和Executable File结合，作为进程的一部分来运行</li><li>核心转储文件，进程意外终止时，系统可以将该进程的部分内容和终止时的其他状态信息保存到该文件中以供调试分析，Linux上的core文件</li></ul><h3 id="7-4-1-ELF"><a href="#7-4-1-ELF" class="headerlink" title="7.4.1 ELF"></a>7.4.1 ELF</h3><p>ELF 头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.3.png"></p><ul><li><p>Magic： 魔数，描述了生成该文件的系统的字的大小和字节顺序<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.4.png"></p></li><li><p>Type：文件类型，REL可重定位文件，还有可执行文件和共享文件</p></li><li><p>Size of this header: 表示头部长度</p></li><li><p>Start of section headers: 节表所在的位置</p></li><li><p>Size of section headers： 每个表项的大小是64字节</p></li><li><p>Number of section headers：一共有13个表项</p></li></ul><p>Section headers</p><p><code>readelf -S main.o</code></p><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.5.png"></p><ul><li><p>Offset: 每个section的起始位置</p></li><li><p>Size：表示大小</p></li><li><p>.text (代码段)<br>已经编译好的机器代码</p></li><li><p>.data （数据段）<br>存放初始化的全局变量</p></li><li><p>.bss(Better Save Space) （未初始化的数据）<br>未初始化的全局和静态C变量，以及所有被初始化为0的全局静态变量。不占用实际空间，仅为占位符，运行时在内存分配这些变量，初始值为0.</p></li><li><p>rodata （只读数据段）<br>只读数据，比如printf语句汇总的格式串和switch中的跳转表，只能读取不能写入的数据</p></li><li><p>.symtab<br>一个符号表，放在程序中定义和引用的函数和全局变量的信息。</p></li><li><p>.rel.text （可重定位代码段）<br>一个.text节中位置的列表，当链接器把这个目标文件和其它文件组合时，需要修改这些位置。</p></li><li><p>.rel.data （可重定位数据段）<br>存放数据段段重定位信息<br><code>...</code></p></li><li><p>.line<br>C 源程序中的行号和 .text 节中机器指令之间的映射</p></li><li><p>.strtab<br>一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。</p></li></ul><h2 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h2><p>每个可重定位目标模块都有一个符号表，包含定义和引用的符号的信息。</p><p>在链接器的上下文中，有三种不同的符号。</p><ul><li>由模块定义并能够被其他模块引用的全局符号。全局链接器符号对应于静态的 C 函数和全局变量。</li><li>由其他模块定义并被模块引用的全局符号。被称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。</li><li>只被模块定义和引用的局部符号。他们对应于带static属性的 C 函数和全局变量。这些符号在模块中任何位置都可见，但是不能被其他模块引用。</li></ul><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.6.png"></p><p>对于上面程序有如下符号表</p><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.7.png"></p><ul><li>函数 main 和 func全局可见 所以类型是FUNC  Bind为GLOBAL，全局可见，Ndx为Section的索引值。</li><li>Value 表示函数相对于.text section起始位置的偏移量（16进制），Size表示字节数</li><li>printf只是在main中被引用所以他的Ndx是UND undefind 类型</li><li>count 和value的类型是OBJECT表示符号是数据对象，例如变量和数组。其中count经过量初始化位于3 中，但是value没有，value在 COM（COMMON）中。</li><li>COMMON 存放未初始化的全局变量</li><li>.bss存放未初始化的静态变量</li><li>局部静态变量a b 局部静态变量，局部变量Bind 为LOCAL，Ndx为3，b的初始化没什么用，Ndx为4。</li><li>变量名改变为了防止静态变量名字冲突。</li><li>局部变量x在运行时栈中被管理，链接器对这不感兴趣。</li></ul><h2 id="7-6-符号解析"><a href="#7-6-符号解析" class="headerlink" title="7.6 符号解析"></a>7.6 符号解析</h2><ul><li>强符号：函数和已初始化的全局变量为强符号</li><li>弱符号：未初始化的全局变量</li></ul><h3 id="7-6-1-处理多重定义的符号名"><a href="#7-6-1-处理多重定义的符号名" class="headerlink" title="7.6.1 处理多重定义的符号名"></a>7.6.1 处理多重定义的符号名</h3><ul><li>多个同名强符号一起出现</li><li>一个强符号和多个同名弱符号一起出现</li></ul><h3 id="7-6-2-与静态库链接"><a href="#7-6-2-与静态库链接" class="headerlink" title="7.6.2 与静态库链接"></a>7.6.2 与静态库链接</h3><p>将所有相关目标模块打包称为一个单独的文件时，只复制静态库里被引用的目标模块。</p><p>atoi、printf、scanf、strcpy、rand等都在libc.a的库中。</p><p>在Linux系统中静态库以命名为 archive 的特殊文件格式存放在磁盘上，是可从定位目标文件的集合。</p><p><code>objdump -t /user/lib/x86_64-linux-gnu/libc.a &gt; libc</code></p><p>可以得到都包含哪些目标文件<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.8.png"></p><p>上图可找到目标文件printf.o在第6615行。</p><p>打开可看到<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.9.png"></p><p>printf在printf.o中。</p><h3 id="7-6-3-构造一个静态库"><a href="#7-6-3-构造一个静态库" class="headerlink" title="7.6.3 构造一个静态库"></a>7.6.3 构造一个静态库</h3><p>可以使用<code>ar -x /usr/lib/x86_64-linux-gnu/libc.a</code>将文件解压到当前目录。</p><p>有两个 .c文件<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.10.png"></p><p>编译两个源文件 <code>gcc -c addvec.c mulvec.c</code></p><p>构造静态库 <code>ar rcs libvector.a addvec.o mulvec.o</code></p><p>可以得到一个名为 libvector.a 的静态库</p><p>如何使用<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.11.png"></p><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.12.png"></p><h3 id="7-6-3-链接器如何使用静态库来解析引用"><a href="#7-6-3-链接器如何使用静态库来解析引用" class="headerlink" title="7.6.3 链接器如何使用静态库来解析引用"></a>7.6.3 链接器如何使用静态库来解析引用</h3><p>在符号解析阶段，链接器从左到右按照它们在编译器启动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.13.png"></p><p>这里会先处理 main.o 之后是  .&#x2F;libvector.a 之后是libc.a（默认文件）</p><p>扫描中链接器维护一个可重定位目标文件的集合 <code>E</code> ，一个未解析的符号集合 <code>U</code> ，以及一个在前面输入文件中已定义的符号集合 <code>D</code>。</p><ul><li><code>E</code>：链接器扫描的过程中发现了可重定位目标文件就会放到这个集合中，在链接即将完成的时候，这个集合中的文件最终会被合并起来形成可执行文件。</li><li><code>U</code>：链接器会把引用的但尚未被定义的文件放到这个集合里。</li><li><code>D</code>：用来存放输入文件中已经定义的符号。</li></ul><p>初始时 <code>E</code>、<code>U</code>和<code>D</code>均为空。</p><ul><li><p>对于每个输入文件<code>f</code>，链接器会判断<code>f</code>是一个目标文件还是存档文件，如果是目标文件，就把<code>f</code>添加到<code>E</code>，修改<code>U</code>和<code>D</code>来反应<code>f</code>中的符号定义和引用，并继续下一个输入文件。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.14.png"></p></li><li><p>如果符号<code>f</code>是一个存档文件，那么链接器就尝试匹配<code>U</code>中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员<code>m</code>，定义来一个符号来解析<code>U</code>中的一个引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到<code>U</code>和<code>D</code>都不发生变化。任何不包含在E中的成员目标文件都被简单的丢弃，链接器将继续处理下一个输入文件。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.15.png"></p></li><li><p>当链接器完成对命令行上输入文件的扫描后，<code>U</code>是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位<code>E</code>中的目标文件，构建输出的可执行文件。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.16.png"></p></li></ul><p>如果一个定义的符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。</p><h2 id="7-7-重定位"><a href="#7-7-重定位" class="headerlink" title="7.7 重定位"></a>7.7 重定位</h2><p>完成符号解析后，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。就可以开始重定位，将合并输入模块，并未每个符号分配运行时地址。重定位分为两步。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.17.png"></p><ul><li><p>重定位节和符号定义<br>这一步链接器将所有相同类型的节合并为同一类型的新聚合节。所有输入的<code>.data</code>合并为可执行目标文件的<code>.data</code>，然后将运行时内存地址赋给新的聚合节，当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.18.png"></p></li><li><p>重定位节中的符号引用<br>这一步，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为<code>重定位条目</code>的数据结构。</p></li></ul><h3 id="7-7-1-重定位条目"><a href="#7-7-1-重定位条目" class="headerlink" title="7.7.1 重定位条目"></a>7.7.1 重定位条目</h3><p>代码的重定位条目放在<code>.rel.test</code>中初始化数据的重定位条目放在<code>.rel.data</code>中。</p><h3 id="7-7-2-重定位符号引用"><a href="#7-7-2-重定位符号引用" class="headerlink" title="7.7.2 重定位符号引用"></a>7.7.2 重定位符号引用</h3><ul><li>重定位绝对引用</li></ul><h2 id="7-8-可执行目标文件"><a href="#7-8-可执行目标文件" class="headerlink" title="7.8 可执行目标文件"></a>7.8 可执行目标文件</h2><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.19.png"></p><p>程序入口点：当程序运行时要执行第一条指令的地址。</p><p>.init节定义了一个函数_init，程序的初始化代码会调用它，因为可执行文件时完全链接的，所以不需要rel节。</p><p>Elf 被设计的很容易加载到内存，可执行文件的连续片被映射到了内存段。程序头部表描述了这种映射关系。</p><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.20.png"></p><p>能看到根据可执行目标文件初始化两个内存段。第一行和第二行告诉我们代码段有读&#x2F;执行访问权限，开始于内存地址 0x400000 处，总共内存大小是 0x69c字节。其中包含ELF头，程序头部表以及 .init、.text和.rodata节。</p><p>第三行和第四行告诉我数据段有读&#x2F;写访问权限，开始于内存地址 0x600df8处，在文件中占用大小为0x228，内存中占用大小为0x230字节，用来存放.bss section，并用从目标文件中转移的0xdf8处开始的。</p><p>对于任何一个段，链接器必须选择一个起始地址使得</p><div class="code-wrapper"><pre><code class="hljs vbnet">vaddr <span class="hljs-built_in">mod</span> align = <span class="hljs-keyword">off</span> <span class="hljs-built_in">mod</span> align</code></pre></div><p>off 表示段在可执行文件中相对于起始位置的偏移量，align是程序头部表中指定的对其量。</p><h2 id="7-9-加载可执行目标文件"><a href="#7-9-加载可执行目标文件" class="headerlink" title="7.9 加载可执行目标文件"></a>7.9 加载可执行目标文件</h2><ul><li>加载<br>运行程序时，linux会调用加载器调用程序，接下来加载器将可执行文件中的代码和数据从磁盘复制到内存中，然后跳转到程序的入口点运行该程序。</li></ul><p>每个Linux程序都有一个运行时内存映像</p><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.21.png"></p><p>在Linux 64 中代码段总是从地址 0x400000 处开始。之后是数据段。运行时堆在数据段之后，通过调用malloc库往上增长（低地址到高地址）。堆后面的区域是为了共享模块保留的，隔开了堆和栈。用户栈总是从最大合法用户地址（2^48-1）开始，向较小内存地址增长（高地址到低地址）。</p><p>再往上是内核空间从2^48开始，这部分对用户不可见，每次运行时这些地址都会改变，但是相对位置不变。</p><p>加载器运行时，加载器跳转到程序的入口点，也就是 _start 函数的地址，这个函数是在系统目标文件ctrl.o中定义的，对所有c程序都一样， _start函数调用系统启动函数  _libc_start_main，该函数定义在libc.so中，它初始化执行环境，之后调用用户层的main函数，执行完成后返回值还是交给 _libc_start_main，之后将控制器还给内核。</p><p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.22.png"></p><h2 id="7-10-动态链接共享库"><a href="#7-10-动态链接共享库" class="headerlink" title="7.10 动态链接共享库"></a>7.10 动态链接共享库</h2><p>特殊的可重定位目标文件，后缀 .so，可以被加载在任何位置，通过动态链接器链接起来。</p><p>使用<code>gcc -shared -fpic -o libvector.so addvec.c mulvec.c</code> 创建一个共享目标文件，<br>使用<code>gcc -o prog2 main.c ./libvector.so</code> 创建一个可执行文件。</p><p>链接器会复制一些重定位和符号表信息，它们使得运行时可以解析对 libvector.so 中代码和数据的引用。<br>当加载器加载和运行时，prog2包含一个.interp 节，这一节包含动态链接器的路径名，动态链接器是一个共享目标，在linux上是（ld-linux.so）。</p><p>加载器接下来不是传递控制给应用，而是加载和运行这个动态链接器，然后动态链接器通过下面的重定位完成任务。</p><ul><li>重定位 libc.so 的文本和数据到某一个内存段</li><li>重定位libvector.so的文本和数据到另一个内存段</li><li>重定位 prog21 中所有对由 libc.so 和 libvector.so 定义的符号引用。</li></ul><p>最后动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7.23.png"></p><h2 id="7-11-从应用程序中加载和链接共享库"><a href="#7-11-从应用程序中加载和链接共享库" class="headerlink" title="7.11 从应用程序中加载和链接共享库"></a>7.11 从应用程序中加载和链接共享库</h2><p>运行时要求动态链接器加载和链接某个共享库，无需在编译时将那些库链接到应用中。</p><ul><li>分发软件：通过共享库来分发软件更新，下一次自动链接和加载新的数据库</li><li>构建高性能Web服务器：将每个生成动态内容的函数打包在共享库中，当一个请求到达时Web服务器动态链接加载适当的函数，直接进行调用。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/12/29/hello-world/"/>
    <url>/2024/12/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
