

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="BoBoDai">
  <meta name="keywords" content="">
  
    <meta name="description" content="讲述了协作式多任务 和 Rust 的 async&#x2F;await 功能。将详细展示 Rust 中的 async&#x2F;await 是如何工作的， 包括 Future trait 的设计、状态机转换和 pinning。 然后，我们通过创建一个异步键盘任务和一个基本的执行器，为我们内核添加了对 async&#x2F;await 的基本支持。">
<meta property="og:type" content="article">
<meta property="og:title" content="Write-an-OS-in-Rust">
<meta property="og:url" content="http://example.com/2025/06/16/OS/%E8%AF%BBWrite-an-OS-in-Rust/index.html">
<meta property="og:site_name" content="Cactus Hole">
<meta property="og:description" content="讲述了协作式多任务 和 Rust 的 async&#x2F;await 功能。将详细展示 Rust 中的 async&#x2F;await 是如何工作的， 包括 Future trait 的设计、状态机转换和 pinning。 然后，我们通过创建一个异步键盘任务和一个基本的执行器，为我们内核添加了对 async&#x2F;await 的基本支持。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_1.png">
<meta property="og:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_2.png">
<meta property="og:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_3.png">
<meta property="og:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_4.png">
<meta property="article:published_time" content="2025-06-16T03:56:35.000Z">
<meta property="article:modified_time" content="2025-06-18T07:43:33.221Z">
<meta property="article:author" content="BoBoDai">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_1.png">
  
  
  
  <title>Write-an-OS-in-Rust - Cactus Hole</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>BoBoBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Write-an-OS-in-Rust"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-16 11:56" pubdate>
          June 16, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          42 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Write-an-OS-in-Rust</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="1-多任务"><a href="#1-多任务" class="headerlink" title="1. 多任务"></a>1. 多任务</h2><p>大多数操作系统的基本特性就是多任务，它同时执行多个任务。<br>实际上一个CPU核心一次只能执行一个任务，操作系统快速的在活动任务之间切换，这样实现了并发。<br>多核CPU能够真正的执行多任务，8核的CPU可以同时执行8个任务，实现了并行。</p>
<p>多任务有两种形式</p>
<ul>
<li>协作式多任务：要求任务定期放弃对CPU的控制，以便其他任务可以取得进展。</li>
<li>抢占式多任务：使用操作系统功能在任意时间点强制暂停线程来切换线程。</li>
</ul>
<h3 id="1-1-协作式多任务"><a href="#1-1-协作式多任务" class="headerlink" title="1.1. 协作式多任务"></a>1.1. 协作式多任务</h3><p>协作式多任务让每个任务运行到自愿放弃对CPU的控制，而不是在任意时间点强制暂停运行的任务，这使得任务可以在方便的时间点暂停自己，例如，需要等待IO操作时。</p>
<p>协作式多任务通常用于语言级别，比如协程或async&#x2F;await的形式。其思想上程序员或编译器在程序中插入yield操作，这样可以放弃对CPU的控制，让其他任务运行。</p>
<p>通常协作式多任务与异步操作结合在一起，当一个操作还没有完成，它不会阻止其他任务运行，而是返回一个未就绪的状态。 在这种情况下，等待的任务可以执行一个yield操作，让其他任务运行。</p>
<h4 id="1-1-1-状态保存"><a href="#1-1-1-状态保存" class="headerlink" title="1.1.1. 状态保存"></a>1.1.1. 状态保存</h4><p>既然任务自己定义了暂停点，他们不需要操作系统保存它们的状态。反之，它们可以在暂停自己之前保存他们需要的状态，这通常会带来更好的性能。比如一个刚完成了复杂计算的任务可能只需要备份计算的最终结果，因为它不再需要中间结果。</p>
<p>协作式多任务的语言级实现通常甚至能够在暂停之前备份调用栈的必要部分。例如，Rust的async&#x2F;await实现会在暂停之前备份所有仍然需要的本地变量到一个自动生成的结构体中。 通过在暂停之前备份调中栈的相关部分，所有任务都可以共享一个调用栈，这导致每个任务的内存消耗大大降低。这使得可以创建几乎任意数量的协作式任务不会耗尽内存。</p>
<h4 id="1-1-2-讨论"><a href="#1-1-2-讨论" class="headerlink" title="1.1.2. 讨论"></a>1.1.2. 讨论</h4><p>协作式多任务的缺点是一个不合作的任务可能运行无限长的时间。因此，一个恶意或有缺陷的任务可能会阻止其他任务运行，从而减慢甚至阻塞整个系统。因此，只有当所有的任务都知道合作时，协作式多任务才应该使用。让操作系统依赖于任务用户级程序的合作是不明智的。</p>
<p>然而，协作式多任务的强大性能和内存优势使得它成为程序内部使用的一个好方法，特别是与异步操作系统结合使用。由于操作系统内核是一个与异步硬件交互和性能关键型程序，协作式多任务似乎是一个实现并发性的一个好办法。</p>
<h3 id="1-2-抢占式多任务"><a href="#1-2-抢占式多任务" class="headerlink" title="1.2. 抢占式多任务"></a>1.2. 抢占式多任务</h3><p>抢占式多任务的思想是操作系统控制何时切换任务，它利用了操作系统在每次中断时重新获得对CPU的控制， 这使得在系统有新的输入时可以进行任务切换。操作系统还可以通过配置硬件计时器在一段时间后发送中断来确定任务允许运行的确切时间。</p>
<p>下图是硬件中断时的任务切换过程</p>
<p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_1.png" srcset="/img/loading.gif" lazyload alt="rust_os_1"></p>
<p>第一行中，CPU正在执行程序A的任务A1所有其他任务都被暂停了。在第二行中，硬件中断到达了CPU。<br>正如在<a target="_blank" rel="noopener" href="https://os.phil-opp.com/hardware-interrupts/">硬件中断</a>中描述的那样,CPU立即停止了任务A1的执行。并跳转到中断描述表（IDT）<br>中定义的中断处理程序。通过这个中断处理程序，操作系统现在再次控制了CPU，之后切换到任务B1。</p>
<h4 id="1-2-1-状态保存"><a href="#1-2-1-状态保存" class="headerlink" title="1.2.1. 状态保存"></a>1.2.1. 状态保存</h4><p>任务在任意时间点被中断，可能在一些计算的中间，未来能够稍后恢复他们，操作系统必须备份整个状态，包括调用栈，和所有CPU寄存器的值，也叫上下文切换。</p>
<p>由于调用栈可能非常大，操作系统通常为每一个任务设置一个单独的调用栈，而不是在每次任务切换时备份调用栈内容。这种有自己的栈被称为执行线程也叫线程。 通过为每个任务使用单独的栈，只需要在上下文切换时保存寄存器内容。</p>
<h4 id="1-2-2-讨论"><a href="#1-2-2-讨论" class="headerlink" title="1.2.2. 讨论"></a>1.2.2. 讨论</h4><p>抢占式多任务主要的好处是操作系统可以完全控制任务的允许执行时间。这样，它可以保证每个任务都能公平的获得CPU的时间，不需要信任任务合作。</p>
<p>抢占式多任务的缺点是每个任务都需要自己的栈，和共享栈相比，导致每个任务的内存使用量更高，而且通常限制了系统中的任务数量。 另一个缺点是操作系统总是需要在每次任务切换时保存完整的CPU寄存器状态，即使任务只使用量寄存器的一小部分。</p>
<p>抢占式多任务和线程是操作系统的基本组件，因为他们使得运行不受信任的用户空间程序称为可能。本文将专注于协作式多任务。</p>
<h2 id="2-Async-Await-in-Rust"><a href="#2-Async-Await-in-Rust" class="headerlink" title="2. Async&#x2F;Await in Rust"></a>2. Async&#x2F;Await in Rust</h2><p>Rust语言提供了对多任务的第一级别支持，这种支持以async&#x2F;await的形式呈现。</p>
<h3 id="2-1-Futures"><a href="#2-1-Futures" class="headerlink" title="2.1. Futures"></a>2.1. Futures</h3><p>一个Future代表一个可能还没有可用的值。这可能是，例如，由另一个任务计算或从网络下载的文件。与等待值可用不同，future使得可以继续执行直到需要值。</p>
<h4 id="2-1-1-例子"><a href="#2-1-1-例子" class="headerlink" title="2.1.1. 例子"></a>2.1.1. 例子</h4><p>future的概念</p>
<p><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_2.png" srcset="/img/loading.gif" lazyload alt="rust_os_2"></p>
<p>这个序列图展示了一个<code>main</code>函数，它从文件系统读取文件，然后调用一个<code>foo</code>函数，这个过程重复了两次：</p>
<ul>
<li>一次同步的<code>read_file</code>调用</li>
<li>一次是异步的<code>async_read_file</code>调用</li>
</ul>
<p>使用异步<code>async_read_file</code>调用，文件系统直接返回一个future，并在后台异步加载文件。这使得<code>main</code>函数可以更早的调用<code>foo</code>，这样它可以与文件加载并行运行。这个例子中，文件加载在<code>foo</code>返回之前完成了，所以<code>main</code>可以在<code>foo</code>返回后直接使用文件而不需要进一步等待。</p>
<h4 id="2-1-2-Future-in-Rust"><a href="#2-1-2-Future-in-Rust" class="headerlink" title="2.1.2. Future in Rust"></a>2.1.2. Future in Rust</h4><p>在Rust中，futures由<code>Future</code>trait表示，它看起来像这样：</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Future</span> &#123;
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt;;
&#125;</code></pre></div>
<p>其中</p>
<ul>
<li>Output指定了异步值的类型，例如，上面的示例中<code>async_read_file</code>函数将返回一个<code>Output</code>设置为<code>File</code>的<code>Future</code>实例。</li>
<li>poll方法允许检查值是否已经可用。它返回一个<code>Poll</code>枚举，看起来这样。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Poll</span>&lt;T&gt; &#123;
    <span class="hljs-title function_ invoke__">Ready</span>(T),
    Pending,
&#125;</code></pre></div>

<p>当那个值已经可用（例如，文件已经读取完毕）。它被包装在<code>Ready</code>变体中返回。否则，返回<code>Penging</code>变体，这通知调用者该值尚不可用。</p>
<p>方法 <code>poll</code> 接受兩個參數：<code>self: Pin&lt;&amp;mut Self&gt;</code> 和 <code>cx: &amp;mut Context</code>。前者的行為與普通的 <code>&amp;mut self</code> 引用類似，只是 Self 值被 釘住 pinned 在它的內存位置。</p>
<p>参数<code>cx: &amp;mut Context</code>的目的是將一個 喚醒器 <code>Waker</code> 實例傳遞給異步任務，例如文件系統加載。 這個 <code>Waker</code> 允許異步任務發出信號，表明它已经完成。主任务知道当<code>Future</code>可用时它将被通知，所以它不需要一遍又一遍的调用<code>poll</code>。</p>
<h3 id="2-2-和Futures一起工作"><a href="#2-2-和Futures一起工作" class="headerlink" title="2.2. 和Futures一起工作"></a>2.2. 和Futures一起工作</h3><p>Futures 代表了异步任务的结果，这些结果可能还不可用。然而，在实践中，我们经常需要这些值來进行进一步的计算。 所以问题是：当我们需要时，我们如何有效地获取 future 的值？</p>
<h4 id="2-2-1-Waiting-on-Futures"><a href="#2-2-1-Waiting-on-Futures" class="headerlink" title="2.2.1. Waiting on Futures"></a>2.2.1. Waiting on Futures</h4><p>一个答案是等待直到future变得可用。这看起来像这样</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>);
<span class="hljs-keyword">let</span> <span class="hljs-variable">file_content</span> = <span class="hljs-keyword">loop</span> &#123;
    <span class="hljs-keyword">match</span> future.<span class="hljs-title function_ invoke__">poll</span>(…) &#123;
        Poll::<span class="hljs-title function_ invoke__">Ready</span>(value) =&gt; <span class="hljs-keyword">break</span> value,
        Poll::Pending =&gt; &#123;&#125;, <span class="hljs-comment">// do nothing</span>
    &#125;
&#125;</code></pre></div>
<p>上述代码主动等待future，通过在一个循环中调用<code>poll</code>。这个<code>poll</code>的参数不重要。这个方案非常低效，因为我们一直占用CPU直到值变的可用。</p>
<p>更有效的方法可能是阻塞当前线程直到future变的可用。这种只有在线程作用下才可能，所以这个方法对内核无效。</p>
<h4 id="2-2-2-Future组合器"><a href="#2-2-2-Future组合器" class="headerlink" title="2.2.2. Future组合器"></a>2.2.2. Future组合器</h4><p>一个等待的替代方案是使用future组合器。Future组合器是像<code>map</code>这样的方法，它允许将future链接和组合在一起，类似于<code>Iterator</code>trait的方法。于等待future不同，这些组合器返回一个future，他们自己应用<code>poll</code>上的映射操作。</p>
<p>例子，一个简单的<code>string_len</code>组合器，它将<code>Future&lt;Output = String&gt;</code>转换成<code>Future&lt;Output = usize&gt;</code>可能看起来像这样。</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StringLen</span>&lt;F&gt; &#123;
    inner_future: F,
&#125;

<span class="hljs-keyword">impl</span>&lt;F&gt; Future <span class="hljs-keyword">for</span> <span class="hljs-title class_">StringLen</span>&lt;F&gt; <span class="hljs-keyword">where</span> F: Future&lt;Output = <span class="hljs-type">String</span>&gt; &#123;
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = <span class="hljs-type">usize</span>;
    
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> Poll&lt;T&gt; &#123;
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.inner_future.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;
            Poll::<span class="hljs-title function_ invoke__">Ready</span>(S) =&gt; Poll::<span class="hljs-title function_ invoke__">Ready</span>(s.<span class="hljs-title function_ invoke__">len</span>()),
            Poll::Pending =&gt; Poll::Pending,
        &#125;
    &#125;
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">string_len</span>(string: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">String</span>&gt;)
    <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">usize</span>&gt;
&#123;
    StringLen &#123;
        inner_future: string,
    &#125;
&#125;

<span class="hljs-comment">//Usage</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">file_len</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">usize</span>&gt; &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">file_content_future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>);
    <span class="hljs-title function_ invoke__">string_len</span>(file_content_future)
&#125;</code></pre></div>
<p>上面的例子，的基本思想是<code>string_len</code>函数将给定的<code>Future</code>实例包装到一个新的<code>StringLen</code>结构体中，它也体现了<code>Future</code>。当包装的future被调用时，它调用内部的future。如果值还不可用，从包装的future也返回<code>Poll::Pending</code>。如果值已可用。则从<code>Poll::Ready</code>变体中提取字符串并计算它的长度。然后，它再次包装在<code>Poll::Ready</code>中并返回。</p>
<p>用这个<code>string_len</code>函数，我们可以计算一个异步字符串的长度而不需要等待它。由于函数再次返回一个<code>Future</code>，调用者不能直接在返回的值上工作，但需要再次使用组合器函数。这样，整个调用图变成了异步的，我们柯宇在某个时候有效的等待多个futures，例如，在<code>main</code>函数中。</p>
<p>因为手工编写组合器函数是很困难的，他们通常由库提供。虽然Rust标准库本身含没有提供组合器方法，但是半官方的<code>futures</code>库提供了。它的<code>FutureExt</code>trait提供了高级组合器方法，比如<code>map</code>或<code>then</code>，它们可以用来使用任意的闭包来操作结果。</p>
<h4 id="2-2-3-优势"><a href="#2-2-3-优势" class="headerlink" title="2.2.3. 优势"></a>2.2.3. 优势</h4><p>Future组合器的一个巨大优势是它们保存来操作的异步性。与异步I&#x2F;O接口结合使用，这种方法可以带来非常高的性能。Future组合器作为具有trait实现的普通结构体，使得编辑器可以对他们进行极限优化。更多可以参考<a target="_blank" rel="noopener" href="https://aturon.github.io/blog/2016/08/11/futures/">Zero-cost futures in Rust</a>。</p>
<h4 id="2-2-4-缺点"><a href="#2-2-4-缺点" class="headerlink" title="2.2.4. 缺点"></a>2.2.4. 缺点</h4><p>当future组合器使得编写非常高效的代码成为可能，但它在一些情况下很难使用，这是因为类型系统和基于闭包的接口。例如下面的代码</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">String</span>&gt; &#123;
    <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>).<span class="hljs-title function_ invoke__">then</span>(<span class="hljs-keyword">move</span> |content| &#123;
        <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; min_len &#123;
            Either::<span class="hljs-title function_ invoke__">Left</span>(<span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;bar.txt&quot;</span>).<span class="hljs-title function_ invoke__">map</span>(|s| content + &amp;s))
        &#125; <span class="hljs-keyword">else</span> &#123;
            Either::<span class="hljs-title function_ invoke__">Right</span>(future::<span class="hljs-title function_ invoke__">ready</span>(content))
        &#125;
    &#125;)
&#125;</code></pre></div>

<p>这里先是读取文件<code>foo.txt</code>,然后使用<code>then</code>组合器来链接基于文件内容的第二个future。如果内容的长度小于给定的<code>min_len</code>，我们读取一个不同的<code>bar.txt</code>文件并使用<code>map</code>组合器将它加到<code>context</code>上。否则返回<code>foo.txt的内容</code>。</p>
<p>我们需要使用<code>move</code>关键字来修复传递给<code>then</code>的闭包，因为否则<code>min_len</code>将会有一个声明周期错误。我们需要使用<code>Either</code>包装器，因为<code>if</code>和<code>else</code>块必须总是有相同的类型。由于我们在块中返回不同的future类型，我们必须使用包装器类型将它们统一到一个模型中。<code>ready</code>函数将一个值包装到一个future中，这个future立即就绪。这个函数在这里是必须的，因为Either包装器期望被包装的值实现了<code>Future</code></p>
<p>这能很快的导致对于大型项目来说非常复杂的代码。如果设计借用和不同的生命周期，它会变的特别复杂。因此，Rust在添加对async&#x2F;await的支持时投入了大量工作，使编写异步代码变的简单。</p>
<h3 id="2-3-The-Async-Await-Pattern"><a href="#2-3-The-Async-Await-Pattern" class="headerlink" title="2.3. The Async&#x2F;Await Pattern"></a>2.3. The Async&#x2F;Await Pattern</h3><p>使用<code>await</code>和<code>async</code>关键字可以将一个同步函数转换为一个返回future的异步函数</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;
    <span class="hljs-number">0</span>
&#125;

<span class="hljs-comment">// the above is roughly translated by the compiler to:</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">u32</span>&gt; &#123;
    future::<span class="hljs-title function_ invoke__">ready</span>(<span class="hljs-number">0</span>)
&#125;</code></pre></div>
<p>这个关键字单独使用不是很有用。在<code>async</code>函数内部，<code>await</code>关键字可以用来获取future的异步值：</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span>;
    <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; min_len&#123;
        content + &amp; <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span>
    &#125; <span class="hljs-keyword">else</span> &#123;
        content
    &#125;
&#125;</code></pre></div>
<p>这个函数使用了组合函数。使用.await运算符，可以获取future的值而不需要任何闭包或<code>Either</code>类型。因此，我们柯宇像写同步代码一样写异步代码。</p>
<h4 id="2-3-1-状态机转换"><a href="#2-3-1-状态机转换" class="headerlink" title="2.3.1. 状态机转换"></a>2.3.1. 状态机转换</h4><p>后面，编译器将<code>async</code>函数体转换成一状态机，其中每个<code>.await</code>调用代表一个不同的状态。对于上面的<code>example</code>函数，编译器创建了一个具有以下四个状态的状态机。<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_3.png" srcset="/img/loading.gif" lazyload alt="rust_os_3"><br>每个状态都是不同的暂停点。</p>
<ul>
<li>“Start”和“End”代表了函数在执行的开始和结束。</li>
<li>“Waiting on foo.txt”状态代表了函数当前正在等待第一个<code>async_read_file</code>的结果。</li>
<li>同样的，“Waiting on bar.txt”状态代表了函数正在等待第二个<code>async_read_file</code>的结果暂停点。</li>
</ul>
<p>状态机通过使每个<code>poll</code>调用成为一个可能的状态转换来实现<code>Future</code>trait：<br><img src="/2025/01/06/csapp/CSAPP%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/_os_4.png" srcset="/img/loading.gif" lazyload alt="rust_os_4"><br>第一个<code>poll</code>调用启动了函数并让它运行直到它达到一个还未准备好的future。如果所有future都准备好了，函数可以运行到“End”状态，并在<code>Poll::Ready</code>中返回它的结果。否则，状态机进入等待状态并返回<code>Poll::Pending</code>。在下一个<code>poll</code>调用中，状态机从最后一个等待的状态开始，并重试最后一个操作。</p>
<h4 id="2-3-2-保存状态"><a href="#2-3-2-保存状态" class="headerlink" title="2.3.2. 保存状态"></a>2.3.2. 保存状态</h4><p>为了能从上一个等待状态继续，状态机必须在内部保存当前状态。此外，它必须保存所有需要在下一个<code>poll</code>调用中继续执行的变量。编译器知道那些变量何时使用，他可以自动生成具有确切所需变量的结构体。</p>
<p>编译器为上面的<code>example</code>函数生成下面这种结构体</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span>;
    <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; min_len &#123;
        content + &amp;<span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;.txt&quot;</span>).<span class="hljs-keyword">await</span>
    &#125; <span class="hljs-keyword">else</span> &#123;
        content
    &#125;
&#125;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">StartState</span> &#123;
    min_len: <span class="hljs-type">usize</span>,
&#125;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">WaitingOnFooTxtState</span> &#123;
    min_len: <span class="hljs-type">usize</span>,
    foo_txt_future: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Outtput = <span class="hljs-type">String</span>&gt;,
&#125;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">WaitingOnBarTxState</span> &#123;
    context: <span class="hljs-type">String</span>,
    bar_txt_future: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span>&lt;Output = <span class="hljs-type">String</span>&gt;
&#125;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">EndState</span> &#123;&#125;</code></pre></div>
<ul>
<li>在”start”和”Waiting on foo.txt”状态中，<code>min_len</code>参数需要被保存以便于<code>content.len()</code>进行后续比较。</li>
<li>“Waiting on foo.txt”状态另外保存来一个<code>foo_txt_future</code>，它代表了<code>async_read_file</code>调用返回的future。当转改继续运行时，这个future需要被再次调用，所以它被保存。</li>
</ul>
<p>“Waiting on bar.txt”状态包含了<code>content</code>变量，以便在<code>bar.txt</code>可用时进行字符串拼接。它还保存来一个<code>bar_txt_future</code>，它代表了<code>bar.txt</code>的异步加载过程。这个结构体不包含<code>min_len</code>变量，因为在<code>content.len()</code>比较之后它不再需要了。在“end”状态中不保存任何变量，因为函数已经结束。</p>
<h4 id="2-3-3-完整的状态机模型"><a href="#2-3-3-完整的状态机模型" class="headerlink" title="2.3.3. 完整的状态机模型"></a>2.3.3. 完整的状态机模型</h4><p>我们可以将状态组合成一个<code>enum</code></p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ExampleStateMachine</span>&#123;
    <span class="hljs-title function_ invoke__">Start</span>(StartState),
    <span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(WaitingOnFooTxtState),
    <span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(WaitingOnBarTxtState),
    <span class="hljs-title function_ invoke__">End</span>(EndState),
&#125;</code></pre></div>
<p>我们定义了一个独立的枚举来表示每个状态，并将相应的状态结构体作为每个变体的字段添加到其中。未来实现状态转换，编译器基于<code>example</code>函数生成了<code>Future</code>trait到实现：</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">ExampleStateMachine</span> &#123;
    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = <span class="hljs-type">String</span>;

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context) <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt; &#123;
        <span class="hljs-keyword">loop</span> &#123;
            <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> &#123;
                ExampleStateMachine::<span class="hljs-title function_ invoke__">Start</span>(state) =&gt; &#123;…&#125;
                ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(state) =&gt; &#123;…&#125;
                ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(state) =&gt; &#123;…&#125;
                ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(state) =&gt; &#123;…&#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>
<p>该future的<code>Output</code>类型是<code>String</code>，因为它是<code>example</code>函数的返回类型。为了实现<code>poll</code>函数，我们在一个<code>loop</code>中使用<code>match</code>语句对当前状态进行分支。我们的想法是只要可能就切换到下一个状态，并在无法继续时显示的<code>return Poll::Pending</code>。</p>
<ul>
<li><code>Start</code>状态</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">Start</span>(state) =&gt; &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">foo_txt_future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">state</span> = WaitingOnFooTxtState &#123;
        min_len: state.min_len,
        foo_txt_future,
    &#125;;
    *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(state);
&#125;</code></pre></div>
<p>状态机在函数处于<code>Start</code>状态。在这个情况下，执行所有代码直到第一个<code>.await</code>。为了处理<code>.await</code>操作，我们将状态机<code>self</code>的状态更改为<code>WaitingOnFooTxt</code>，这包括了<code>WaitingOnFooTxtState</code>结构体的构造。</p>
<p>因为<code>match self &#123;...&#125;</code>语句在一个循环中执行，所以执行直接跳到<code>WaitingOnFooTxt</code>分支：</p>
<ul>
<li>“WaitingOnFooTxt”的状态</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnFooTxt</span>(state) =&gt; &#123;
    <span class="hljs-keyword">match</span> state.foo_txt_future.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;
        Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,
        Poll::<span class="hljs-title function_ invoke__">Ready</span>(content) =&gt; &#123;
            <span class="hljs-comment">// from body of `example`</span>
            <span class="hljs-keyword">if</span> content.<span class="hljs-title function_ invoke__">len</span>() &lt; state.min_len &#123;
                <span class="hljs-keyword">let</span> <span class="hljs-variable">bar_txt_future</span> = <span class="hljs-title function_ invoke__">async_read_file</span>(<span class="hljs-string">&quot;bar.txt&quot;</span>);
                <span class="hljs-comment">// `.await` operation</span>
                <span class="hljs-keyword">let</span> <span class="hljs-variable">state</span> = WaitingOnBarTxtState &#123;
                    content,
                    bar_txt_future,
                &#125;;
                *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(state);
            &#125; <span class="hljs-keyword">else</span> &#123;
                *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(EndState);
                <span class="hljs-keyword">return</span> Poll::<span class="hljs-title function_ invoke__">Ready</span>(content);
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>
<p>这个<code>match</code>分支中，先调用<code>foo_txt_future</code>的<code>poll</code>函数。如果还没准备好，我们退出循环并返回<code>Poll::Pending</code>。由于这种情况下<code>self</code>保持在<code>WaitingOnFooTxt</code>状态，下一个<code>poll</code>调用将进入相同的<code>match</code>分支并重试<code>foo_txt_future</code>的轮询。</p>
<p>当<code>foo_txt_future</code>准备好时，我们将结果分配给<code>content</code>变量并继续执行<code>example</code>函数的代码：如果<code>content.len()</code>小于状态结构体中保存的<code>min_len</code>，我们异步读取<code>bar.txt</code>文件。我们再次将<code>.await</code>操作转换成一个状态变化，这次是到<code>WaitingOnBarTxt</code>状态。由于我们在一个循环中执行<code>match</code>，所以执行直接跳到新状态的<code>match</code>分支，并轮询<code>bar_txt_future</code>。</p>
<p>如果我们进入<code>else</code>分支，则不会进行下一步的<code>.await</code>操作，我们达到函数的结尾并将<code>content</code>包装在<code>Poll::ready</code>中返回。我们还将当前的状态更改为<code>End</code>状态。</p>
<ul>
<li>“WaitingOnBarTxt”的状态</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">WaitingOnBarTxt</span>(state) =&gt; &#123;
    <span class="hljs-keyword">match</span> state.bar_txt_future.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;
        Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,
        Poll::<span class="hljs-title function_ invoke__">Ready</span>(bar_txt) =&gt; &#123;
            *<span class="hljs-keyword">self</span> = ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(EndState);
            <span class="hljs-comment">// from body of `example`</span>
            <span class="hljs-keyword">return</span> Poll::<span class="hljs-title function_ invoke__">Ready</span>(state.content + &amp;bar_txt);
        &#125;
    &#125;
&#125;</code></pre></div>

<p>我们先轮询<code>bar_txt_future</code>。如果它还没有准备好，我们推出循环并返回<code>Poll::Pending</code>。反之，我们可以执行<code>example</code>函数的最后一个操作:将<code>content</code>变量与future的结果链接起来。我们将状态机更改为<code>End</code>并在<code>Poll::Ready</code>中返回结果。</p>
<ul>
<li>最后，<code>End</code>状态的代码如下</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs rust">ExampleStateMachine::<span class="hljs-title function_ invoke__">End</span>(_) =&gt; &#123;
<span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;poll called after Poll::Ready was returned&quot;</span>);
&#125;</code></pre></div>
<p>Future在返回<code>Poll::Ready</code>后不应该再被轮询，所以在<code>End</code>状态下调用<code>poll</code>，会panic。</p>
<p>因为完整的函数体，在状态机实现，函数为宜需要做的事情是初始化状态机并返回它。生成的代码是这样</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">example</span>(min_len: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> ExampleStateMachine &#123;
    ExampleStateMachine::<span class="hljs-title function_ invoke__">Start</span>(StartState &#123;
        min_len,
    &#125;)
&#125;</code></pre></div>
<p>这个函数没有<code>async</code>，因为它明确的返回了一个实现了<code>Future</code>trait的<code>ExampleStateMachine</code>类型。状态机在<code>Start</code>状态中构造，相应的状态结果体被初始化为<code>min_len</code>参数。</p>
<h3 id="2-4-Pinning"><a href="#2-4-Pinning" class="headerlink" title="2.4. Pinning"></a>2.4. Pinning</h3><h4 id="2-4-1-Self-Referential-Structs"><a href="#2-4-1-Self-Referential-Structs" class="headerlink" title="2.4.1. Self-Referential Structs"></a>2.4.1. Self-Referential Structs</h4><h4 id="2-4-2-自引用結構體的問題"><a href="#2-4-2-自引用結構體的問題" class="headerlink" title="2.4.2. 自引用結構體的問題"></a>2.4.2. 自引用結構體的問題</h4><h4 id="2-4-3-可能的解決方案"><a href="#2-4-3-可能的解決方案" class="headerlink" title="2.4.3. 可能的解決方案"></a>2.4.3. 可能的解決方案</h4><h4 id="2-4-4-堆上之數值"><a href="#2-4-4-堆上之數值" class="headerlink" title="2.4.4. 堆上之數值"></a>2.4.4. 堆上之數值</h4><h4 id="2-4-5-栈上钉住-Pin"><a href="#2-4-5-栈上钉住-Pin" class="headerlink" title="2.4.5. 栈上钉住 Pin&lt;&amp;mut T&gt;"></a>2.4.5. 栈上钉住 Pin&lt;&amp;mut T&gt;</h4><h4 id="2-4-6-钉住操作和-Futures"><a href="#2-4-6-钉住操作和-Futures" class="headerlink" title="2.4.6. 钉住操作和 Futures"></a>2.4.6. 钉住操作和 Futures</h4><h3 id="2-5-执行器和唤醒器"><a href="#2-5-执行器和唤醒器" class="headerlink" title="2.5. 执行器和唤醒器"></a>2.5. 执行器和唤醒器</h3><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Rust/" class="print-no-link">#Rust</a>
      
        <a href="/tags/OS/" class="print-no-link">#OS</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Write-an-OS-in-Rust</div>
      <div>http://example.com/2025/06/16/OS/读Write-an-OS-in-Rust/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>BoBoDai</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 16, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/06/15/RUST%E9%97%B2%E8%B0%88%E6%9D%82%E8%AE%B0/RUST%E5%AE%8F/" title="RUST宏">
                        <span class="hidden-mobile">RUST宏</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
