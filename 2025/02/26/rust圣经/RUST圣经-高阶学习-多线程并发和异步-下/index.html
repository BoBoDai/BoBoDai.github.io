

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="BoBoDai">
  <meta name="keywords" content="">
  
    <meta name="description" content="4 线程同步：锁、Condvar 和信号量在多线程编程中，同步性极其的重要，当你需要同时访问一个资源、控制不同线程的执行次序时，都需要使用到同步性。 在 Rust 中有多种方式可以实现同步性。在上一节中讲到的消息传递就是同步性的一种实现方式，例如我们可以通过消息传递来控制不同线程间的执行次序。还可以使用共享内存来实现同步性，例如通过锁和原子操作等并发原语来实现多个线程同时且安全地去访问一个资源。">
<meta property="og:type" content="article">
<meta property="og:title" content="RUST圣经-高阶学习-多线程并发和异步-下">
<meta property="og:url" content="http://example.com/2025/02/26/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5-%E4%B8%8B/index.html">
<meta property="og:site_name" content="Cactus Hole">
<meta property="og:description" content="4 线程同步：锁、Condvar 和信号量在多线程编程中，同步性极其的重要，当你需要同时访问一个资源、控制不同线程的执行次序时，都需要使用到同步性。 在 Rust 中有多种方式可以实现同步性。在上一节中讲到的消息传递就是同步性的一种实现方式，例如我们可以通过消息传递来控制不同线程间的执行次序。还可以使用共享内存来实现同步性，例如通过锁和原子操作等并发原语来实现多个线程同时且安全地去访问一个资源。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-02-26T05:36:49.000Z">
<meta property="article:modified_time" content="2025-03-01T01:45:49.867Z">
<meta property="article:author" content="BoBoDai">
<meta property="article:tag" content="rust圣经">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>RUST圣经-高阶学习-多线程并发和异步-下 - Cactus Hole</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>BoBoBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="RUST圣经-高阶学习-多线程并发和异步-下"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-26 13:36" pubdate>
          February 26, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.8k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          74 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">RUST圣经-高阶学习-多线程并发和异步-下</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="4-线程同步：锁、Condvar-和信号量"><a href="#4-线程同步：锁、Condvar-和信号量" class="headerlink" title="4 线程同步：锁、Condvar 和信号量"></a>4 线程同步：锁、Condvar 和信号量</h2><p>在多线程编程中，同步性极其的重要，当你需要同时访问一个资源、控制不同线程的执行次序时，都需要使用到同步性。</p>
<p>在 Rust 中有多种方式可以实现同步性。在上一节中讲到的消息传递就是同步性的一种实现方式，例如我们可以通过消息传递来控制不同线程间的执行次序。还可以使用共享内存来实现同步性，例如通过锁和原子操作等并发原语来实现多个线程同时且安全地去访问一个资源。</p>
<h2 id="4-1-该如何选择"><a href="#4-1-该如何选择" class="headerlink" title="4.1 该如何选择"></a>4.1 该如何选择</h2><p>共享内存可以说是同步的灵魂，因为消息传递的底层实际上也是通过共享内存来实现，两者的区别如下：</p>
<ul>
<li>共享内存相对消息传递能节省多次内存拷贝的成本</li>
<li>共享内存的实现简洁的多</li>
<li>共享内存的锁竞争更多</li>
</ul>
<p>消息传递适用的场景很多，我们下面列出了几个主要的使用场景:</p>
<ul>
<li>需要可靠和简单的(简单不等于简洁)实现时</li>
<li>需要模拟现实世界，例如用消息去通知某个目标执行相应的操作时</li>
<li>需要一个任务处理流水线(管道)时，等等</li>
</ul>
<p>而使用共享内存(并发原语)的场景往往就比较简单粗暴：需要简洁的实现以及更高的性能时。</p>
<p>总之，消息传递类似一个单所有权的系统：一个值同时只能有一个所有者，如果另一个线程需要该值的所有权，需要将所有权通过消息传递进行转移。而共享内存类似于一个多所有权的系统：多个线程可以同时访问同一个值。</p>
<h2 id="4-2-互斥锁-Mutex"><a href="#4-2-互斥锁-Mutex" class="headerlink" title="4.2 互斥锁 Mutex"></a>4.2 互斥锁 Mutex</h2><p>既然是共享内存，那并发原语自然是重中之重，先来一起看看皇冠上的明珠: 互斥锁Mutex(mutual exclusion 的缩写)。</p>
<p>Mutex让多个线程并发的访问同一个值变成了排队访问：同一时间，只允许一个线程A访问该值，其它线程需要等待A访问完成后才能继续。</p>
<h3 id="4-2-1-单线程中使用-Mutex"><a href="#4-2-1-单线程中使用-Mutex" class="headerlink" title="4.2.1 单线程中使用 Mutex"></a>4.2.1 单线程中使用 Mutex</h3><p>先来看看单线程中Mutex该如何使用:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-comment">// 使用`Mutex`结构体的关联函数创建新的互斥锁实例</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);

    &#123;
        <span class="hljs-comment">// 获取锁，然后deref为`m`的引用</span>
        <span class="hljs-comment">// lock返回的是Result</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        *num = <span class="hljs-number">6</span>;
        <span class="hljs-comment">// 锁自动被drop</span>
    &#125;

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;m = &#123;:?&#125;&quot;</span>, m);
&#125;</code></pre></div>

<p>和Box类似，数据被Mutex所拥有，要访问内部的数据，需要使用方法m.lock()向m申请一个锁, 该方法会阻塞当前线程，直到获取到锁，因此当多个线程同时访问该数据时，只有一个线程能获取到锁，其它线程只能阻塞着等待，这样就保证了数据能被安全的修改！</p>
<p>m.lock()方法也有可能报错，例如当前正在持有锁的线程panic了。在这种情况下，其它线程不可能再获得锁，因此lock方法会返回一个错误。</p>
<p>因为Mutex<T>是一个智能指针，准确的说是m.lock()返回一个智能指针MutexGuard<T>:</p>
<ul>
<li>它实现了Deref特征，会被自动解引用后获得一个引用类型，该引用指向Mutex内部的数据</li>
<li>它还实现了Drop特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁</li>
</ul>
<p>正因为智能指针的使用，使得我们无需任何操作就能获取其中的数据。</p>
<p>如果释放锁，你需要做的仅仅是做好锁的作用域管理，例如上述代码的内部花括号使用，建议读者尝试下去掉内部的花括号，然后再次尝试获取第二个锁num1，看看会发生什么，友情提示：不会报错，但是主线程会永远阻塞，因为不幸发生了死锁。</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    *num = <span class="hljs-number">6</span>;
    <span class="hljs-comment">// 锁还没有被 drop 就尝试申请下一个锁，导致主线程阻塞</span>
    <span class="hljs-comment">// drop(num); // 手动 drop num ，可以让 num1 申请到下个锁</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num1</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    *num1 = <span class="hljs-number">7</span>;
    <span class="hljs-comment">// drop(num1); // 手动 drop num1 ，观察打印结果的不同</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;m = &#123;:?&#125;&quot;</span>, m);
&#125;</code></pre></div>

<h3 id="4-2-2-多线程中使用-Mutex"><a href="#4-2-2-多线程中使用-Mutex" class="headerlink" title="4.2.2 多线程中使用 Mutex"></a>4.2.2 多线程中使用 Mutex</h3><p>如何在多线程下使用Mutex来访问同一个资源.</p>
<h4 id="4-2-2-1-无法运行的Rc"><a href="#4-2-2-1-无法运行的Rc" class="headerlink" title="4.2.2.1 无法运行的Rc"></a>4.2.2.1 无法运行的Rc<T></h4><div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;
<span class="hljs-keyword">use</span> std::sync::Mutex;
<span class="hljs-keyword">use</span> std::thread;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-comment">// 通过`Rc`实现`Mutex`的多所有权</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];

    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;counter);
        <span class="hljs-comment">// 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

            *num += <span class="hljs-number">1</span>;
        &#125;);
        handles.<span class="hljs-title function_ invoke__">push</span>(handle);
    &#125;

    <span class="hljs-comment">// 等待所有子线程完成</span>
    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;
        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    &#125;

    <span class="hljs-comment">// 输出最终的计数结果</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());
&#125;</code></pre></div>

<p>由于子线程需要通过move拿走锁的所有权，因此我们需要使用多所有权来保证每个线程都拿到数据的独立所有权，恰好智能指针Rc<T>可以做到(上面代码会报错！</p>
<p>以上代码实现了在多线程中计数的功能，由于多个线程都需要去修改该计数器，因此我们需要使用锁来保证同一时间只有一个线程可以修改计数器，否则会导致脏数据：想象一下 A 线程和 B 线程同时拿到计数器，获取了当前值1, 并且同时对其进行了修改，最后值变成2, 毕竟正确的值是3，因为两个线程各自加 1。</p>
<h4 id="4-2-2-2-多线程安全的-Arc"><a href="#4-2-2-2-多线程安全的-Arc" class="headerlink" title="4.2.2.2 多线程安全的 Arc"></a>4.2.2.2 多线程安全的 Arc<T></h4><p>Arc<T>，得益于它的内部计数器是多线程安全的，因此可以在多线程环境中使用:</p>
<p>将Rc换成Arc就可以正常使用了</p>
<h4 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h4><p>Rust中Rc<T>和RefCell<T>的结合，可以实现单线程的内部可变性。</p>
<p>现在我们又有了新的武器，由于Mutex<T>可以支持修改内部数据，当结合Arc<T>一起使用时，可以实现多线程的内部可变性。</p>
<p>简单总结下：Rc<T>&#x2F;RefCell<T>用于单线程内部可变性， Arc<T>&#x2F;Mutex<T>用于多线程内部可变性。</p>
<h4 id="需要小心使用的-Mutex"><a href="#需要小心使用的-Mutex" class="headerlink" title="需要小心使用的 Mutex"></a>需要小心使用的 Mutex</h4><ul>
<li>在使用数据前必须先获取锁</li>
<li>在数据使用完成后，必须及时的释放锁，比如文章开头的例子，使用内部语句块的目的就是为了及时的释放锁</li>
</ul>
<p>对于其它语言，忘记释放锁是经常发生的，虽然 Rust 通过智能指针的drop机制帮助我们避免了这一点，但是由于不及时释放锁导致的性能问题也是常见的。</p>
<p>正因为这种困难性，导致很多用户都热衷于使用消息传递的方式来实现同步，例如 Go 语言直接把channel内置在语言特性中，甚至还有无锁的语言，例如erlang，完全使用Actor模型，依赖消息传递来完成共享和同步。幸好 Rust 的类型系统、所有权机制、智能指针等可以很好的帮助我们减轻使用锁时的负担。</p>
<p>另一个值的注意的是在使用Mutex<T>时，Rust 无法帮我们避免所有的逻辑错误，例如在之前章节，我们提到过使用Rc<T>可能会导致循环引用的问题。类似的，Mutex<T>也存在使用上的风险，例如创建死锁(deadlock)：当一个操作试图锁住两个资源，然后两个线程各自获取其中一个锁，并试图获取另一个锁时，就会造成死锁。</p>
<h2 id="4-3-死锁"><a href="#4-3-死锁" class="headerlink" title="4.3 死锁"></a>4.3 死锁</h2><p>Rust 中有多种方式可以创建死锁，了解这些方式有助于你提前规避可能的风险。</p>
<h2 id="4-3-1-单线程死锁"><a href="#4-3-1-单线程死锁" class="headerlink" title="4.3.1 单线程死锁"></a>4.3.1 单线程死锁</h2><p>这种死锁比较容易规避，但是当代码复杂后还是有可能遇到：</p>
<div class="code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">use</span> std::sync::<span class="hljs-type">Mutex</span>;

<span class="hljs-title">fn</span> main() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Mutex</span>::new(0);</span>
    <span class="hljs-keyword">let</span> d1 = <span class="hljs-class"><span class="hljs-keyword">data</span>.lock();</span>
    <span class="hljs-keyword">let</span> d2 = <span class="hljs-class"><span class="hljs-keyword">data</span>.lock();</span>
&#125; // d1锁在此处释放</code></pre></div>

<p>只要你在另一个锁还未被释放时去申请新的锁，就会触发，当代码复杂后，这种情况可能就没有那么显眼。</p>
<h2 id="4-3-2-多线程死锁"><a href="#4-3-2-多线程死锁" class="headerlink" title="4.3.2 多线程死锁"></a>4.3.2 多线程死锁</h2><p>当我们拥有两个锁，且两个线程各自使用了其中一个锁，然后试图去访问另一个锁时，就可能发生死锁：</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;sync::&#123;Mutex, MutexGuard&#125;, thread&#125;;
<span class="hljs-keyword">use</span> std::thread::sleep;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-keyword">use</span> lazy_static::lazy_static;
lazy_static! &#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> MUTEX1: Mutex&lt;<span class="hljs-type">i64</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> MUTEX2: Mutex&lt;<span class="hljs-type">i64</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-comment">// 存放子线程的句柄</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">children</span> = <span class="hljs-built_in">vec!</span>[];
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i_thread</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">2</span> &#123;
        children.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
            <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1</span> &#123;
                <span class="hljs-comment">// 线程1</span>
                <span class="hljs-keyword">if</span> i_thread % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;
                    <span class="hljs-comment">// 锁住MUTEX1</span>
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span>: MutexGuard&lt;<span class="hljs-type">i64</span>&gt; = MUTEX1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 锁住了MUTEX1，接着准备去锁MUTEX2 !&quot;</span>, i_thread);

                    <span class="hljs-comment">// 当前线程睡眠一小会儿，等待线程2锁住MUTEX2</span>
                    <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span>));

                    <span class="hljs-comment">// 去锁MUTEX2</span>
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span> = MUTEX2.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
                <span class="hljs-comment">// 线程2</span>
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// 锁住MUTEX2</span>
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">_guard</span> = MUTEX2.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 锁住了MUTEX2, 准备去锁MUTEX1&quot;</span>, i_thread);

                    <span class="hljs-keyword">let</span> <span class="hljs-variable">_guard</span> = MUTEX1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
                &#125;
            &#125;
        &#125;));
    &#125;

    <span class="hljs-comment">// 等子线程完成</span>
    <span class="hljs-keyword">for</span> <span class="hljs-variable">child</span> <span class="hljs-keyword">in</span> children &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = child.<span class="hljs-title function_ invoke__">join</span>();
    &#125;

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;死锁没有发生&quot;</span>);
&#125;</code></pre></div>

<p>在上面的描述中，我们用了”可能”二字，原因在于死锁在这段代码中不是必然发生的，总有一次运行你能看到最后一行打印输出。这是由于子线程的初始化顺序和执行速度并不确定，我们无法确定哪个线程中的锁先被执行，因此也无法确定两个线程对锁的具体使用顺序。</p>
<p>但是，可以简单的说明下死锁发生的必然条件：线程 1 锁住了MUTEX1并且线程2锁住了MUTEX2，然后线程 1 试图去访问MUTEX2，同时线程2试图去访问MUTEX1，就会死锁。 因为线程 2 需要等待线程 1 释放MUTEX1后，才会释放MUTEX2，而与此同时，线程 1 需要等待线程 2 释放MUTEX2后才能释放MUTEX1，这种情况造成了两个线程都无法释放对方需要的锁，最终死锁。</p>
<p>那么为何某些时候，死锁不会发生？原因很简单，线程 2 在线程 1 锁MUTEX1之前，就已经全部执行完了，随之线程 2 的MUTEX2和MUTEX1被全部释放，线程 1 对锁的获取将不再有竞争者。 同理，线程 1 若全部被执行完，那线程 2 也不会被锁，因此我们在线程 1 中间加一个睡眠，增加死锁发生的概率。如果你在线程 2 中同样的位置也增加一个睡眠，那死锁将必然发生!</p>
<h2 id="4-3-3-try-lock"><a href="#4-3-3-try-lock" class="headerlink" title="4.3.3 try_lock"></a>4.3.3 try_lock</h2><p>与lock方法不同，try_lock会尝试去获取一次锁，如果无法获取会返回一个错误，因此不会发生阻塞:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;sync::&#123;Mutex, MutexGuard&#125;, thread&#125;;
<span class="hljs-keyword">use</span> std::thread::sleep;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-keyword">use</span> lazy_static::lazy_static;
lazy_static! &#123;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> MUTEX1: Mutex&lt;<span class="hljs-type">i64</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> MUTEX2: Mutex&lt;<span class="hljs-type">i64</span>&gt; = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-comment">// 存放子线程的句柄</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">children</span> = <span class="hljs-built_in">vec!</span>[];
    <span class="hljs-keyword">for</span> <span class="hljs-variable">i_thread</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">2</span> &#123;
        children.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
            <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1</span> &#123;
                <span class="hljs-comment">// 线程1</span>
                <span class="hljs-keyword">if</span> i_thread % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;
                    <span class="hljs-comment">// 锁住MUTEX1</span>
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span>: MutexGuard&lt;<span class="hljs-type">i64</span>&gt; = MUTEX1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 锁住了MUTEX1，接着准备去锁MUTEX2 !&quot;</span>, i_thread);

                    <span class="hljs-comment">// 当前线程睡眠一小会儿，等待线程2锁住MUTEX2</span>
                    <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span>));

                    <span class="hljs-comment">// 去锁MUTEX2</span>
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span> = MUTEX2.<span class="hljs-title function_ invoke__">try_lock</span>();
                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 获取 MUTEX2 锁的结果: &#123;:?&#125;&quot;</span>, i_thread, guard);
                <span class="hljs-comment">// 线程2</span>
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// 锁住MUTEX2</span>
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">_guard</span> = MUTEX2.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();

                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 锁住了MUTEX2, 准备去锁MUTEX1&quot;</span>, i_thread);
                    <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">10</span>));
                    <span class="hljs-keyword">let</span> <span class="hljs-variable">guard</span> = MUTEX1.<span class="hljs-title function_ invoke__">try_lock</span>();
                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程 &#123;&#125; 获取 MUTEX1 锁的结果: &#123;:?&#125;&quot;</span>, i_thread, guard);
                &#125;
            &#125;
        &#125;));
    &#125;

    <span class="hljs-comment">// 等子线程完成</span>
    <span class="hljs-keyword">for</span> <span class="hljs-variable">child</span> <span class="hljs-keyword">in</span> children &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = child.<span class="hljs-title function_ invoke__">join</span>();
    &#125;

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;死锁没有发生&quot;</span>);
&#125;</code></pre></div>

<p>将lock替换成try_lock，与之前的结果不同，这段代码将不会再有死锁发生：</p>
<p>当try_lock失败时，会报出一个错误:Err(“WouldBlock”)，接着线程中的剩余代码会继续执行，不会被阻塞。</p>
<div class="code-wrapper"><pre><code class="hljs ceylon">一个有趣的命名规则：在 Rust 标准库中，使用<span class="hljs-keyword">try</span><span class="hljs-number">_</span>xxx都会尝试进行一次操作，如果无法完成，就立即返回，不会发生阻塞。例如消息传递章节中的<span class="hljs-keyword">try</span><span class="hljs-number">_</span>recv以及本章节中的<span class="hljs-keyword">try</span><span class="hljs-number">_</span>lock</code></pre></div>

<h2 id="4-4-读写锁-RwLock"><a href="#4-4-读写锁-RwLock" class="headerlink" title="4.4 读写锁 RwLock"></a>4.4 读写锁 RwLock</h2><p>Mutex会对每次读写都进行加锁，但某些时候，我们需要大量的并发读，Mutex就无法满足需求了，此时就可以使用RwLock:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::RwLock;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">lock</span> = RwLock::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);

    <span class="hljs-comment">// 同一时间允许多个读</span>
    &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = lock.<span class="hljs-title function_ invoke__">read</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = lock.<span class="hljs-title function_ invoke__">read</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-built_in">assert_eq!</span>(*r1, <span class="hljs-number">5</span>);
        <span class="hljs-built_in">assert_eq!</span>(*r2, <span class="hljs-number">5</span>);
    &#125; <span class="hljs-comment">// 读锁在此处被drop</span>

    <span class="hljs-comment">// 同一时间只允许一个写</span>
    &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">w</span> = lock.<span class="hljs-title function_ invoke__">write</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        *w += <span class="hljs-number">1</span>;
        <span class="hljs-built_in">assert_eq!</span>(*w, <span class="hljs-number">6</span>);

        <span class="hljs-comment">// 以下代码会阻塞发生死锁，因为读和写不允许同时存在</span>
        <span class="hljs-comment">// 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中</span>
        <span class="hljs-comment">// let r1 = lock.read();</span>
        <span class="hljs-comment">// println!(&quot;&#123;:?&#125;&quot;,r1);</span>
    &#125;<span class="hljs-comment">// 写锁在此处被drop</span>
&#125;</code></pre></div>

<p>RwLock在使用上和Mutex区别不大，只有在多个读的情况下不阻塞程序，其他如读写、写读、写写情况下均会对后获取锁的操作进行阻塞。</p>
<p>也可以使用try_write和try_read来尝试进行一次写&#x2F;读，若失败则返回错误:</p>
<div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Err</span><span class="hljs-params">(<span class="hljs-string">&quot;WouldBlock&quot;</span>)</span></span></code></pre></div>

<p>简单总结下RwLock:</p>
<ul>
<li>同时允许多个读，但最多只能有一个写</li>
<li>读和写不能同时存在</li>
<li>读可以使用read、try_read，写write、try_write, 在实际项目中，try_xxx会安全的多</li>
</ul>
<h2 id="4-5-Mutex-还是-RwLock"><a href="#4-5-Mutex-还是-RwLock" class="headerlink" title="4.5 Mutex 还是 RwLock"></a>4.5 Mutex 还是 RwLock</h2><p>简单性上Mutex完胜，因为使用RwLock你得操心几个问题：</p>
<ul>
<li>读和写不能同时发生，如果使用try_xxx解决，就必须做大量的错误处理和失败重试机制</li>
<li>当读多写少时，写操作可能会因为一直无法获得锁导致连续多次失败(writer starvation)</li>
<li>RwLock 其实是操作系统提供的，实现原理要比Mutex复杂的多，因此单就锁的性能而言，比不上原生实现的Mutex</li>
</ul>
<p>再来简单总结下两者的使用场景：</p>
<ul>
<li>追求高并发读取时，使用RwLock，因为Mutex一次只允许一个线程去读取</li>
<li>如果要保证写操作的成功性，使用Mutex</li>
<li>不知道哪个合适，统一使用Mutex</li>
</ul>
<p>RwLock虽然看上去貌似提供了高并发读取的能力，但这个不能说明它的性能比Mutex高，事实上Mutex性能要好不少，后者唯一的问题也仅仅在于不能并发读取。</p>
<p>一个常见的、错误的使用RwLock的场景就是使用HashMap进行简单读写，因为HashMap的读和写都非常快，RwLock的复杂实现和相对低的性能反而会导致整体性能的降低，因此一般来说更适合使用Mutex。 </p>
<p>要使用RwLock要确保满足以下两个条件：并发读，且需要对读到的资源进行”长时间”的操作，HashMap也许满足了并发读的需求，但是往往并不能满足后者：”长时间”的操作。</p>
<h2 id="4-6-三方库提供的锁实现"><a href="#4-6-三方库提供的锁实现" class="headerlink" title="4.6 三方库提供的锁实现"></a>4.6 三方库提供的锁实现</h2><p>标准库在设计时总会存在取舍，因为往往性能并不是最好的，如果你追求性能，可以使用三方库提供的并发原语:</p>
<ul>
<li>parking_lot, 功能更完善、稳定，社区较为活跃，star 较多，更新较为活跃</li>
<li>spin, 在多数场景中性能比parking_lot高一点，最近没怎么更新</li>
</ul>
<p>如果不是追求特别极致的性能，建议选择前者。</p>
<h2 id="4-7-用条件变量-Condvar-控制线程的同步"><a href="#4-7-用条件变量-Condvar-控制线程的同步" class="headerlink" title="4.7 用条件变量(Condvar)控制线程的同步"></a>4.7 用条件变量(Condvar)控制线程的同步</h2><p>Mutex用于解决资源安全访问的问题，但是我们还需要一个手段来解决资源访问顺序的问题。而 Rust 考虑到了这一点，为我们提供了条件变量(Condition Variables)，它经常和Mutex一起使用，可以让线程挂起，直到某个条件发生后再继续执行</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc,Mutex,Condvar&#125;;
<span class="hljs-keyword">use</span> std::thread::&#123;spawn,sleep&#125;;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">flag</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>));
    <span class="hljs-keyword">let</span> <span class="hljs-variable">cond</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Condvar::<span class="hljs-title function_ invoke__">new</span>());
    <span class="hljs-keyword">let</span> <span class="hljs-variable">cflag</span> = flag.<span class="hljs-title function_ invoke__">clone</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">ccond</span> = cond.<span class="hljs-title function_ invoke__">clone</span>();

    <span class="hljs-keyword">let</span> <span class="hljs-variable">hdl</span> = <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lock</span> = cflag.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">while</span> counter &lt; <span class="hljs-number">3</span> &#123;
            <span class="hljs-keyword">while</span> !*lock &#123;
                <span class="hljs-comment">// wait方法会接收一个MutexGuard&lt;&#x27;a, T&gt;，且它会自动地暂时释放这个锁，使其他线程可以拿到锁并进行数据更新。</span>
                <span class="hljs-comment">// 同时当前线程在此处会被阻塞，直到被其他地方notify后，它会将原本的MutexGuard&lt;&#x27;a, T&gt;还给我们，即重新获取到了锁，同时唤醒了此线程。</span>
                lock = ccond.<span class="hljs-title function_ invoke__">wait</span>(lock).<span class="hljs-title function_ invoke__">unwrap</span>();
            &#125;
            
            *lock = <span class="hljs-literal">false</span>;

            counter += <span class="hljs-number">1</span>;
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;inner counter: &#123;&#125;&quot;</span>, counter);
        &#125;
    &#125;);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">loop</span> &#123;
        <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>));
        *flag.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>() = <span class="hljs-literal">true</span>;
        counter += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> counter &gt; <span class="hljs-number">3</span> &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;outside counter: &#123;&#125;&quot;</span>, counter);
        cond.<span class="hljs-title function_ invoke__">notify_one</span>();
    &#125;
    hdl.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, flag);
&#125;</code></pre></div>

<p>例子中通过主线程来触发子线程实现交替打印输出：</p>
<div class="code-wrapper"><pre><code class="hljs nix">outside <span class="hljs-params">counter:</span> <span class="hljs-number">1</span>
inner <span class="hljs-params">counter:</span> <span class="hljs-number">1</span>
outside <span class="hljs-params">counter:</span> <span class="hljs-number">2</span>
inner <span class="hljs-params">counter:</span> <span class="hljs-number">2</span>
outside <span class="hljs-params">counter:</span> <span class="hljs-number">3</span>
inner <span class="hljs-params">counter:</span> <span class="hljs-number">3</span>
Mutex &#123; <span class="hljs-params">data:</span> <span class="hljs-literal">true</span>, <span class="hljs-params">poisoned:</span> <span class="hljs-literal">false</span>, .. &#125;</code></pre></div>

<h2 id="4-8-信号量-Semaphore"><a href="#4-8-信号量-Semaphore" class="headerlink" title="4.8 信号量 Semaphore"></a>4.8 信号量 Semaphore</h2><p>在多线程中，另一个重要的概念就是信号量，使用它可以让我们精准的控制当前正在运行的任务最大数量。<br>当一个新游戏刚开服时(有些较火的老游戏也会，比如wow)，往往会控制游戏内玩家的同时在线数，一旦超过某个临界值，就开始进行排队进服。而在实际使用中，也有很多时候，我们需要通过信号量来控制最大并发数，防止服务器资源被撑爆。</p>
<p>本来 Rust 在标准库中有提供一个信号量实现, 但是由于各种原因这个库现在已经不再推荐使用了，因此我们推荐使用tokio中提供的Semaphore实现: tokio::sync::Semaphore。</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Arc;
<span class="hljs-keyword">use</span> tokio::sync::Semaphore;

<span class="hljs-meta">#[tokio::main]</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">semaphore</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Semaphore::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>));
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">join_handles</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">5</span> &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">permit</span> = semaphore.<span class="hljs-title function_ invoke__">clone</span>().<span class="hljs-title function_ invoke__">acquire_owned</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();
        join_handles.<span class="hljs-title function_ invoke__">push</span>(tokio::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// 在这里执行任务...</span>
            <span class="hljs-comment">//</span>
            <span class="hljs-title function_ invoke__">drop</span>(permit);
        &#125;));
    &#125;

    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> join_handles &#123;
        handle.<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();
    &#125;
&#125;</code></pre></div>

<p>上面代码创建了一个容量为 3 的信号量，当正在执行的任务超过 3 时，剩下的任务需要等待正在执行任务完成并减少信号量后到 3 以内时，才能继续执行。</p>
<p>这里的关键其实说白了就在于：信号量的申请和归还，使用前需要申请信号量，如果容量满了，就需要等待；使用后需要释放信号量，以便其它等待者可以继续。</p>
<h2 id="5-线程同步：Atomic-原子类型与内存顺序"><a href="#5-线程同步：Atomic-原子类型与内存顺序" class="headerlink" title="5 线程同步：Atomic 原子类型与内存顺序"></a>5 线程同步：Atomic 原子类型与内存顺序</h2><p>Mutex用起来简单，但是无法并发读，RwLock可以并发读，但是使用场景较为受限且性能不够，那么有没有一种全能性选手呢？ 欢迎我们的Atomic闪亮登场。</p>
<p>在多核 CPU 下，当某个 CPU 核心开始运行原子操作时，会先暂停其它 CPU 内核对内存的操作，以保证原子操作不会被其它 CPU 内核所干扰。</p>
<p>原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。</p>
<p>原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了CAS循环，当大量的冲突发生时，该等待还是得等待！但是总归比锁要好。</p>
<p><code>CAS 全称是 Compare and swap, 它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值，如果相等，则将其修改为新的值</code></p>
<h2 id="5-1-使用-Atomic-作为全局变量"><a href="#5-1-使用-Atomic-作为全局变量" class="headerlink" title="5.1 使用 Atomic 作为全局变量"></a>5.1 使用 Atomic 作为全局变量</h2><p>原子类型的一个常用场景，就是作为全局变量来使用:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Sub;
<span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicU64, Ordering&#125;;
<span class="hljs-keyword">use</span> std::thread::&#123;<span class="hljs-keyword">self</span>, JoinHandle&#125;;
<span class="hljs-keyword">use</span> std::time::Instant;

<span class="hljs-keyword">const</span> N_TIMES: <span class="hljs-type">u64</span> = <span class="hljs-number">10000000</span>;
<span class="hljs-keyword">const</span> N_THREADS: <span class="hljs-type">usize</span> = <span class="hljs-number">10</span>;

<span class="hljs-keyword">static</span> R: AtomicU64 = AtomicU64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_n_times</span>(n: <span class="hljs-type">u64</span>) <span class="hljs-punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;
    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
        <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..n &#123;
            R.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Ordering::Relaxed);
        &#125;
    &#125;)
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = Instant::<span class="hljs-title function_ invoke__">now</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">threads</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(N_THREADS);

    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..N_THREADS &#123;
        threads.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-title function_ invoke__">add_n_times</span>(N_TIMES));
    &#125;

    <span class="hljs-keyword">for</span> <span class="hljs-variable">thread</span> <span class="hljs-keyword">in</span> threads &#123;
        thread.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    &#125;

    <span class="hljs-built_in">assert_eq!</span>(N_TIMES * N_THREADS <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>, R.<span class="hljs-title function_ invoke__">load</span>(Ordering::Relaxed));

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,Instant::<span class="hljs-title function_ invoke__">now</span>().<span class="hljs-title function_ invoke__">sub</span>(s));
&#125;</code></pre></div>

<p>以上代码启动了数个线程，每个线程都在疯狂对全局变量进行加 1 操作, 最后将它与线程数 * 加1次数进行比较，如果发生了因为多个线程同时修改导致了脏数据，那么这两个必将不相等。好在，它没有让我们失望，不仅快速的完成了任务，而且保证了 100%的并发安全性。</p>
<p>当然以上代码的功能其实也可以通过Mutex来实现，但是后者的强大功能是建立在额外的性能损耗基础上的，因此性能会逊色不少:</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Atomic</span>实现：<span class="hljs-number">673</span>ms
<span class="hljs-attribute">Mutex</span>实现: <span class="hljs-number">1136</span>ms</code></pre></div>

<p>可以看到Atomic实现会比Mutex快41%，实际上在复杂场景下还能更快(甚至达到 4 倍的性能差距)！</p>
<p>还有一点值得注意: 和Mutex一样，Atomic的值具有内部可变性，你无需将其声明为mut：</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;
<span class="hljs-keyword">use</span> std::sync::atomic::&#123;Ordering, AtomicU64&#125;;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span> &#123;
    count: <span class="hljs-type">u64</span>
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(Counter &#123;
        count: <span class="hljs-number">0</span>
    &#125;);

    n.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().count += <span class="hljs-number">1</span>;

    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = AtomicU64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);

    n.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">0</span>, Ordering::Relaxed);
&#125;</code></pre></div>

<p>这里有一个奇怪的枚举成员Ordering::Relaxed, 看上去很像是排序作用，但是我们并没有做排序操作啊？实际上它用于控制原子操作使用的内存顺序。</p>
<h2 id="5-2-内存顺序"><a href="#5-2-内存顺序" class="headerlink" title="5.2 内存顺序"></a>5.2 内存顺序</h2><p>内存顺序是指 CPU 在访问内存时的顺序，该顺序可能受以下因素的影响：</p>
<ul>
<li>代码中的先后顺序</li>
<li>编译器优化导致在编译阶段发生改变(内存重排序 reordering)</li>
<li>运行阶段因 CPU 的缓存机制导致顺序被打乱</li>
</ul>
<h3 id="5-2-1-编译器优化导致内存顺序的改变"><a href="#5-2-1-编译器优化导致内存顺序的改变" class="headerlink" title="5.2.1 编译器优化导致内存顺序的改变**"></a>5.2.1 编译器优化导致内存顺序的改变**</h3><p>对于第二点，我们举个例子：</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> X: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> Y: <span class="hljs-type">u64</span> = <span class="hljs-number">1</span>;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    ...     <span class="hljs-comment">// A</span>

    <span class="hljs-keyword">unsafe</span> &#123;
        ... <span class="hljs-comment">// B</span>
        X = <span class="hljs-number">1</span>;
        ... <span class="hljs-comment">// C</span>
        Y = <span class="hljs-number">3</span>;
        ... <span class="hljs-comment">// D</span>
        X = <span class="hljs-number">2</span>;
        ... <span class="hljs-comment">// E</span>
    &#125;
&#125;</code></pre></div>

<p>假如在C和D代码片段中，根本没有用到X &#x3D; 1，那么编译器很可能会将X &#x3D; 1和X &#x3D; 2进行合并:</p>
<p>若代码A中创建了一个新的线程用于读取全局静态变量X，则该线程将无法读取到X &#x3D; 1的结果，因为在编译阶段就已经被优化掉。</p>
<h3 id="5-2-2-CPU-缓存导致的内存顺序的改变"><a href="#5-2-2-CPU-缓存导致的内存顺序的改变" class="headerlink" title="5.2.2 CPU 缓存导致的内存顺序的改变"></a>5.2.2 CPU 缓存导致的内存顺序的改变</h3><p>假设之前的X &#x3D; 1没有被优化掉，并且在代码片段A中有一个新的线程:</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">initial</span> state: X = <span class="hljs-number">0</span>, Y = <span class="hljs-number">1</span>

<span class="hljs-attribute">THREAD</span> Main     THREAD A
<span class="hljs-attribute">X</span> = <span class="hljs-number">1</span>;          if X == <span class="hljs-number">1</span> &#123;
<span class="hljs-attribute">Y</span> = <span class="hljs-number">3</span>;              Y *= <span class="hljs-number">2</span>;
<span class="hljs-attribute">X</span> = <span class="hljs-number">2</span>;          &#125;</code></pre></div>

<p>我们来讨论下以上线程状态，Y最终的可能值(可能性依次降低):</p>
<ul>
<li>Y &#x3D; 3: 线程Main运行完后才运行线程A，或者线程A运行完后再运行线程Main</li>
<li>Y &#x3D; 6: 线程Main的Y &#x3D; 3运行完，但X &#x3D; 2还没被运行， 此时线程 A 开始运行Y *&#x3D; 2, 最后才运行Main线程的X &#x3D; 2</li>
<li>Y &#x3D; 2: 线程Main正在运行Y &#x3D; 3还没结束，此时线程A正在运行Y *&#x3D; 2, 因此Y取到了值 1，然后Main的线程将Y设置为 3， 紧接着就被线程A的Y &#x3D; 2所覆盖</li>
<li>Y &#x3D; 2: 上面的还只是一般的数据竞争，这里虽然产生了相同的结果2，但是背后的原理大相径庭: 线程Main运行完Y &#x3D; 3，但是 CPU 缓存中的Y &#x3D; 3还没有被同步到其它 CPU 缓存中，此时线程A中的Y *&#x3D; 2就开始读取Y，结果读到了值1，最终计算出结果2</li>
</ul>
<p>甚至更改成:</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">initial</span> state: X = <span class="hljs-number">0</span>, Y = <span class="hljs-number">1</span>

<span class="hljs-attribute">THREAD</span> Main     THREAD A
<span class="hljs-attribute">X</span> = <span class="hljs-number">1</span>;          if X == <span class="hljs-number">2</span> &#123;
<span class="hljs-attribute">Y</span> = <span class="hljs-number">3</span>;              Y *= <span class="hljs-number">2</span>;
<span class="hljs-attribute">X</span> = <span class="hljs-number">2</span>;          &#125;</code></pre></div>

<p>还是可能出现Y &#x3D; 2，因为Main线程中的X和Y被同步到其它 CPU 缓存中的顺序未必一致。</p>
<h3 id="5-2-3-限定内存顺序的-5-个规则"><a href="#5-2-3-限定内存顺序的-5-个规则" class="headerlink" title="5.2.3 限定内存顺序的 5 个规则"></a>5.2.3 限定内存顺序的 5 个规则</h3><p>在理解了内存顺序可能存在的改变后，你就可以明白为什么 Rust 提供了Ordering::Relaxed用于限定内存顺序了，事实上，该枚举有 5 个成员:</p>
<ul>
<li>Relaxed， 这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序</li>
<li>Release 释放，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面</li>
<li>Acquire 获取, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和Release在不同线程中联合使用</li>
<li>AcqRel, 是 Acquire 和 Release 的结合，同时拥有它们俩提供的保证。比如你要对一个 atomic 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序</li>
<li>SeqCst 顺序一致性， SeqCst就像是AcqRel的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到SeqCst的原子操作，线程中该SeqCst操作前的数据操作绝对不会被重新排在该SeqCst操作之后，且该SeqCst操作后的数据操作也绝对不会被重新排在SeqCst操作前。</li>
</ul>
<p>这些规则由于是系统提供的，因此其它语言提供的相应规则也大同小异，大家如果不明白可以看看其它语言的相关解释。</p>
<h3 id="5-2-4-内存屏障的例子"><a href="#5-2-4-内存屏障的例子" class="headerlink" title="5.2.4 内存屏障的例子"></a>5.2.4 内存屏障的例子</h3><p>以Release和Acquire为例，使用它们构筑出一对内存屏障，防止编译器和 CPU 将屏障前(Release)和屏障后(Acquire)中的数据操作重新排在屏障围成的范围之外:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread::&#123;<span class="hljs-keyword">self</span>, JoinHandle&#125;;
<span class="hljs-keyword">use</span> std::sync::atomic::&#123;Ordering, AtomicBool&#125;;

<span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">reset</span>() &#123;
    <span class="hljs-keyword">unsafe</span> &#123;
        DATA = <span class="hljs-number">0</span>;
    &#125;
    READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, Ordering::Relaxed);
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">producer</span>() <span class="hljs-punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;
    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
        <span class="hljs-keyword">unsafe</span> &#123;
            DATA = <span class="hljs-number">100</span>;                                 <span class="hljs-comment">// A</span>
        &#125;
        READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Ordering::Release);           <span class="hljs-comment">// B: 内存屏障 ↑</span>
    &#125;)
&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">consumer</span>() <span class="hljs-punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;
    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
        <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Ordering::Acquire) &#123;&#125;         <span class="hljs-comment">// C: 内存屏障 ↓</span>

        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">100</span>, <span class="hljs-keyword">unsafe</span> &#123; DATA &#125;);               <span class="hljs-comment">// D</span>
    &#125;)
&#125;


<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">loop</span> &#123;
        <span class="hljs-title function_ invoke__">reset</span>();

        <span class="hljs-keyword">let</span> <span class="hljs-variable">t_producer</span> = <span class="hljs-title function_ invoke__">producer</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-variable">t_consumer</span> = <span class="hljs-title function_ invoke__">consumer</span>();

        t_producer.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
        t_consumer.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    &#125;
&#125;</code></pre></div>

<p>原则上，Acquire用于读取，而Release用于写入。但是由于有些原子操作同时拥有读取和写入的功能，此时就需要使用AcqRel来设置内存顺序了。在内存屏障中被写入的数据，都可以被其它线程读取到，不会有 CPU 缓存的问题。</p>
<p><strong>内存顺序的选择</strong></p>
<ul>
<li>不知道怎么选择时，优先使用SeqCst，虽然会稍微减慢速度，但是慢一点也比出现错误好</li>
<li>多线程只计数fetch_add而不使用该值触发其他逻辑分支的简单使用场景，可以使用Relaxed 参考 Which std::sync::atomic::Ordering to use?</li>
</ul>
<h2 id="5-3-多线程中使用-Atomic"><a href="#5-3-多线程中使用-Atomic" class="headerlink" title="5.3 多线程中使用 Atomic"></a>5.3 多线程中使用 Atomic</h2><p>在多线程环境中要使用Atomic需要配合Arc：</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Arc;
<span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;
<span class="hljs-keyword">use</span> std::&#123;hint, thread&#125;;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">spinlock</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>));

    <span class="hljs-keyword">let</span> <span class="hljs-variable">spinlock_clone</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;spinlock);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">thread</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;
        spinlock_clone.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">0</span>, Ordering::SeqCst);
    &#125;);

    <span class="hljs-comment">// 等待其它线程释放锁</span>
    <span class="hljs-keyword">while</span> spinlock.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst) != <span class="hljs-number">0</span> &#123;
        hint::<span class="hljs-title function_ invoke__">spin_loop</span>();
    &#125;

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Err</span>(panic) = thread.<span class="hljs-title function_ invoke__">join</span>() &#123;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Thread had an error: &#123;:?&#125;&quot;</span>, panic);
    &#125;
&#125;</code></pre></div>

<h2 id="5-4-Atomic-能替代锁吗"><a href="#5-4-Atomic-能替代锁吗" class="headerlink" title="5.4 Atomic 能替代锁吗"></a>5.4 Atomic 能替代锁吗</h2><p>那么原子类型既然这么全能，它可以替代锁吗？答案是不行：</p>
<ul>
<li>对于复杂的场景下，锁的使用简单粗暴，不容易有坑</li>
<li>std::sync::atomic包中仅提供了数值类型的原子操作：AtomicBool, AtomicIsize, AtomicUsize, AtomicI8, AtomicU16等，而锁可以应用于各种类型</li>
<li>在有些情况下，必须使用锁来配合，例如上一章节中使用Mutex配合Condvar</li>
</ul>
<h2 id="5-5-Atomic-的应用场景"><a href="#5-5-Atomic-的应用场景" class="headerlink" title="5.5 Atomic 的应用场景"></a>5.5 Atomic 的应用场景</h2><p>事实上，Atomic虽然对于用户不太常用，但是对于高性能库的开发者、标准库开发者都非常常用，它是并发原语的基石，除此之外，还有一些场景适用：</p>
<ul>
<li>无锁(lock free)数据结构</li>
<li>全局变量，例如全局自增 ID, 在后续章节会介绍</li>
<li>跨线程计数器，例如可以用于统计指标</li>
</ul>
<p>以上列出的只是Atomic适用的部分场景，具体场景需要大家未来根据自己的需求进行权衡选择。</p>
<h2 id="6-基于-Send-和-Sync-的线程安全"><a href="#6-基于-Send-和-Sync-的线程安全" class="headerlink" title="6 基于 Send 和 Sync 的线程安全"></a>6 基于 Send 和 Sync 的线程安全</h2><p>为何 Rc、RefCell 和裸指针不可以在多线程间使用？如何让裸指针可以在多线程使用？我们一起来探寻下这些问题的答案。</p>
<h2 id="6-1-无法用于多线程的Rc"><a href="#6-1-无法用于多线程的Rc" class="headerlink" title="6.1 无法用于多线程的Rc"></a>6.1 无法用于多线程的Rc</h2><p>先来看一段多线程使用Rc的代码:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::rc::Rc;
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,v);
    &#125;);

    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
&#125;</code></pre></div>

<p>以上代码将v的所有权通过move转移到子线程中，看似正确实则会报错：</p>
<p>表面原因是Rc无法在线程间安全的转移，实际是编译器给予我们的那句帮助: <code>the trait </code>Send<code>is not implemented for</code>Rc<i32><code>(Rc&lt;i32&gt;未实现Send特征),</code>那么此处的Send特征又是何方神圣？</p>
<h2 id="6-2-Rc-和-Arc-源码对比"><a href="#6-2-Rc-和-Arc-源码对比" class="headerlink" title="6.2 Rc 和 Arc 源码对比"></a>6.2 Rc 和 Arc 源码对比</h2><p>在介绍Send特征之前，再来看看Arc为何可以在多线程使用，玄机在于两者的源码实现上：</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-comment">// Rc源码片段</span>
<span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; !marker::<span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Rc</span>&lt;T&gt; &#123;&#125;
<span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; !marker::<span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Rc</span>&lt;T&gt; &#123;&#125;

<span class="hljs-comment">// Arc源码片段</span>
<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Sync</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;
<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Sync</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;</code></pre></div>

<p>!代表移除特征的相应实现，上面代码中Rc<T>的Send和Sync特征被特地移除了实现，而Arc<T>则相反，实现了Sync + Send，再结合之前的编译器报错，大概可以明白了：Send和Sync是在线程间安全使用一个值的关键。</p>
<h2 id="6-3-Send-和-Sync"><a href="#6-3-Send-和-Sync" class="headerlink" title="6.3 Send 和 Sync"></a>6.3 Send 和 Sync</h2><p>Send和Sync是 Rust 安全并发的重中之重，但是实际上它们只是标记特征(marker trait，该特征未定义任何行为，因此非常适合用于标记), 来看看它们的作用：</p>
<ul>
<li>实现Send的类型可以在线程间安全的传递其所有权</li>
<li>实现Sync的类型可以在线程间安全的共享(通过引用)</li>
</ul>
<p>这里还有一个潜在的依赖：一个类型要在线程间安全的共享的前提是，指向它的引用必须能在线程间传递。因为如果引用都不能被传递，我们就无法在多个线程间使用引用去访问同一个数据了。</p>
<p>由上可知，若类型 T 的引用&amp;T是Send，则T是Sync。</p>
<p>来看看RwLock的实现:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">RwLock</span>&lt;T&gt; &#123;&#125;</code></pre></div>

<p>首先RwLock可以在线程间安全的共享，那它肯定是实现了Sync，但是我们的关注点不在这里。众所周知，RwLock可以并发的读，说明其中的值T必定也可以在线程间共享，那T必定要实现Sync。</p>
<p>果不其然，上述代码中，T的特征约束中就有一个Sync特征，那问题又来了，Mutex是不是相反？再来看看:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span> + <span class="hljs-built_in">Send</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Mutex</span>&lt;T&gt; &#123;&#125;</code></pre></div>

<p>不出所料，Mutex<T>中的T并没有Sync特征约束。</p>
<h2 id="6-4-实现Send和Sync的类型"><a href="#6-4-实现Send和Sync的类型" class="headerlink" title="6.4 实现Send和Sync的类型"></a>6.4 实现Send和Sync的类型</h2><p>在 Rust 中，几乎所有类型都默认实现了Send和Sync，而且由于这两个特征都是可自动派生的特征(通过derive派生)，意味着一个复合类型(例如结构体), 只要它内部的所有成员都实现了Send或者Sync，那么它就自动实现了Send或Sync。</p>
<p>正是因为以上规则，Rust 中绝大多数类型都实现了Send和Sync，除了以下几个(事实上不止这几个，只不过它们比较常见):</p>
<ul>
<li>裸指针两者都没实现，因为它本身就没有任何安全保证</li>
<li>UnsafeCell不是Sync，因此Cell和RefCell也不是</li>
<li>Rc两者都没实现(因为内部的引用计数器不是线程安全的)</li>
</ul>
<p>当然，如果是自定义的复合类型，那没实现那哥俩的就较为常见了：只要复合类型中有一个成员不是Send或Sync，那么该复合类型也就不是Send或Sync。</p>
<p>手动实现 Send 和 Sync 是不安全的，通常并不需要手动实现 Send 和 Sync trait，实现者需要使用unsafe小心维护并发安全保证。</p>
<p>我们来一起看看如何让裸指针可以在线程间安全的使用。</p>
<h2 id="6-5-为裸指针实现Send"><a href="#6-5-为裸指针实现Send" class="headerlink" title="6.5 为裸指针实现Send"></a>6.5 为裸指针实现Send</h2><p>裸指针既没实现Send，意味着下面代码会报错:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-number">5</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,p);
    &#125;);

    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
&#125;</code></pre></div>

<p>报错跟之前无二： <code>*mut u8</code> cannot be sent between threads safely, 但是有一个问题，我们无法为其直接实现Send特征，好在可以用newtype类型 :struct MyBox(*mut u8);。</p>
<p>还记得之前的规则吗：复合类型中有一个成员没实现Send，该复合类型就不是Send，因此我们需要手动为它实现:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>(*<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>);
<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span> &#123;&#125;
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = <span class="hljs-title function_ invoke__">MyBox</span>(<span class="hljs-number">5</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,p);
    &#125;);

    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
&#125;</code></pre></div>

<p>此时，我们的指针已经可以欢快的在多线程间撒欢，以上代码很简单，但有一点需要注意：Send和Sync是unsafe特征，实现时需要用unsafe代码块包裹。</p>
<h2 id="6-6-为裸指针实现Sync"><a href="#6-6-为裸指针实现Sync" class="headerlink" title="6.6 为裸指针实现Sync"></a>6.6 为裸指针实现Sync</h2><p>由于Sync是多线程间共享一个值，大家可能会想这么实现：</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,&amp;v);
    &#125;);

    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
&#125;</code></pre></div>

<p>关于这种用法，在多线程章节也提到过，线程如果直接去借用其它线程的变量，会报错:closure may outlive the current function,, 原因在于编译器无法确定主线程main和子线程t谁的生命周期更长，特别是当两个线程都是子线程时，没有任何人知道哪个子线程会先结束，包括编译器！</p>
<p>因此我们得配合Arc去使用:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::sync::Arc;
<span class="hljs-keyword">use</span> std::sync::Mutex;

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>(*<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>);
<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span> &#123;&#125;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;
    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = &amp;<span class="hljs-title function_ invoke__">MyBox</span>(<span class="hljs-number">5</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(b));
    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;
        <span class="hljs-keyword">let</span> <span class="hljs-variable">_v1</span> =  v.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    &#125;);

    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
&#125;</code></pre></div>

<p>上面代码将智能指针v的所有权转移给新线程，同时v包含了一个引用类型b，当在新的线程中试图获取内部的引用时，会报错：</p>
<p>因为我们访问的引用实际上还是对主线程中的数据的借用，转移进来的仅仅是外层的智能指针引用。要解决很简单，为MyBox实现Sync:</p>
<div class="code-wrapper"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span> &#123;&#125;</code></pre></div>

<h2 id="6-7-总结"><a href="#6-7-总结" class="headerlink" title="6.7 总结"></a>6.7 总结</h2><p>通过上面的两个裸指针的例子，我们了解了如何实现Send和Sync，以及如何只实现Send而不实现Sync，简单总结下：</p>
<ul>
<li>实现Send的类型可以在线程间安全的传递其所有权, 实现Sync的类型可以在线程间安全的共享(通过引用)</li>
<li>绝大部分类型都实现了Send和Sync，常见的未实现的有：裸指针、Cell、RefCell、Rc 等</li>
<li>可以为自定义类型实现Send和Sync，但是需要unsafe代码块</li>
<li>可以为部分 Rust 中的类型实现Send、Sync，但是需要使用newtype，例如文中的裸指针例子</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/rust%E5%9C%A3%E7%BB%8F/" class="print-no-link">#rust圣经</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>RUST圣经-高阶学习-多线程并发和异步-下</div>
      <div>http://example.com/2025/02/26/rust圣经/RUST圣经-高阶学习-多线程并发和异步-下/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>BoBoDai</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 26, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/02/27/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-async_await%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%E4%B8%8A/" title="RUST圣经-高阶学习-async_await异步编程-上">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RUST圣经-高阶学习-async_await异步编程-上</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/21/rust%E5%9C%A3%E7%BB%8F/RUST%E5%9C%A3%E7%BB%8F-%E9%AB%98%E9%98%B6%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%BC%82%E6%AD%A5-%E4%B8%8A/" title="RUST圣经-高阶学习-多线程并发和异步-上">
                        <span class="hidden-mobile">RUST圣经-高阶学习-多线程并发和异步-上</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
